// Generated by CoffeeScript 1.12.4

/*
 * Usage

    hybrid_udp = require './hybrid_udp'

    server = new hybrid_udp.UDPServer
    server.on 'packet', (buf, addr, port) ->
       * buf is a Buffer instance
      console.log "server received: 0x#{buf.toString 'hex'}"
      if buf[0] is 0x04
         * shutdown server
        server.stop()
        console.log "server stopped"
    server.start 9999, "localhost", ->
      console.log "server started"

      client = new hybrid_udp.UDPClient
      client.start 9999, "localhost", ->
        console.log "client started"
        console.log "client: writing 0x010203"
        client.write new Buffer([0x01, 0x02, 0x03]), ->
          console.log "client: writing 0x040506 and waiting for ACK"
          client.writeReliable new Buffer([0x04, 0x05, 0x06]), ->
            console.log "client: received ACK"
            client.stop()
            console.log "client stopped"
 */

(function() {
  var FRAGMENT_HEADER_LEN, INITIAL_PACKET_ID, MAX_PACKET_ID, OLD_UDP_PACKET_TIME_THRESHOLD, PACKET_TYPE_ACK, PACKET_TYPE_REQUIRE_ACK, PACKET_TYPE_RESET, PACKET_TYPE_UNRELIABLE, RECEIVE_PACKET_ID_WINDOW, RESEND_TIMEOUT, UDPClient, UDPServer, dgram, events, logger, zeropad,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  events = require('events');

  dgram = require('dgram');

  logger = require('./logger');

  MAX_PACKET_ID = 255;

  FRAGMENT_HEADER_LEN = 2;

  RESEND_TIMEOUT = 100;

  PACKET_TYPE_UNRELIABLE = 0x01;

  PACKET_TYPE_REQUIRE_ACK = 0x02;

  PACKET_TYPE_ACK = 0x03;

  PACKET_TYPE_RESET = 0x04;

  OLD_UDP_PACKET_TIME_THRESHOLD = 1000;

  RECEIVE_PACKET_ID_WINDOW = 10;

  INITIAL_PACKET_ID = 0;

  zeropad = function(width, num) {
    num += '';
    while (num.length < width) {
      num = '0' + num;
    }
    return num;
  };

  exports.UDPClient = UDPClient = (function() {
    function UDPClient() {
      this.pendingPackets = [];
      this.newPacketId = 0;
      this.maxPacketSize = 8000;
      this.isInBlockMode = false;
      this.ackCallbacks = {};
      this.serverPort = null;
      this.serverHost = null;
      this.isStopped = false;
      this.socket = dgram.createSocket('udp4');
      this.socket.on('error', function(err) {
        logger.error("UDPServer socket error: " + err);
        return this.socket.close();
      });
      this.socket.on('message', (function(_this) {
        return function(msg, rinfo) {
          return _this.onMessage(msg, rinfo);
        };
      })(this));
    }

    UDPClient.prototype.start = function(serverPort, serverHost, callback) {
      this.serverPort = serverPort;
      this.serverHost = serverHost;
      return this.socket.bind(0, '0.0.0.0', (function(_this) {
        return function() {
          return _this.resetPacketId(callback);
        };
      })(this));
    };

    UDPClient.prototype.stop = function() {
      this.isStopped = true;
      return this.socket.close();
    };

    UDPClient.prototype.onMessage = function(msg, rinfo) {
      var packetId, packetType;
      packetType = msg[0];
      if (packetType === PACKET_TYPE_ACK) {
        packetId = msg[1];
        if (this.ackCallbacks[packetId] != null) {
          return this.ackCallbacks[packetId]();
        } else {
          return logger.warn("ACK is already processed for packetId " + packetId);
        }
      } else {
        logger.warn("unknown packet type: " + packetType + " len=" + msg.length);
        return logger.warn(msg);
      }
    };

    UDPClient.prototype.getNextPacketId = function() {
      var id;
      id = this.newPacketId;
      if (++this.newPacketId > MAX_PACKET_ID) {
        this.newPacketId = 0;
      }
      return id;
    };

    UDPClient.prototype.sendPacket = function(packetType, packetId, buf, callback) {
      var bufLen, endFragmentNumber, fragmentNumber, fragmentSize, sendData, sendNextFragment, sentCount, totalFragments, wroteLen;
      sendData = new Buffer(this.maxPacketSize);
      sendData[0] = packetType;
      sendData[1] = packetId;
      fragmentSize = this.maxPacketSize - FRAGMENT_HEADER_LEN - 2;
      if (fragmentSize <= 0) {
        throw new Error("maxPacketSize must be > " + (FRAGMENT_HEADER_LEN + 2));
      }
      bufLen = buf.length;
      totalFragments = Math.ceil(bufLen / fragmentSize);
      if (totalFragments > 256) {
        throw new Error("too many fragments: " + totalFragments + " (buf.length=" + bufLen + " / fragmentSize=" + fragmentSize + ")");
      }
      endFragmentNumber = totalFragments - 1;
      sendData[2] = endFragmentNumber;
      fragmentNumber = 0;
      wroteLen = 0;
      sentCount = 0;
      sendNextFragment = (function(_this) {
        return function() {
          var remainingLen, thisLen;
          if (wroteLen >= bufLen) {
            throw new Error("wroteLen (" + wroteLen + ") > bufLen (" + bufLen + ")");
          }
          remainingLen = bufLen - wroteLen;
          if (remainingLen < fragmentSize) {
            thisLen = remainingLen;
          } else {
            thisLen = fragmentSize;
          }
          sendData[3] = fragmentNumber;
          buf.copy(sendData, 4, wroteLen, wroteLen + thisLen);
          fragmentNumber++;
          return _this.socket.send(sendData, 0, thisLen + 4, _this.serverPort, _this.serverHost, function() {
            wroteLen += thisLen;
            sentCount++;
            if (sentCount === totalFragments) {
              return typeof callback === "function" ? callback() : void 0;
            } else {
              return sendNextFragment();
            }
          });
        };
      })(this);
      return sendNextFragment();
    };

    UDPClient.prototype.resetPacketId = function(callback) {
      var buf, isACKReceived;
      buf = new Buffer([PACKET_TYPE_RESET, INITIAL_PACKET_ID]);
      this.newPacketId = INITIAL_PACKET_ID + 1;
      isACKReceived = false;
      this.waitForACK(INITIAL_PACKET_ID, function() {
        isACKReceived = true;
        return typeof callback === "function" ? callback() : void 0;
      });
      this.socket.send(buf, 0, buf.length, this.serverPort, this.serverHost);
      return setTimeout((function(_this) {
        return function() {
          if (!isACKReceived && !_this.isStopped) {
            logger.warn("resend reset (no ACK received)");
            return _this.resetPacketId(callback);
          }
        };
      })(this), RESEND_TIMEOUT);
    };

    UDPClient.prototype.rawSend = function(buf, offset, length, callback) {
      return this.socket.send(buf, offset, length, this.serverPort, this.serverAddress, callback);
    };

    UDPClient.prototype.write = function(buf, callback) {
      var packetId;
      if (this.isInBlockMode) {
        this.pendingPackets.push([this.write].concat(slice.call(arguments)));
        return;
      }
      packetId = this.getNextPacketId();
      return this.sendPacket(PACKET_TYPE_UNRELIABLE, packetId, buf, callback);
    };

    UDPClient.prototype._writeReliableBypassBlock = function(buf, packetId, onSuccessCallback, onTimeoutCallback) {
      var isACKReceived;
      isACKReceived = false;
      this.waitForACK(packetId, function() {
        isACKReceived = true;
        return typeof onSuccessCallback === "function" ? onSuccessCallback() : void 0;
      });
      this.sendPacket(PACKET_TYPE_REQUIRE_ACK, packetId, buf);
      return setTimeout((function(_this) {
        return function() {
          if (!isACKReceived && !_this.isStopped) {
            logger.warn("resend " + packetId + " (no ACK received)");
            return onTimeoutCallback();
          }
        };
      })(this), RESEND_TIMEOUT);
    };

    UDPClient.prototype._writeReliable = function(buf, packetId, callback) {
      if (this.isInBlockMode) {
        this.pendingPackets.push([this._writeReliable].concat(slice.call(arguments)));
        return;
      }
      return this._writeReliableBypassBlock(buf, packetId, callback, (function(_this) {
        return function() {
          return _this._writeReliable(buf, packetId, callback);
        };
      })(this));
    };

    UDPClient.prototype.writeReliable = function(buf, callback) {
      var packetId;
      packetId = this.getNextPacketId();
      return this._writeReliable(buf, packetId, callback);
    };

    UDPClient.prototype.waitForACK = function(packetId, callback) {
      return this.ackCallbacks[packetId] = (function(_this) {
        return function() {
          delete _this.ackCallbacks[packetId];
          return typeof callback === "function" ? callback() : void 0;
        };
      })(this);
    };

    UDPClient.prototype.flushPendingPackets = function(callback) {
      var args, func, origCallback, packet;
      if (this.pendingPackets.length === 0) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      packet = this.pendingPackets.shift();
      func = packet[0];
      args = packet.slice(1);
      origCallback = args[func.length - 1];
      args[func.length - 1] = (function(_this) {
        return function() {
          _this.flushPendingPackets(callback);
          return typeof origCallback === "function" ? origCallback() : void 0;
        };
      })(this);
      return func.apply(this, args);
    };

    UDPClient.prototype._writeReliableBlocked = function(buf, packetId, callback) {
      return this._writeReliableBypassBlock(buf, packetId, callback, (function(_this) {
        return function() {
          return _this._writeReliableBlocked(buf, packetId, callback);
        };
      })(this));
    };

    UDPClient.prototype.writeReliableBlocked = function(buf, callback) {
      var packetId;
      if (this.isInBlockMode) {
        this.pendingPackets.push([this.writeReliableBlocked].concat(slice.call(arguments)));
        return;
      }
      this.isInBlockMode = true;
      packetId = this.getNextPacketId();
      return this._writeReliableBlocked(buf, packetId, (function(_this) {
        return function() {
          _this.isInBlockMode = false;
          return _this.flushPendingPackets(callback);
        };
      })(this));
    };

    UDPClient.prototype.fragment = function(buf, fragmentSize) {
      var fragments, remainingLen, thisLen;
      if (fragmentSize == null) {
        fragmentSize = maxPacketSize;
      }
      fragments = [];
      remainingLen = buf.length;
      while (remainingLen > 0) {
        if (remainingLen < fragmentSize) {
          thisLen = remainingLen;
        } else {
          thisLen = fragmentSize;
        }
        fragments.push(buf.slice(0, thisLen));
        buf = buf.slice(thisLen);
      }
      return fragments;
    };

    return UDPClient;

  })();

  exports.UDPServer = UDPServer = (function(superClass) {
    extend(UDPServer, superClass);

    function UDPServer() {
      this.socket = dgram.createSocket('udp4');
      this.socket.on('error', function(err) {
        logger.error("UDPServer socket error: " + err);
        return this.socket.close();
      });
      this.socket.on('message', (function(_this) {
        return function(msg, rinfo) {
          return _this.onReceiveMessage(msg, rinfo);
        };
      })(this));
      this.isStopped = false;
      this.resetServerState();
    }

    UDPServer.prototype.resetServerState = function() {
      this.videoReceiveBuf = {};
      this.processedPacketId = null;
      this.latestPacketId = null;
      this.bufferedPackets = {};
      return this.packetLastReceiveTime = {};
    };

    UDPServer.prototype.onReceiveMessage = function(msg, rinfo) {
      var e, endFragmentNumber, fragmentNumber, i, isMissing, j, packetId, packetType, receivedBuf, ref, targetBuf;
      packetType = msg[0];
      packetId = msg[1];
      endFragmentNumber = msg[2];
      fragmentNumber = msg[3];
      if (packetType === PACKET_TYPE_RESET) {
        this.resetServerState();
        this.latestPacketId = packetId;
        this.processedPacketId = packetId;
        this.sendAck(packetId, rinfo.port, rinfo.address);
        return;
      }
      this.packetLastReceiveTime[packetId] = Date.now();
      if (this.latestPacketId != null) {
        if ((packetId <= this.latestPacketId + RECEIVE_PACKET_ID_WINDOW && packetId > this.latestPacketId) || packetId < this.latestPacketId - 50) {
          this.latestPacketId = packetId;
        }
      } else {
        this.latestPacketId = packetId;
      }
      if (endFragmentNumber > 0) {
        if (this.videoReceiveBuf[packetId] != null) {
          if (Date.now() - this.videoReceiveBuf[packetId].time >= OLD_UDP_PACKET_TIME_THRESHOLD) {
            logger.warn("drop stale buffer of packetId " + packetId);
            this.videoReceiveBuf[packetId] = null;
          }
        }
        if (this.videoReceiveBuf[packetId] == null) {
          this.videoReceiveBuf[packetId] = {
            buf: [],
            totalReceivedLength: 0
          };
        }
        targetBuf = this.videoReceiveBuf[packetId];
        targetBuf.buf[fragmentNumber] = msg.slice(4);
        targetBuf.time = Date.now();
        targetBuf.totalReceivedLength += msg.length - 4;
        isMissing = false;
        for (i = j = 0, ref = endFragmentNumber; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (targetBuf.buf[i] == null) {
            isMissing = true;
            break;
          }
        }
        if (!isMissing) {
          try {
            receivedBuf = Buffer.concat(targetBuf.buf);
            return this.onReceivePacket({
              packetType: packetType,
              packetId: packetId,
              port: rinfo.port,
              address: rinfo.address,
              body: receivedBuf
            });
          } catch (error) {
            e = error;
            logger.error("concat/receive error for packetId=" + packetId + ": " + e);
            logger.error(e.stack);
            return logger.error(targetBuf.buf);
          } finally {
            delete this.videoReceiveBuf[packetId];
            delete this.packetLastReceiveTime[packetId];
          }
        }
      } else {
        receivedBuf = msg.slice(4);
        delete this.videoReceiveBuf[packetId];
        delete this.packetLastReceiveTime[packetId];
        return this.onReceivePacket({
          packetType: packetType,
          packetId: packetId,
          port: rinfo.port,
          address: rinfo.address,
          body: receivedBuf
        });
      }
    };

    UDPServer.prototype.consumeBufferedPacketsFrom = function(packetId) {
      var oldEnoughTime;
      oldEnoughTime = Date.now() - OLD_UDP_PACKET_TIME_THRESHOLD;
      while (true) {
        if (this.bufferedPackets[packetId] == null) {
          break;
        }
        if (this.packetLastReceiveTime[packetId] <= oldEnoughTime) {
          logger.warn("packet " + packetId + " is too old");
          break;
        }
        this.onCompletePacket(this.bufferedPackets[packetId]);
        delete this.bufferedPackets[packetId];
        this.processedPacketId = packetId;
        if (packetId === MAX_PACKET_ID) {
          packetId = 0;
        } else {
          packetId++;
        }
      }
    };

    UDPServer.prototype.deleteOldBufferedPackets = function() {
      var isDoneSomething, j, nextPacketId, oldEnoughTime, oldestUnprocessedPacketId, packetId, ref, ref1, timeDiff;
      if (this.processedPacketId === this.latestPacketId) {
        return;
      }
      isDoneSomething = false;
      if (this.processedPacketId === MAX_PACKET_ID) {
        oldestUnprocessedPacketId = 0;
      } else {
        oldestUnprocessedPacketId = this.processedPacketId + 1;
      }
      oldEnoughTime = Date.now() - OLD_UDP_PACKET_TIME_THRESHOLD;
      for (packetId = j = ref = oldestUnprocessedPacketId, ref1 = this.latestPacketId; ref <= ref1 ? j < ref1 : j > ref1; packetId = ref <= ref1 ? ++j : --j) {
        if (this.packetLastReceiveTime[packetId] == null) {
          this.packetLastReceiveTime[packetId] = Date.now();
        }
        if (this.packetLastReceiveTime[packetId] <= oldEnoughTime) {
          timeDiff = oldEnoughTime - this.packetLastReceiveTime[packetId];
          logger.warn("dropped packet " + packetId + ": " + timeDiff + " ms late");
          isDoneSomething = true;
          if (this.bufferedPackets[packetId] != null) {
            delete this.bufferedPackets[packetId];
          }
          if (this.processedPacketId === MAX_PACKET_ID) {
            this.processedPacketId = 0;
          } else {
            this.processedPacketId++;
          }
        } else {
          break;
        }
      }
      if (isDoneSomething) {
        if (this.processedPacketId === MAX_PACKET_ID) {
          nextPacketId = 0;
        } else {
          nextPacketId = this.processedPacketId + 1;
        }
        this.consumeBufferedPacketsFrom(nextPacketId);
      }
    };

    UDPServer.prototype.onReceivePacket = function(packet) {
      var anticipatingPacketId, nextPacketId, ref;
      anticipatingPacketId = this.processedPacketId + 1;
      if (anticipatingPacketId === MAX_PACKET_ID + 1) {
        anticipatingPacketId = 0;
      }
      if (packet.packetId === anticipatingPacketId) {
        this.processedPacketId = packet.packetId;
        this.onCompletePacket(packet);
        if (packet.packetId === MAX_PACKET_ID) {
          nextPacketId = 0;
        } else {
          nextPacketId = packet.packetId + 1;
        }
        return this.consumeBufferedPacketsFrom(nextPacketId);
      } else {
        if ((this.processedPacketId - RECEIVE_PACKET_ID_WINDOW <= (ref = packet.packetId) && ref <= this.processedPacketId)) {
          logger.warn("duplicated packet " + packet.packetId);
          if (packet.packetType === PACKET_TYPE_REQUIRE_ACK) {
            this.sendAck(packet.packetId, packet.port, packet.address);
          }
          return;
        }
        this.bufferedPackets[packet.packetId] = packet;
        return this.deleteOldBufferedPackets();
      }
    };

    UDPServer.prototype.onCompletePacket = function(packet) {
      if (packet.packetType === PACKET_TYPE_REQUIRE_ACK) {
        this.sendAck(packet.packetId, packet.port, packet.address);
      }
      return setTimeout((function(_this) {
        return function() {
          return _this.emit('packet', packet.body, packet.address, packet.port);
        };
      })(this), 0);
    };

    UDPServer.prototype.sendAck = function(packetId, port, address, callback) {
      var buf;
      buf = new Buffer([PACKET_TYPE_ACK, packetId]);
      return this.socket.send(buf, 0, buf.length, port, address, callback);
    };

    UDPServer.prototype.start = function(port, address, callback) {
      return this.socket.bind(port, address, callback);
    };

    UDPServer.prototype.stop = function() {
      this.isStopped = true;
      return this.socket.close();
    };

    return UDPServer;

  })(events.EventEmitter);

}).call(this);
