// Generated by CoffeeScript 1.12.4
(function() {
  var DAY_NAMES, DEFAULT_SERVER_NAME, DIRECTORY_INDEX_FILENAME, GZIP_SIZE_THRESHOLD, HTTPHandler, MONTH_NAMES, STATIC_DIR, Sequent, TEMPLATE_DIR, api, ejs, fs, logger, path, spawn, zeropad, zlib;

  ejs = require('ejs');

  path = require('path');

  fs = require('fs');

  zlib = require('zlib');

  spawn = require('child_process').spawn;

  Sequent = require('sequent');

  logger = require('./logger');

  TEMPLATE_DIR = __dirname + "/template";

  STATIC_DIR = __dirname + "/public";

  DIRECTORY_INDEX_FILENAME = 'index.html';

  DEFAULT_SERVER_NAME = 'node-rtsp-rtmp-server';

  GZIP_SIZE_THRESHOLD = 300;

  DAY_NAMES = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

  MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

  zeropad = function(width, num) {
    num += '';
    while (num.length < width) {
      num = '0' + num;
    }
    return num;
  };

  HTTPHandler = (function() {
    function HTTPHandler(opts) {
      var ref, ref1;
      this.serverName = (ref = opts != null ? opts.serverName : void 0) != null ? ref : DEFAULT_SERVER_NAME;
      this.documentRoot = (ref1 = opts != null ? opts.documentRoot : void 0) != null ? ref1 : STATIC_DIR;
    }

    HTTPHandler.prototype.setServerName = function(name) {
      return this.serverName = name;
    };

    HTTPHandler.prototype.handlePath = function(filepath, req, callback) {
      var opts;
      if (filepath === '/crossdomain.xml') {
        return this.respondCrossDomainXML(req, callback);
      } else if (filepath === '/ping') {
        return this.respondText('pong', req, callback);
      } else if (filepath === '/list') {
        opts = {
          files: ['foo', 'bar', 'baz']
        };
        return fs.readFile(TEMPLATE_DIR + "/list.ejs", {
          encoding: 'utf8'
        }, (function(_this) {
          return function(err, template) {
            var html;
            if (err) {
              logger.error(err);
              return _this.serverError(req, callback);
            } else {
              html = ejs.render(template, opts);
              return _this.respondHTML(html, req, callback);
            }
          };
        })(this));
      } else if (filepath === '/302') {
        return this.redirect('/new-url', req, callback);
      } else if (filepath === '/404') {
        return this.notFound(req, callback);
      } else if (filepath === '/400') {
        return this.badRequest(req, callback);
      } else if (filepath === '/500') {
        return this.serverError(req, callback);
      } else {
        return this.respondStaticPath(this.documentRoot + "/" + filepath.slice(1), req, callback);
      }
    };

    HTTPHandler.prototype.createHeader = function(params) {
      var header, protocol, ref, ref1, ref2, statusMessage;
      protocol = (ref = params.protocol) != null ? ref : 'HTTP/1.1';
      statusMessage = '200 OK';
      if ((params != null ? params.statusCode : void 0) != null) {
        if (params.statusCode === 404) {
          statusMessage = '404 Not Found';
        } else if (params.statusCode === 500) {
          statusMessage = '500 Internal Server Error';
        } else if (params.statusCode === 302) {
          statusMessage = '302 Found';
        } else if (params.statusCode === 301) {
          statusMessage = '301 Moved Permanently';
        } else if (params.statusCode === 206) {
          statusMessage = '206 Partial Content';
        } else if (params.statusCode === 400) {
          statusMessage = '400 Bad Request';
        } else if (params.statusCode === 401) {
          statusMessage = '401 Unauthorized';
        }
      }
      header = protocol + " " + statusMessage + "\nDate: " + (api.getDateHeader()) + "\nServer: " + this.serverName + "\n";
      if ((params != null ? (ref1 = params.req) != null ? (ref2 = ref1.headers.connection) != null ? ref2.toLowerCase() : void 0 : void 0 : void 0) === 'keep-alive') {
        header += 'Connection: keep-alive\n';
      } else {
        header += 'Connection: close\n';
      }
      if ((params != null ? params.contentLength : void 0) != null) {
        header += "Content-Length: " + params.contentLength + "\n";
      }
      if ((params != null ? params.location : void 0) != null) {
        header += "Location: " + params.location + "\n";
      }
      if ((params != null ? params.contentType : void 0) != null) {
        header += "Content-Type: " + params.contentType + "\n";
      }
      if ((params != null ? params.contentEncoding : void 0) != null) {
        header += "Content-Encoding: " + params.contentEncoding + "\n";
      }
      if ((params != null ? params.contentRange : void 0) != null) {
        header += "Content-Range: " + params.contentRange + "\n";
      }
      if ((params != null ? params.authenticate : void 0) != null) {
        header += "WWW-Authenticate: " + params.authenticate + "\n";
      }
      return header.replace(/\n/g, '\r\n') + '\r\n';
    };

    HTTPHandler.prototype.redirect = function(path, req, callback) {
      var headerBytes;
      headerBytes = new Buffer(this.createHeader({
        statusCode: 302,
        location: path,
        req: req,
        contentLength: 0
      }));
      return callback(null, headerBytes);
    };

    HTTPHandler.prototype.notFound = function(req, callback) {
      var allBytes, bodyBytes, bodyLength, headerBytes;
      bodyBytes = new Buffer('Not Found', 'utf8');
      bodyLength = bodyBytes.length;
      headerBytes = new Buffer(this.createHeader({
        statusCode: 404,
        contentLength: bodyLength,
        req: req,
        contentType: "text/plain; charset=utf-8"
      }), 'utf8');
      allBytes = Buffer.concat([headerBytes, bodyBytes], headerBytes.length + bodyLength);
      return callback(null, allBytes);
    };

    HTTPHandler.prototype.respondTextWithHeader = function(str, req, opts, callback) {
      var allBytes, headerBytes, headerOpts, name, textBytes, textLength, value;
      textBytes = new Buffer(str + '', 'utf8');
      textLength = textBytes.length;
      headerOpts = {
        statusCode: 200,
        contentLength: textLength,
        req: req,
        contentType: "text/plain; charset=utf-8"
      };
      if (opts != null) {
        for (name in opts) {
          value = opts[name];
          headerOpts[name] = value;
        }
      }
      headerBytes = new Buffer(this.createHeader(headerOpts), 'utf8');
      allBytes = Buffer.concat([headerBytes, textBytes], headerBytes.length + textLength);
      return callback(null, allBytes);
    };

    HTTPHandler.prototype.respondJavaScript = function(str, req, callback) {
      return this.respondTextWithHeader(str, req, {
        contentType: 'application/javascript; charset=utf-8'
      }, callback);
    };

    HTTPHandler.prototype.respondText = function(str, req, callback) {
      return this.respondTextWithHeader(str, req, null, callback);
    };

    HTTPHandler.prototype.treatCompress = function(bytes, req, callback) {
      var acceptEncoding;
      if (bytes.length < GZIP_SIZE_THRESHOLD) {
        callback(null, bytes, null);
        return;
      }
      acceptEncoding = req.headers['accept-encoding'];
      if (acceptEncoding == null) {
        callback(null, bytes, null);
        return;
      }
      acceptEncoding = acceptEncoding.toLowerCase();
      if (/\bgzip\b/.test(acceptEncoding)) {
        return zlib.gzip(bytes, function(err, compressedBytes) {
          if (err) {
            callback(err);
          } else {
            callback(null, compressedBytes, 'gzip');
          }
        });
      } else if (/\bdeflate\b/.test(acceptEncoding)) {
        return zlib.deflate(bytes, function(err, compressedBytes) {
          if (err) {
            return callback(err);
          } else {
            return callback(null, compressedBytes, 'deflate');
          }
        });
      } else {
        return callback(null, bytes, null);
      }
    };

    HTTPHandler.prototype.respondJS = function(content, req, callback) {
      var contentBytes;
      contentBytes = new Buffer(content, 'utf8');
      return this.treatCompress(contentBytes, req, (function(_this) {
        return function(err, contentBytes, encoding) {
          var allBytes, contentLength, headerBytes;
          if (err) {
            callback(err);
            return;
          }
          contentLength = contentBytes.length;
          headerBytes = new Buffer(_this.createHeader({
            contentLength: contentLength,
            req: req,
            contentEncoding: encoding,
            contentType: 'application/javascript'
          }), 'utf8');
          allBytes = Buffer.concat([headerBytes, contentBytes], headerBytes.length + contentLength);
          return callback(null, allBytes);
        };
      })(this));
    };

    HTTPHandler.prototype.respondHTML = function(html, req, callback) {
      var htmlBytes;
      htmlBytes = new Buffer(html, 'utf8');
      return this.treatCompress(htmlBytes, req, (function(_this) {
        return function(err, htmlBytes, encoding) {
          var allBytes, headerBytes, htmlLength;
          if (err) {
            callback(err);
            return;
          }
          htmlLength = htmlBytes.length;
          headerBytes = new Buffer(_this.createHeader({
            contentLength: htmlLength,
            req: req,
            contentEncoding: encoding,
            contentType: "text/html; charset=utf-8"
          }), 'utf8');
          allBytes = Buffer.concat([headerBytes, htmlBytes], headerBytes.length + htmlLength);
          return callback(null, allBytes);
        };
      })(this));
    };

    HTTPHandler.prototype.badRequest = function(req, callback) {
      var allBytes, bodyBytes, bodyLength, headerBytes;
      bodyBytes = new Buffer('Bad Request', 'utf8');
      bodyLength = bodyBytes.length;
      headerBytes = new Buffer(this.createHeader({
        statusCode: 400,
        contentLength: bodyLength,
        req: req,
        contentType: "text/plain; charset=utf-8"
      }), 'utf8');
      allBytes = Buffer.concat([headerBytes, bodyBytes], headerBytes.length + bodyLength);
      return callback(null, allBytes);
    };

    HTTPHandler.prototype.serverError = function(req, callback) {
      var allBytes, bodyBytes, bodyLength, headerBytes;
      bodyBytes = new Buffer('Server Error', 'utf8');
      bodyLength = bodyBytes.length;
      headerBytes = new Buffer(this.createHeader({
        statusCode: 500,
        contentLength: bodyLength,
        req: req,
        contentType: "text/plain; charset=utf-8"
      }), 'utf8');
      allBytes = Buffer.concat([headerBytes, bodyBytes], headerBytes.length + bodyLength);
      return callback(null, allBytes);
    };

    HTTPHandler.prototype.respondCrossDomainXML = function(req, callback) {
      var content, opts;
      content = "<?xml version=\"1.0\"?>\n<!DOCTYPE cross-domain-policy SYSTEM \"http://www.adobe.com/xml/dtds/cross-domain-policy.dtd\">\n<cross-domain-policy>\n    <site-control permitted-cross-domain-policies=\"all\"/>\n    <allow-access-from domain=\"*\" secure=\"false\"/>\n    <allow-http-request-headers-from domain=\"*\" headers=\"*\" secure=\"false\"/>\n</cross-domain-policy>\n";
      opts = {
        contentType: 'text/x-cross-domain-policy'
      };
      return this.respondTextWithHeader(content, req, opts, callback);
    };

    HTTPHandler.prototype.respondStaticPath = function(filepath, req, callback) {
      if (filepath === '') {
        filepath = DIRECTORY_INDEX_FILENAME;
      } else if (/\/$/.test(filepath)) {
        filepath += DIRECTORY_INDEX_FILENAME;
      }
      if (filepath.indexOf('..') !== -1) {
        this.badRequest(req, callback);
        return;
      }
      return this.respondFile(filepath, req, callback);
    };

    HTTPHandler.prototype.respondFile = function(filepath, req, callback) {
      return fs.exists(filepath, (function(_this) {
        return function(exists) {
          if (exists) {
            return fs.stat(filepath, function(err, stat) {
              var seq;
              if (err) {
                logger.error("stat error: " + filepath);
                _this.serverError(req, callback);
                return;
              }
              seq = new Sequent;
              if (stat.isDirectory()) {
                filepath += "/" + DIRECTORY_INDEX_FILENAME;
                fs.exists(filepath, function(exists) {
                  if (exists) {
                    return seq.done();
                  } else {
                    return _this.notFound(req, callback);
                  }
                });
              } else {
                seq.done();
              }
              return seq.wait(1, function() {
                return fs.readFile(filepath, {
                  encoding: null,
                  flag: 'r'
                }, function(err, contentBuf) {
                  var contentRangeHeader, contentType, doCompress, from, header, headerBuf, match, statusCode, to;
                  if (err) {
                    logger.error("readFile error: " + filepath);
                    _this.serverError(req, callback);
                    return;
                  }
                  contentRangeHeader = null;
                  if (req.headers.range != null) {
                    if ((match = /^bytes=(\d+)?-(\d+)?$/.exec(req.headers.range)) != null) {
                      from = match[1] != null ? parseInt(match[1]) : null;
                      to = match[2] != null ? parseInt(match[2]) : null;
                      logger.debug("Range from " + from + " to " + to);
                      if ((from == null) && (to != null)) {
                        contentRangeHeader = "bytes " + (contentBuf.length - to) + "-" + (contentBuf.length - 1) + "/" + contentBuf.length;
                        contentBuf = contentBuf.slice(contentBuf.length - to, contentBuf.length);
                      } else if ((from != null) && (to == null)) {
                        if (from > 0) {
                          contentRangeHeader = "bytes " + from + "-" + (contentBuf.length - 1) + "/" + contentBuf.length;
                          contentBuf = contentBuf.slice(from, contentBuf.length);
                        }
                      } else if ((from != null) && (to != null)) {
                        contentRangeHeader = "bytes " + from + "-" + to + "/" + contentBuf.length;
                        contentBuf = contentBuf.slice(from, to + 1);
                      }
                    } else {
                      logger.error("[Range spec " + req.headers.range + " is not supported]");
                    }
                  }
                  if (err) {
                    _this.serverError(req, callback);
                    return;
                  }
                  contentType = 'text/html; charset=utf-8';
                  doCompress = true;
                  if (/\.m3u8$/.test(filepath)) {
                    contentType = 'application/x-mpegURL';
                  } else if (/\.ts$/.test(filepath)) {
                    contentType = 'video/MP2T';
                    doCompress = false;
                  } else if (/\.mp4$/.test(filepath)) {
                    contentType = 'video/mp4';
                    doCompress = false;
                  } else if (/\.3gpp?$/.test(filepath)) {
                    contentType = 'video/3gpp';
                    doCompress = false;
                  } else if (/\.jpg$/.test(filepath)) {
                    contentType = 'image/jpeg';
                    doCompress = false;
                  } else if (/\.gif$/.test(filepath)) {
                    contentType = 'image/gif';
                    doCompress = false;
                  } else if (/\.png$/.test(filepath)) {
                    contentType = 'image/png';
                    doCompress = false;
                  } else if (/\.swf$/.test(filepath)) {
                    contentType = 'application/x-shockwave-flash';
                    doCompress = false;
                  } else if (/\.css$/.test(filepath)) {
                    contentType = 'text/css';
                  } else if (/\.js$/.test(filepath)) {
                    contentType = 'application/javascript';
                  } else if (/\.txt$/.test(filepath)) {
                    contentType = 'text/plain; charset=utf-8';
                  }
                  if (contentRangeHeader != null) {
                    statusCode = 206;
                  } else {
                    statusCode = 200;
                  }
                  if (doCompress) {
                    return _this.treatCompress(contentBuf, req, function(err, compressedBytes, encoding) {
                      var header, headerBuf;
                      if (err) {
                        callback(err);
                        return;
                      }
                      header = _this.createHeader({
                        statusCode: statusCode,
                        contentType: contentType,
                        contentLength: compressedBytes.length,
                        req: req,
                        contentRange: contentRangeHeader,
                        contentEncoding: encoding
                      });
                      headerBuf = new Buffer(header, 'utf8');
                      return callback(null, [headerBuf, compressedBytes]);
                    });
                  } else {
                    header = _this.createHeader({
                      statusCode: statusCode,
                      contentType: contentType,
                      contentLength: contentBuf.length,
                      req: req,
                      contentRange: contentRangeHeader
                    });
                    headerBuf = new Buffer(header, 'utf8');
                    return callback(null, [headerBuf, contentBuf]);
                  }
                });
              });
            });
          } else {
            logger.warn("[http] Requested file not found: " + filepath);
            return _this.notFound(req, callback);
          }
        };
      })(this));
    };

    return HTTPHandler;

  })();

  api = {
    HTTPHandler: HTTPHandler,
    getDateHeader: function() {
      var d;
      d = new Date;
      return (DAY_NAMES[d.getUTCDay()] + ", " + (d.getUTCDate()) + " " + MONTH_NAMES[d.getUTCMonth()]) + (" " + (d.getUTCFullYear()) + " " + (zeropad(2, d.getUTCHours())) + ":" + (zeropad(2, d.getUTCMinutes()))) + (":" + (zeropad(2, d.getUTCSeconds())) + " UTC");
    },
    parseRequest: function(str) {
      var body, decodedURI, e, headerPart, headers, i, j, len, line, lines, method, params, protocol, protocolName, protocolVersion, ref, ref1, slashPos, uri;
      ref = str.split('\r\n\r\n'), headerPart = ref[0], body = ref[1];
      lines = headerPart.split(/\r\n/);
      ref1 = lines[0].split(/\s+/), method = ref1[0], uri = ref1[1], protocol = ref1[2];
      if (protocol != null) {
        slashPos = protocol.indexOf('/');
        if (slashPos !== -1) {
          protocolName = protocol.slice(0, slashPos);
          protocolVersion = protocol.slice(slashPos + 1);
        }
      }
      headers = {};
      for (i = j = 0, len = lines.length; j < len; i = ++j) {
        line = lines[i];
        if (i === 0) {
          continue;
        }
        if (/^\s*$/.test(line)) {
          continue;
        }
        params = line.split(": ");
        headers[params[0].toLowerCase()] = params[1];
      }
      try {
        decodedURI = decodeURIComponent(uri);
      } catch (error) {
        e = error;
        logger.error("error: failed to decode URI: " + uri);
        return null;
      }
      return {
        method: method,
        uri: decodedURI,
        protocol: protocol,
        protocolName: protocolName,
        protocolVersion: protocolVersion,
        headers: headers,
        body: body,
        headerBytes: Buffer.byteLength(headerPart, 'utf8')
      };
    }
  };

  module.exports = api;

}).call(this);
