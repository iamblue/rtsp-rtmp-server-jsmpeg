// Generated by CoffeeScript 1.12.4
(function() {
  var AVC_PACKET_TYPE_END_OF_SEQUENCE, AVC_PACKET_TYPE_NALU, AVC_PACKET_TYPE_SEQUENCE_HEADER, Bits, DEBUG_INCOMING_RTMP_PACKETS, DEBUG_INCOMING_STREAM_DATA, DEBUG_OUTGOING_RTMP_PACKETS, RTMPServer, RTMPSession, RTMPTSession, RTMPT_SEND_REQUEST_BUFFER_SIZE, SESSION_STATE_HANDSHAKE_DONE, SESSION_STATE_HANDSHAKE_ONGOING, SESSION_STATE_NEW, Sequent, TIMESTAMP_ROUNDOFF, aac, api, avstreams, clearQueuedRTMPMessages, clientMaxId, codec_utils, config, convertPTSToMilliseconds, counter, createAMF0CommandMessage, createAMF0CommandMessageParams, createAMF0Data, createAMF0DataMessage, createAMF0DataMessageParams, createAMF0ECMAArray, createAMF0Object, createAMF0PropertyList, createAMF0StrictArray, createAudioMessage, createMessageHeader, createRTMPAggregateMessage, createRTMPMessage, createRTMPType1Message, createVideoMessage, crypto, flushRTMPMessages, flv, generateClientID, generateNewClientID, generateNewSessionID, generateSessionID, h264, logger, net, parseAMF0CommandMessage, parseAMF0Data, parseAMF0DataMessage, parseAMF0ECMAArray, parseAMF0Object, parseAMF0StrictArray, parseAcknowledgementMessage, parseIEEE754Double, parseUserControlMessage, queueAudioMessage, queueRTMPMessages, queueVideoMessage, queuedRTMPMessages, rtmp_handshake, rtmptSessions, rtmptSessionsCount, serializeAMF0DataMessage, sessions, sessionsCount, url,
    slice = [].slice;

  net = require('net');

  url = require('url');

  crypto = require('crypto');

  Sequent = require('sequent');

  rtmp_handshake = require('./rtmp_handshake');

  codec_utils = require('./codec_utils');

  config = require('./config');

  h264 = require('./h264');

  aac = require('./aac');

  flv = require('./flv');

  avstreams = require('./avstreams');

  logger = require('./logger');

  Bits = require('./bits');

  SESSION_STATE_NEW = 1;

  SESSION_STATE_HANDSHAKE_ONGOING = 2;

  SESSION_STATE_HANDSHAKE_DONE = 3;

  AVC_PACKET_TYPE_SEQUENCE_HEADER = 0;

  AVC_PACKET_TYPE_NALU = 1;

  AVC_PACKET_TYPE_END_OF_SEQUENCE = 2;

  TIMESTAMP_ROUNDOFF = 4294967296;

  DEBUG_INCOMING_STREAM_DATA = false;

  DEBUG_INCOMING_RTMP_PACKETS = false;

  DEBUG_OUTGOING_RTMP_PACKETS = false;

  RTMPT_SEND_REQUEST_BUFFER_SIZE = 10;

  sessionsCount = 0;

  sessions = {};

  rtmptSessionsCount = 0;

  rtmptSessions = {};

  clientMaxId = 0;

  queuedRTMPMessages = {};

  generateNewClientID = function() {
    var clientID;
    clientID = generateClientID();
    while (sessions[clientID] != null) {
      clientID = generateClientID();
    }
    return clientID;
  };

  generateClientID = function() {
    var clientID, i, j, numPossible, possible;
    possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    numPossible = possible.length;
    clientID = '';
    for (i = j = 0; j <= 7; i = ++j) {
      clientID += possible.charAt((Math.random() * numPossible) | 0);
    }
    return clientID;
  };

  parseAcknowledgementMessage = function(buf) {
    var sequenceNumber;
    sequenceNumber = (buf[0] * Math.pow(256, 3)) + (buf[1] << 16) + (buf[2] << 8) + buf[3];
    return {
      sequenceNumber: sequenceNumber
    };
  };

  convertPTSToMilliseconds = function(pts) {
    return Math.floor(pts / 90);
  };

  createAudioMessage = function(params) {
    var audioMessage;
    return audioMessage = createRTMPMessage({
      chunkStreamID: 4,
      timestamp: params.timestamp,
      messageTypeID: 0x08,
      messageStreamID: 1,
      body: params.body
    }, params.chunkSize);
  };

  clearQueuedRTMPMessages = function(stream) {
    if (queuedRTMPMessages[stream.id] != null) {
      return queuedRTMPMessages[stream.id] = [];
    }
  };

  queueRTMPMessages = function(stream, messages, params) {
    var j, len1, message, ref;
    for (j = 0, len1 = messages.length; j < len1; j++) {
      message = messages[j];
      message.originalTimestamp = message.timestamp;
    }
    if (queuedRTMPMessages[stream.id] != null) {
      (ref = queuedRTMPMessages[stream.id]).push.apply(ref, messages);
    } else {
      queuedRTMPMessages[stream.id] = slice.call(messages);
    }
    return flushRTMPMessages(stream, params);
  };

  queueVideoMessage = function(stream, params) {
    params.avType = 'video';
    params.chunkStreamID = 4;
    params.messageTypeID = 0x09;
    params.messageStreamID = 1;
    params.originalTimestamp = params.timestamp;
    if (queuedRTMPMessages[stream.id] != null) {
      queuedRTMPMessages[stream.id].push(params);
    } else {
      queuedRTMPMessages[stream.id] = [params];
    }
    return setImmediate(function() {
      return flushRTMPMessages(stream);
    });
  };

  queueAudioMessage = function(stream, params) {
    params.avType = 'audio';
    params.chunkStreamID = 4;
    params.messageTypeID = 0x08;
    params.messageStreamID = 1;
    params.originalTimestamp = params.timestamp;
    if (queuedRTMPMessages[stream.id] != null) {
      queuedRTMPMessages[stream.id].push(params);
    } else {
      queuedRTMPMessages[stream.id] = [params];
    }
    return setImmediate(function() {
      return flushRTMPMessages(stream);
    });
  };

  createVideoMessage = function(params) {
    var videoMessage;
    return videoMessage = createRTMPMessage({
      chunkStreamID: 4,
      timestamp: params.timestamp,
      messageTypeID: 0x09,
      messageStreamID: 1,
      body: params.body
    }, params.chunkSize);
  };

  parseUserControlMessage = function(buf) {
    var eventData, eventType, message;
    eventType = (buf[0] << 8) + buf[1];
    eventData = buf.slice(2);
    message = {
      eventType: eventType,
      eventData: eventData
    };
    if (eventType === 3) {
      message.streamID = (eventData[0] << 24) + (eventData[1] << 16) + (eventData[2] << 8) + eventData[3];
      message.bufferLength = (eventData[4] << 24) + (eventData[5] << 16) + (eventData[6] << 8) + eventData[7];
    }
    return message;
  };

  parseIEEE754Double = function(buf) {
    var bitIndex, bitValue, byteIndex, exponent, fraction, i, j, sign, value;
    sign = buf[0] >> 7;
    exponent = ((buf[0] & 0x7f) << 4) + (buf[1] >> 4);
    exponent -= 1023;
    fraction = 1;
    for (i = j = 0; j <= 51; i = ++j) {
      byteIndex = 1 + parseInt((i + 4) / 8);
      bitIndex = 7 - (i + 4) % 8;
      bitValue = (buf[byteIndex] >> bitIndex) & 0x1;
      if (bitValue > 0) {
        fraction += Math.pow(2, -(i + 1));
      }
    }
    value = fraction * Math.pow(2, exponent);
    if (sign === 1) {
      value = -value;
    }
    return value;
  };

  parseAMF0StrictArray = function(buf) {
    var arr, len, readLen, result;
    arr = [];
    len = (buf[0] << 24) + (buf[1] << 16) + (buf[2] << 8) + buf[3];
    readLen = 4;
    while (--len >= 0) {
      result = parseAMF0Data(buf.slice(readLen));
      arr.push(result.value);
      readLen += result.readLen;
    }
    return {
      value: arr,
      readLen: readLen
    };
  };

  parseAMF0ECMAArray = function(buf) {
    var count, result;
    count = (buf[0] << 24) + (buf[1] << 16) + (buf[2] << 8) + buf[3];
    result = parseAMF0Object(buf.slice(4), count);
    result.readLen += 4;
    return result;
  };

  parseAMF0Object = function(buf, maxItems) {
    var bufLen, items, name, nameLen, obj, readLen, result;
    if (maxItems == null) {
      maxItems = null;
    }
    obj = {};
    bufLen = buf.length;
    readLen = 0;
    items = 0;
    if ((maxItems == null) || (maxItems > 0)) {
      while (readLen < bufLen) {
        nameLen = (buf[readLen++] << 8) + buf[readLen++];
        if (nameLen > 0) {
          name = buf.toString('utf8', readLen, readLen + nameLen);
          readLen += nameLen;
        } else {
          name = null;
        }
        result = parseAMF0Data(buf.slice(readLen));
        readLen += result.readLen;
        if (result.type === 'object-end-marker') {
          break;
        } else {
          items++;
          if ((maxItems != null) && (items > maxItems)) {
            logger.warn("warn: illegal AMF0 data: force break because items (" + items + ") > maxItems (" + maxItems + ")");
            break;
          }
        }
        if (name != null) {
          obj[name] = result.value;
        } else {
          logger.warn("warn: illegal AMF0 data: object key for value " + result.value + " is zero length");
        }
      }
    }
    return {
      value: obj,
      readLen: readLen
    };
  };

  serializeAMF0DataMessage = function(parsedObject) {
    var bufs, j, len1, object, ref;
    bufs = [];
    ref = parsedObject.objects;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      object = ref[j];
      bufs.push(createAMF0Data(object.value));
    }
    return Buffer.concat(bufs);
  };

  parseAMF0DataMessage = function(buf) {
    var amf0Packets, remainingLen, result;
    amf0Packets = [];
    remainingLen = buf.length;
    while (remainingLen > 0) {
      result = parseAMF0Data(buf);
      amf0Packets.push(result);
      remainingLen -= result.readLen;
      buf = buf.slice(result.readLen);
    }
    return {
      objects: amf0Packets
    };
  };

  parseAMF0CommandMessage = function(buf) {
    var amf0Packets, e, remainingLen, result;
    amf0Packets = [];
    remainingLen = buf.length;
    while (remainingLen > 0) {
      try {
        result = parseAMF0Data(buf);
      } catch (error) {
        e = error;
        logger.error("[rtmp] error parsing AMF0 command (maybe a bug); buf:");
        logger.error(buf);
        throw e;
      }
      amf0Packets.push(result);
      remainingLen -= result.readLen;
      buf = buf.slice(result.readLen);
    }
    return {
      command: amf0Packets[0].value,
      transactionID: amf0Packets[1].value,
      objects: amf0Packets.slice(2)
    };
  };

  parseAMF0Data = function(buf) {
    var date, i, result, strLen, time, type, value;
    i = 0;
    type = buf[i++];
    if (type === 0x00) {
      value = buf.readDoubleBE(i);
      return {
        type: 'number',
        value: value,
        readLen: i + 8
      };
    } else if (type === 0x01) {
      value = buf[i] === 0x00 ? false : true;
      return {
        type: 'boolean',
        value: value,
        readLen: i + 1
      };
    } else if (type === 0x02) {
      strLen = (buf[i++] << 8) + buf[i++];
      value = buf.toString('utf8', i, i + strLen);
      return {
        type: 'string',
        value: value,
        readLen: i + strLen
      };
    } else if (type === 0x03) {
      result = parseAMF0Object(buf.slice(i));
      return {
        type: 'object',
        value: result.value,
        readLen: i + result.readLen
      };
    } else if (type === 0x05) {
      return {
        type: 'null',
        value: null,
        readLen: i
      };
    } else if (type === 0x06) {
      return {
        type: 'undefined',
        value: void 0,
        readLen: i
      };
    } else if (type === 0x08) {
      result = parseAMF0ECMAArray(buf.slice(i));
      return {
        type: 'array',
        value: result.value,
        readLen: i + result.readLen
      };
    } else if (type === 0x09) {
      return {
        type: 'object-end-marker',
        readLen: i
      };
    } else if (type === 0x0a) {
      result = parseAMF0StrictArray(buf.slice(i));
      return {
        type: 'strict-array',
        value: result.value,
        readLen: i + result.readLen
      };
    } else if (type === 0x0b) {
      time = buf.readDoubleBE(i);
      date = new Date(time);
      return {
        type: 'date',
        value: date,
        readLen: i + 10
      };
    } else {
      throw new Error("Unknown AMF0 data type: " + type);
    }
  };

  createAMF0Data = function(data) {
    var buf, strBytes, strLen, type;
    type = typeof data;
    buf = null;
    if (type === 'number') {
      buf = new Buffer(9);
      buf[0] = 0x00;
      buf.writeDoubleBE(data, 1);
    } else if (type === 'boolean') {
      buf = new Buffer(2);
      buf[0] = 0x01;
      buf[1] = data ? 0x01 : 0x00;
    } else if (type === 'string') {
      buf = new Buffer(3);
      buf[0] = 0x02;
      strBytes = new Buffer(data, 'utf8');
      strLen = strBytes.length;
      buf[1] = (strLen >> 8) & 0xff;
      buf[2] = strLen & 0xff;
      buf = Buffer.concat([buf, strBytes], 3 + strLen);
    } else if (data === null) {
      buf = new Buffer([0x05]);
    } else if (type === 'undefined') {
      buf = new Buffer([0x06]);
    } else if (data instanceof Date) {
      buf = new Buffer(11);
      buf[0] = 0x0b;
      buf.writeDoubleBE(data.getTime(), 1);
      buf[9] = 0;
      buf[10] = 0;
    } else if (data instanceof Array) {
      buf = new Buffer([0x0a]);
      buf = createAMF0StrictArray(data, buf);
    } else if (type === 'object') {
      buf = createAMF0Object(data);
    } else {
      throw new Error("Unknown data type \"" + type + "\" for data " + data);
    }
    return buf;
  };

  createAMF0StrictArray = function(arr, buf) {
    var arrLen, bufs, i, j, len1, totalLength, value, valueBytes;
    if (buf == null) {
      buf = null;
    }
    bufs = [];
    totalLength = 0;
    if (buf != null) {
      bufs.push(buf);
      totalLength += buf.length;
    }
    arrLen = arr.length;
    bufs.push(new Buffer([(arrLen >>> 24) & 0xff, (arrLen >>> 16) & 0xff, (arrLen >>> 8) & 0xff, arrLen & 0xff]));
    totalLength += 4;
    for (i = j = 0, len1 = arr.length; j < len1; i = ++j) {
      value = arr[i];
      valueBytes = createAMF0Data(value);
      bufs.push(valueBytes);
      totalLength += valueBytes.length;
    }
    return Buffer.concat(bufs, totalLength);
  };

  createAMF0Object = function(obj) {
    var buf;
    buf = new Buffer([0x03]);
    return createAMF0PropertyList(obj, buf);
  };

  createAMF0ECMAArray = function(obj) {
    var buf, count;
    count = Object.keys(obj).length;
    buf = new Buffer([0x08, (count >>> 24) & 0xff, (count >>> 16) & 0xff, (count >>> 8) & 0xff, count & 0xff]);
    return createAMF0PropertyList(obj, buf);
  };

  createAMF0PropertyList = function(obj, buf) {
    var bufs, dataBytes, name, nameBytes, nameLen, nameLenBytes, totalLength, value;
    if (buf == null) {
      buf = null;
    }
    bufs = [];
    totalLength = 0;
    if (buf != null) {
      bufs.push(buf);
      totalLength += buf.length;
    }
    for (name in obj) {
      value = obj[name];
      nameBytes = new Buffer(name, 'utf8');
      nameLen = nameBytes.length;
      nameLenBytes = new Buffer(2);
      nameLenBytes[0] = (nameLen >> 8) & 0xff;
      nameLenBytes[1] = nameLen & 0xff;
      dataBytes = createAMF0Data(value);
      bufs.push(nameLenBytes, nameBytes, dataBytes);
      totalLength += 2 + nameLen + dataBytes.length;
    }
    bufs.push(new Buffer([0x00, 0x00, 0x09]));
    totalLength += 3;
    return Buffer.concat(bufs, totalLength);
  };

  counter = 0;

  flushRTMPMessages = function(stream, params) {
    var allSessions, buf, bufs, clientID, filteredMsgs, i, j, k, l, len1, len2, len3, len4, len5, len6, m, msgs, n, o, ref, rtmpMessage, rtmpMessagesToSend, session;
    if (stream == null) {
      logger.error("[rtmp] error: flushRTMPMessages: Invalid stream");
      return;
    }
    if (((params != null ? params.forceFlush : void 0) !== true) && (queuedRTMPMessages[stream.id].length < config.rtmpMessageQueueSize)) {
      return;
    }
    rtmpMessagesToSend = queuedRTMPMessages[stream.id];
    queuedRTMPMessages[stream.id] = [];
    for (i = j = 0, len1 = rtmpMessagesToSend.length; j < len1; i = ++j) {
      rtmpMessage = rtmpMessagesToSend[i];
      rtmpMessage.index = i;
    }
    rtmpMessagesToSend.sort(function(a, b) {
      var cmp;
      cmp = a.originalTimestamp - b.originalTimestamp;
      if (cmp === 0) {
        if ((a.avType == null) || (b.avType == null)) {
          cmp = 0;
        } else if (a.avType === b.avType) {
          cmp = 0;
        } else if (a.avType === 'audio') {
          cmp = -1;
        } else if (b.avType === 'audio') {
          cmp = 1;
        }
      }
      if (cmp === 0) {
        cmp = a.index - b.index;
      }
      return cmp;
    });
    if (rtmpMessagesToSend.length === 0) {
      return;
    }
    allSessions = [];
    for (clientID in rtmptSessions) {
      session = rtmptSessions[clientID];
      allSessions.push(session.rtmpSession);
    }
    for (clientID in sessions) {
      session = sessions[clientID];
      allSessions.push(session);
    }
    for (k = 0, len2 = allSessions.length; k < len2; k++) {
      session = allSessions[k];
      if (((ref = session.stream) != null ? ref.id : void 0) !== stream.id) {
        continue;
      }
      msgs = null;
      if (session.isWaitingForKeyFrame) {
        if (config.rtmpWaitForKeyFrame) {
          if (stream.isVideoStarted) {
            for (i = l = 0, len3 = rtmpMessagesToSend.length; l < len3; i = ++l) {
              rtmpMessage = rtmpMessagesToSend[i];
              if ((rtmpMessage.avType === 'video') && rtmpMessage.isKeyFrame) {
                logger.info("[rtmp:client=" + session.clientid + "] started playing stream " + stream.id);
                session.startPlaying();
                session.playStartTimestamp = rtmpMessage.originalTimestamp;
                session.playStartDateTime = Date.now();
                session.isWaitingForKeyFrame = false;
                msgs = rtmpMessagesToSend.slice(i);
                break;
              }
            }
          } else {
            logger.info("[rtmp:client=" + session.clientid + "] started playing stream " + stream.id);
            session.startPlaying();
            session.playStartTimestamp = rtmpMessagesToSend[0].originalTimestamp;
            session.playStartDateTime = Date.now();
            session.isWaitingForKeyFrame = false;
            msgs = rtmpMessagesToSend;
          }
        } else {
          logger.info("[rtmp:client=" + session.clientid + "] started playing stream " + stream.id);
          session.startPlaying();
          session.playStartTimestamp = rtmpMessagesToSend[0].originalTimestamp;
          session.playStartDateTime = Date.now();
          session.isWaitingForKeyFrame = false;
          msgs = rtmpMessagesToSend;
        }
      } else {
        msgs = rtmpMessagesToSend;
      }
      if (msgs == null) {
        continue;
      }
      if (session.isPlaying) {
        for (m = 0, len4 = msgs.length; m < len4; m++) {
          rtmpMessage = msgs[m];
          rtmpMessage.timestamp = session.getScaledTimestamp(rtmpMessage.originalTimestamp) % TIMESTAMP_ROUNDOFF;
        }
        if (session.isResuming) {
          filteredMsgs = [];
          for (i = n = 0, len5 = msgs.length; n < len5; i = ++n) {
            rtmpMessage = msgs[i];
            if (rtmpMessage.avType == null) {
              filteredMsgs.push(rtmpMessage);
            } else if (rtmpMessage.avType === 'video') {
              filteredMsgs.push.apply(filteredMsgs, msgs.slice(i));
              session.isResuming = false;
              break;
            } else if (rtmpMessage.timestamp > session.lastSentTimestamp) {
              filteredMsgs.push(rtmpMessage);
            } else {
              logger.debug("[rtmp:client=" + session.clientid + "] skipped message (timestamp=" + rtmpMessage.timestamp + " <= lastSentTimestamp=" + session.lastSentTimestamp + ")");
            }
          }
        } else {
          filteredMsgs = msgs;
        }
        if (((params != null ? params.hasControlMessage : void 0) !== true) && (filteredMsgs.length > 1)) {
          buf = createRTMPAggregateMessage(filteredMsgs, session.chunkSize);
          if (DEBUG_OUTGOING_RTMP_PACKETS) {
            logger.info(("send RTMP agg msg: " + buf.length + " bytes; time=") + filteredMsgs.map(function(item) {
              var ref1, ref2;
              return "" + ((ref1 = (ref2 = item.avType) != null ? ref2[0] : void 0) != null ? ref1 : 'other') + (item.avType === 'video' && item.isKeyFrame ? '(key)' : '') + ":" + item.timestamp + (item.avType === 'video' && item.compositionTime !== 0 ? "(cmp=" + (item.timestamp + item.compositionTime) + ")" : '');
            }).join(','));
          }
          session.sendData(buf);
        } else {
          bufs = [];
          for (o = 0, len6 = filteredMsgs.length; o < len6; o++) {
            rtmpMessage = filteredMsgs[o];
            bufs.push(createRTMPMessage(rtmpMessage, session.chunkSize));
          }
          buf = Buffer.concat(bufs);
          if (DEBUG_OUTGOING_RTMP_PACKETS) {
            logger.info(("send RTMP msg: " + buf.length + " bytes; time=") + filteredMsgs.map(function(item) {
              var ref1, ref2;
              return ((ref1 = (ref2 = item.avType) != null ? ref2[0] : void 0) != null ? ref1 : 'other') + ":" + item.timestamp;
            }).join(','));
          }
          session.sendData(buf);
        }
        session.lastSentTimestamp = filteredMsgs[filteredMsgs.length - 1].timestamp;
      }
    }
  };

  createMessageHeader = function(params) {
    var payloadLength;
    payloadLength = params.body.length;
    if (params.messageTypeID == null) {
      logger.warn("[rtmp] warning: createMessageHeader(): messageTypeID is not set");
    }
    if (params.timestamp == null) {
      logger.warn("[rtmp] warning: createMessageHeader(): timestamp is not set");
    }
    if (params.messageStreamID == null) {
      logger.warn("[rtmp] warning: createMessageHeader(): messageStreamID is not set");
    }
    return new Buffer([params.messageTypeID, (payloadLength >> 16) & 0xff, (payloadLength >> 8) & 0xff, payloadLength & 0xff, (params.timestamp >>> 16) & 0xff, (params.timestamp >>> 8) & 0xff, params.timestamp & 0xff, (params.timestamp >>> 24) & 0xff, (params.messageStreamID >> 16) & 0xff, (params.messageStreamID >> 8) & 0xff, params.messageStreamID & 0xff]);
  };

  createRTMPAggregateMessage = function(rtmpMessages, chunkSize) {
    var aggregateBody, aggregateTimestamp, bufs, header, j, len, len1, rtmpMessage, totalLength;
    bufs = [];
    totalLength = 0;
    aggregateTimestamp = null;
    for (j = 0, len1 = rtmpMessages.length; j < len1; j++) {
      rtmpMessage = rtmpMessages[j];
      if (aggregateTimestamp == null) {
        aggregateTimestamp = rtmpMessage.timestamp;
      }
      header = createMessageHeader(rtmpMessage);
      len = header.length + rtmpMessage.body.length;
      bufs.push(header, rtmpMessage.body, new Buffer([(len >>> 24) & 0xff, (len >>> 16) & 0xff, (len >>> 8) & 0xff, len & 0xff]));
      totalLength += len + 4;
    }
    aggregateBody = Buffer.concat(bufs, totalLength);
    return createRTMPMessage({
      chunkStreamID: 4,
      timestamp: aggregateTimestamp,
      messageTypeID: 22,
      messageStreamID: 1,
      body: aggregateBody
    }, chunkSize);
  };

  createRTMPType1Message = function(params) {
    var body, bodyLength, extendedTimestamp, formatTypeID, header, ordinaryTimestampBytes, useExtendedTimestamp;
    bodyLength = params.body.length;
    formatTypeID = 1;
    if (params.body == null) {
      logger.warn("[rtmp] warning: createRTMPType1Message(): body is not set for RTMP message");
    }
    if (params.chunkStreamID == null) {
      logger.warn("[rtmp] warning: createRTMPType1Message(): chunkStreamID is not set for RTMP message");
    }
    if (params.timestampDelta == null) {
      logger.warn("[rtmp] warning: createRTMPType1Message(): timestampDelta is not set for RTMP message");
    }
    if (params.messageStreamID == null) {
      logger.warn("[rtmp] warning: createRTMPType1Message(): messageStreamID is not set for RTMP message");
    }
    useExtendedTimestamp = false;
    if (params.timestampDelta >= 0xffffff) {
      useExtendedTimestamp = true;
      ordinaryTimestampBytes = [0xff, 0xff, 0xff];
    } else {
      ordinaryTimestampBytes = [(params.timestampDelta >> 16) & 0xff, (params.timestampDelta >> 8) & 0xff, params.timestampDelta & 0xff];
    }
    header = new Buffer([(formatTypeID << 6) | params.chunkStreamID, ordinaryTimestampBytes[0], ordinaryTimestampBytes[1], ordinaryTimestampBytes[2], (bodyLength >> 16) & 0xff, (bodyLength >> 8) & 0xff, bodyLength & 0xff, params.messageTypeID]);
    if (useExtendedTimestamp) {
      extendedTimestamp = new Buffer([(params.timestampDelta >> 24) & 0xff, (params.timestampDelta >> 16) & 0xff, (params.timestampDelta >> 8) & 0xff, params.timestampDelta & 0xff]);
      header = Buffer.concat([header, extendedTimestamp], 12);
    }
    body = params.body;
    return Buffer.concat([header, body], 8 + bodyLength);
  };

  createRTMPMessage = function(params, chunkSize) {
    var body, bodyChunk, bodyChunkLen, bodyLength, bufs, formatTypeID, timestamp, totalLength, type3Header, useExtendedTimestamp;
    if (chunkSize == null) {
      chunkSize = 128;
    }
    bodyLength = params.body.length;
    formatTypeID = 0;
    if (params.body == null) {
      logger.warn("[rtmp] warning: createRTMPMessage(): body is not set for RTMP message");
    }
    if (params.chunkStreamID == null) {
      logger.warn("[rtmp] warning: createRTMPMessage(): chunkStreamID is not set for RTMP message");
    }
    if (params.timestamp == null) {
      logger.warn("[rtmp] warning: createRTMPMessage(): timestamp is not set for RTMP message");
    }
    if (params.messageStreamID == null) {
      logger.warn("[rtmp] warning: createRTMPMessage(): messageStreamID is not set for RTMP message");
    }
    useExtendedTimestamp = false;
    if (params.timestamp >= 0xffffff) {
      useExtendedTimestamp = true;
      timestamp = [0xff, 0xff, 0xff];
    } else {
      timestamp = [(params.timestamp >> 16) & 0xff, (params.timestamp >> 8) & 0xff, params.timestamp & 0xff];
    }
    bufs = [new Buffer([(formatTypeID << 6) | params.chunkStreamID, timestamp[0], timestamp[1], timestamp[2], (bodyLength >> 16) & 0xff, (bodyLength >> 8) & 0xff, bodyLength & 0xff, params.messageTypeID, params.messageStreamID & 0xff, (params.messageStreamID >>> 8) & 0xff, (params.messageStreamID >>> 16) & 0xff, (params.messageStreamID >>> 24) & 0xff])];
    totalLength = 12;
    if (useExtendedTimestamp) {
      bufs.push(new Buffer([(params.timestamp >> 24) & 0xff, (params.timestamp >> 16) & 0xff, (params.timestamp >> 8) & 0xff, params.timestamp & 0xff]));
      totalLength += 4;
    }
    body = params.body;
    if (bodyLength > chunkSize) {
      bufs.push(body.slice(0, chunkSize));
      totalLength += chunkSize;
      body = body.slice(chunkSize);
      bodyLength -= chunkSize;
      type3Header = new Buffer([(3 << 6) | params.chunkStreamID]);
      while (true) {
        bodyChunk = body.slice(0, chunkSize);
        bodyChunkLen = bodyChunk.length;
        bufs.push(type3Header, bodyChunk);
        totalLength += 1 + bodyChunkLen;
        body = body.slice(bodyChunkLen);
        bodyLength -= bodyChunkLen;
        if (bodyLength === 0) {
          break;
        }
      }
    } else {
      bufs.push(body);
      totalLength += bodyLength;
    }
    return Buffer.concat(bufs, totalLength);
  };

  createAMF0DataMessage = function(params, chunkSize) {
    return createRTMPMessage(createAMF0DataMessageParams(params), chunkSize);
  };

  createAMF0DataMessageParams = function(params) {
    var amf0Bytes, j, len, len1, obj, ref;
    len = 0;
    ref = params.objects;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      obj = ref[j];
      len += obj.length;
    }
    amf0Bytes = Buffer.concat(params.objects, len);
    return {
      chunkStreamID: params.chunkStreamID,
      timestamp: params.timestamp,
      messageTypeID: 0x12,
      messageStreamID: params.messageStreamID,
      body: amf0Bytes
    };
  };

  createAMF0CommandMessage = function(params, chunkSize) {
    return createRTMPMessage(createAMF0CommandMessageParams(params), chunkSize);
  };

  createAMF0CommandMessageParams = function(params) {
    var amf0Bytes, commandBuf, j, len, len1, obj, ref, transactionIDBuf;
    commandBuf = createAMF0Data(params.command);
    transactionIDBuf = createAMF0Data(params.transactionID);
    len = commandBuf.length + transactionIDBuf.length;
    ref = params.objects;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      obj = ref[j];
      len += obj.length;
    }
    amf0Bytes = Buffer.concat([commandBuf, transactionIDBuf].concat(slice.call(params.objects)), len);
    return {
      chunkStreamID: params.chunkStreamID,
      timestamp: params.timestamp,
      messageTypeID: 0x14,
      messageStreamID: params.messageStreamID,
      body: amf0Bytes
    };
  };

  RTMPSession = (function() {
    function RTMPSession(socket) {
      logger.debug("[rtmp] created a new session");
      this.listeners = {};
      this.state = SESSION_STATE_NEW;
      this.socket = socket;
      this.chunkSize = 128;
      this.receiveChunkSize = 128;
      this.previousChunkMessage = {};
      this.isPlaying = false;
      this.clientid = generateNewClientID();
      this.useEncryption = false;
      this.receiveTimestamp = null;
      this.lastSentAckBytes = 0;
      this.receivedBytes = 0;
      this.stream = null;
      this.seekedDuringPause = false;
      this.lastSentTimestamp = null;
      this.isResuming = false;
      this.windowAckSize = 2500000;
    }

    RTMPSession.prototype.toString = function() {
      return this.clientid + ": addr=" + this.socket.remoteAddress + " port=" + this.socket.remotePort;
    };

    RTMPSession.prototype.startPlaying = function() {
      this.isPlaying = true;
      return this.isResuming = false;
    };

    RTMPSession.prototype.parseVideoMessage = function(buf) {
      var info, isEOS, nalUnitGlob, nalUnits, pps, sps;
      info = flv.parseVideo(buf);
      nalUnitGlob = null;
      isEOS = false;
      switch (info.videoDataTag.avcPacketType) {
        case flv.AVC_PACKET_TYPE_SEQUENCE_HEADER:
          this.avcInfo = info.avcDecoderConfigurationRecord;
          if (this.avcInfo.numOfSPS > 1) {
            logger.warn("warn: flv:parseVideo(): numOfSPS is " + numOfSPS + " > 1 (may not work)");
          }
          if (this.avcInfo.numOfPPS > 1) {
            logger.warn("warn: flv:parseVideo(): numOfPPS is " + numOfPPS + " > 1 (may not work)");
          }
          sps = h264.concatWithStartCodePrefix(this.avcInfo.sps);
          pps = h264.concatWithStartCodePrefix(this.avcInfo.pps);
          nalUnitGlob = Buffer.concat([sps, pps]);
          break;
        case flv.AVC_PACKET_TYPE_NALU:
          if (this.avcInfo == null) {
            throw new Error("[rtmp:publish] malformed video data: avcInfo is missing");
          }
          nalUnits = flv.splitNALUnits(info.nalUnits, this.avcInfo.nalUnitLengthSize);
          nalUnitGlob = h264.concatWithStartCodePrefix(nalUnits);
          break;
        case flv.AVC_PACKET_TYPE_EOS:
          isEOS = true;
          break;
        default:
          throw new Error("unknown AVCPacketType: " + flv.AVC_PACKET_TYPE_SEQUENCE_HEADER);
      }
      return {
        info: info,
        nalUnitGlob: nalUnitGlob,
        isEOS: isEOS
      };
    };

    RTMPSession.prototype.parseAudioMessage = function(buf) {
      var adtsFrame, adtsHeader, info, stream;
      info = flv.parseAudio(buf);
      adtsFrame = null;
      stream = this.stream;
      if (stream == null) {
        throw new Error("[rtmp] Stream not set for this session");
      }
      switch (info.audioDataTag.aacPacketType) {
        case flv.AAC_PACKET_TYPE_SEQUENCE_HEADER:
          if (info.audioSpecificConfig != null) {
            stream.updateConfig({
              audioSpecificConfig: info.audioSpecificConfig,
              audioASCInfo: info.ascInfo
            });
          } else {
            logger.warn("[rtmp] skipping empty AudioSpecificConfig");
          }
          break;
        case flv.AAC_PACKET_TYPE_RAW:
          if (stream.audioASCInfo == null) {
            logger.error("[rtmp:publish] malformed audio data: AudioSpecificConfig is missing");
          }
          adtsHeader = new Buffer(aac.createADTSHeader(stream.audioASCInfo, info.rawDataBlock.length));
          adtsFrame = Buffer.concat([adtsHeader, info.rawDataBlock]);
          break;
        default:
          throw new Error("[rtmp:publish] unknown AAC_PACKET_TYPE: " + info.audioDataTag.aacPacketType);
      }
      return {
        info: info,
        adtsFrame: adtsFrame
      };
    };

    RTMPSession.prototype.clearTimeout = function() {
      if (this.timeoutTimer != null) {
        clearTimeout(this.timeoutTimer);
        return this.timeoutTimer = null;
      }
    };

    RTMPSession.prototype.scheduleTimeout = function() {
      if (this.isTearedDown) {
        return;
      }
      this.clearTimeout();
      this.lastTimeoutScheduledTime = Date.now();
      return this.timeoutTimer = setTimeout((function(_this) {
        return function() {
          if (_this.isTearedDown) {
            return;
          }
          if (_this.timeoutTimer == null) {
            return;
          }
          if (Date.now() - _this.lastTimeoutScheduledTime < config.rtmpSessionTimeoutMs) {
            return;
          }
          logger.info("[rtmp:client=" + _this.clientid + "] session timeout");
          return _this.teardown();
        };
      })(this), config.rtmpSessionTimeoutMs);
    };

    RTMPSession.prototype.schedulePing = function() {
      this.lastPingScheduledTime = Date.now();
      if (this.pingTimer != null) {
        clearTimeout(this.pingTimer);
      }
      return this.pingTimer = setTimeout((function(_this) {
        return function() {
          if (Date.now() - _this.lastPingScheduledTime < config.rtmpPingTimeoutMs) {
            logger.debug("[rtmp] ping timeout canceled");
          }
          return _this.ping();
        };
      })(this), config.rtmpPingTimeoutMs);
    };

    RTMPSession.prototype.ping = function() {
      var currentTimestamp, pingRequest;
      currentTimestamp = this.getCurrentTimestamp();
      pingRequest = createRTMPMessage({
        chunkStreamID: 2,
        timestamp: currentTimestamp,
        messageTypeID: 0x04,
        messageStreamID: 0,
        body: new Buffer([0, 6, (currentTimestamp >> 24) & 0xff, (currentTimestamp >> 16) & 0xff, (currentTimestamp >> 8) & 0xff, currentTimestamp & 0xff])
      });
      return this.sendData(pingRequest);
    };

    RTMPSession.prototype.stopPlaying = function() {
      this.isPlaying = false;
      return this.isWaitingForKeyFrame = false;
    };

    RTMPSession.prototype.teardown = function() {
      var base, e, ref;
      if (this.isTearedDown) {
        logger.debug("[rtmp] already teared down");
        return;
      }
      this.isTearedDown = true;
      this.clearTimeout();
      this.stopPlaying();
      if (((ref = this.stream) != null ? ref.type : void 0) === avstreams.STREAM_TYPE_RECORDED) {
        if (typeof (base = this.stream).teardown === "function") {
          base.teardown();
        }
      }
      if (this.cipherIn != null) {
        this.cipherIn.final();
        this.cipherIn = null;
      }
      if (this.cipherOut != null) {
        this.cipherOut.final();
        this.cipherOut = null;
      }
      try {
        this.socket.end();
      } catch (error) {
        e = error;
        logger.error("[rtmp] socket.end error: " + e);
      }
      return this.emit('teardown');
    };

    RTMPSession.prototype.getCurrentTimestamp = function() {
      return Date.now() - this.playStartDateTime;
    };

    RTMPSession.prototype.getScaledTimestamp = function(timestamp) {
      var ts;
      ts = timestamp - this.playStartTimestamp;
      if (ts < 0) {
        ts = 0;
      }
      return ts;
    };

    RTMPSession.prototype.createVideoMessage = function(params) {
      params.chunkStreamID = 4;
      params.messageTypeID = 0x09;
      params.messageStreamID = 1;
      return this.createAVMessage(params);
    };

    RTMPSession.prototype.createAudioMessage = function(params) {
      params.chunkStreamID = 4;
      params.messageTypeID = 0x08;
      params.messageStreamID = 1;
      return this.createAVMessage(params);
    };

    RTMPSession.prototype.createAVMessage = function(params) {
      var msg, thisTimestamp;
      thisTimestamp = this.getScaledTimestamp(params.timestamp);
      if ((this.lastAVTimestamp != null) && params.body.length <= this.chunkSize) {
        params.timestampDelta = (thisTimestamp - this.lastAVTimestamp) % TIMESTAMP_ROUNDOFF;
        msg = createRTMPType1Message(params);
      } else {
        msg = createRTMPMessage(params, this.chunkSize);
      }
      this.lastAVTimestamp = thisTimestamp;
      return msg;
    };

    RTMPSession.prototype.concatenate = function(arr) {
      var i, item, j, len, len1;
      if (Buffer.isBuffer(arr)) {
        return arr;
      }
      if (!(arr instanceof Array)) {
        return;
      }
      len = 0;
      for (i = j = 0, len1 = arr.length; j < len1; i = ++j) {
        item = arr[i];
        if (item != null) {
          len += item.length;
        } else {
          arr[i] = new Buffer(0);
        }
      }
      return Buffer.concat(arr, len);
    };

    RTMPSession.prototype.emit = function() {
      var args, event, j, len1, listener, ref;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (this.listeners[event] == null) {
        return;
      }
      ref = this.listeners[event];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        listener = ref[j];
        listener.apply(null, args);
      }
    };

    RTMPSession.prototype.on = function(event, listener) {
      if (this.listeners[event] == null) {
        this.listeners[event] = [listener];
      } else {
        this.listeners[event].push(listener);
      }
    };

    RTMPSession.prototype.removeListener = function(event, listener) {
      var _listener, actualIndex, i, j, len1, listeners, ref, removedCount;
      listeners = this.listeners[event];
      if (listeners == null) {
        return;
      }
      removedCount = 0;
      for (i = j = 0, len1 = listeners.length; j < len1; i = ++j) {
        _listener = listeners[i];
        if (_listener === listener) {
          logger.debug("[rtmp] removed listener for " + event);
          actualIndex = i - removedCount;
          [].splice.apply(listeners, [actualIndex, actualIndex - actualIndex + 1].concat(ref = [])), ref;
          removedCount++;
        }
      }
    };

    RTMPSession.prototype.sendData = function(arr) {
      var buf, item, j, len, len1;
      if (arr == null) {
        return;
      }
      if (Buffer.isBuffer(arr)) {
        buf = arr;
      } else {
        len = 0;
        for (j = 0, len1 = arr.length; j < len1; j++) {
          item = arr[j];
          len += item.length;
        }
        buf = Buffer.concat(arr, len);
      }
      if (this.useEncryption) {
        buf = this.encrypt(buf);
      }
      return this.emit('data', buf);
    };

    RTMPSession.prototype.rejectConnect = function(commandMessage, callback) {
      var _error, close, streamBegin0;
      streamBegin0 = createRTMPMessage({
        chunkStreamID: 2,
        timestamp: 0,
        messageTypeID: 0x04,
        messageStreamID: 0,
        body: new Buffer([0, 0, 0, 0, 0, 0])
      });
      _error = createAMF0CommandMessage({
        chunkStreamID: 3,
        timestamp: 0,
        messageStreamID: 0,
        command: '_error',
        transactionID: 1,
        objects: [
          createAMF0Data(null), createAMF0Object({
            level: 'error',
            code: 'NetConnection.Connect.Rejected',
            description: "[ Server.Reject ] : (_defaultRoot_, ) : Invalid application name(/" + this.app + ")."
          })
        ]
      });
      close = createAMF0CommandMessage({
        chunkStreamID: 3,
        timestamp: 0,
        messageStreamID: 0,
        command: 'close',
        transactionID: 0,
        objects: [createAMF0Data(null)]
      });
      return callback(null, this.concatenate([streamBegin0, _error, close]));
    };

    RTMPSession.prototype.respondConnect = function(commandMessage, callback) {
      var app, connectResult, onBWDone, ref, setPeerBandwidth, streamBegin0, windowAck;
      app = commandMessage.objects[0].value.app;
      app = app.replace(/\/$/, '');
      this.app = app;
      if ((app !== config.liveApplicationName) && (app !== config.recordedApplicationName)) {
        logger.warn("[rtmp:client=" + this.clientid + "] requested invalid app name: " + app);
        this.rejectConnect(commandMessage, callback);
        return;
      }
      windowAck = createRTMPMessage({
        chunkStreamID: 2,
        timestamp: 0,
        messageTypeID: 0x05,
        messageStreamID: 0,
        body: new Buffer([0, 0x26, 0x25, 0xa0])
      });
      setPeerBandwidth = createRTMPMessage({
        chunkStreamID: 2,
        timestamp: 0,
        messageTypeID: 0x06,
        messageStreamID: 0,
        body: new Buffer([0, 0x26, 0x25, 0xa0, 0x02])
      });
      streamBegin0 = createRTMPMessage({
        chunkStreamID: 2,
        timestamp: 0,
        messageTypeID: 0x04,
        messageStreamID: 0,
        body: new Buffer([0, 0, 0, 0, 0, 0])
      });
      connectResult = createAMF0CommandMessage({
        chunkStreamID: 3,
        timestamp: 0,
        messageStreamID: 0,
        command: '_result',
        transactionID: 1,
        objects: [
          createAMF0Object({
            fmsVer: 'FMS/3,0,4,423',
            capabilities: 31
          }), createAMF0Object({
            level: 'status',
            code: 'NetConnection.Connect.Success',
            description: 'Connection succeeded.',
            objectEncoding: (ref = this.objectEncoding) != null ? ref : 0
          })
        ]
      });
      onBWDone = createAMF0CommandMessage({
        chunkStreamID: 3,
        timestamp: 0,
        messageStreamID: 0,
        command: 'onBWDone',
        transactionID: 0,
        objects: [createAMF0Data(null)]
      });
      return callback(null, this.concatenate([windowAck, setPeerBandwidth, streamBegin0, connectResult, onBWDone]));
    };

    RTMPSession.prototype.encrypt = function(data) {
      var isSingleByte, result;
      isSingleByte = typeof data === 'number';
      if (isSingleByte) {
        data = new Buffer([data]);
      }
      result = this.cipherIn.update(data);
      if (isSingleByte) {
        return result[0];
      } else {
        return result;
      }
    };

    RTMPSession.prototype.decrypt = function(data) {
      var isSingleByte, result;
      isSingleByte = typeof data === 'number';
      if (isSingleByte) {
        data = new Buffer([data]);
      }
      result = this.cipherOut.update(data);
      if (isSingleByte) {
        return result[0];
      } else {
        return result;
      }
    };

    RTMPSession.prototype.respondHandshake = function(c0c1, callback) {
      return rtmp_handshake.generateS0S1S2(c0c1, (function(_this) {
        return function(err, s0s1s2, keys) {
          var type, zeroBytes;
          type = s0s1s2[0];
          if (type === 6) {
            _this.useEncryption = true;
            logger.info("[rtmp:client=" + _this.clientid + "] enabled encryption");
            _this.clientPublicKey = keys.clientPublicKey;
            _this.dh = keys.dh;
            _this.sharedSecret = _this.dh.computeSecret(_this.clientPublicKey);
            _this.keyOut = codec_utils.calcHmac(_this.dh.getPublicKey(), _this.sharedSecret).slice(0, 16);
            _this.keyIn = codec_utils.calcHmac(_this.clientPublicKey, _this.sharedSecret).slice(0, 16);
            _this.cipherOut = crypto.createCipheriv('rc4', _this.keyOut, '');
            _this.cipherIn = crypto.createCipheriv('rc4', _this.keyIn, '');
            zeroBytes = new Buffer(1536);
            zeroBytes.fill(0);
            _this.encrypt(zeroBytes);
            _this.decrypt(zeroBytes);
          }
          return callback(null, s0s1s2);
        };
      })(this));
    };

    RTMPSession.prototype.parseRTMPMessages = function(rtmpMessage) {
      var chunkBasicHeader, chunkBody, chunkMessageHeader, chunkPayloadSize, consumedLen, headerLen, message, messages, previousChunk, remainingMessageLen;
      messages = [];
      consumedLen = 0;
      while (rtmpMessage.length > 1) {
        headerLen = 0;
        message = {};
        chunkBasicHeader = rtmpMessage[0];
        message.formatType = chunkBasicHeader >> 6;
        message.chunkStreamID = chunkBasicHeader & 0x3f;
        if (message.chunkStreamID === 0) {
          if (rtmpMessage.length < 2) {
            break;
          }
          message.chunkStreamID = rtmpMessage[1] + 64;
          chunkMessageHeader = rtmpMessage.slice(2);
          headerLen += 2;
        } else if (message.chunkStreamID === 1) {
          if (rtmpMessage.length < 3) {
            break;
          }
          message.chunkStreamID = (rtmpMessage[1] << 8) + rtmpMessage[2] + 64;
          chunkMessageHeader = rtmpMessage.slice(3);
          headerLen += 3;
        } else {
          chunkMessageHeader = rtmpMessage.slice(1);
          headerLen += 1;
        }
        if (message.formatType === 0) {
          if (chunkMessageHeader.length < 11) {
            break;
          }
          message.timestamp = (chunkMessageHeader[0] << 16) + (chunkMessageHeader[1] << 8) + chunkMessageHeader[2];
          message.timestampDelta = 0;
          message.messageLength = (chunkMessageHeader[3] << 16) + (chunkMessageHeader[4] << 8) + chunkMessageHeader[5];
          message.messageTypeID = chunkMessageHeader[6];
          message.messageStreamID = chunkMessageHeader.readInt32LE(7);
          chunkBody = chunkMessageHeader.slice(11);
          headerLen += 11;
        } else if (message.formatType === 1) {
          if (chunkMessageHeader.length < 7) {
            break;
          }
          message.timestampDelta = (chunkMessageHeader[0] << 16) + (chunkMessageHeader[1] << 8) + chunkMessageHeader[2];
          message.messageLength = (chunkMessageHeader[3] << 16) + (chunkMessageHeader[4] << 8) + chunkMessageHeader[5];
          message.messageTypeID = chunkMessageHeader[6];
          previousChunk = this.previousChunkMessage[message.chunkStreamID];
          if (previousChunk != null) {
            message.timestamp = previousChunk.timestamp;
            message.messageStreamID = previousChunk.messageStreamID;
          } else {
            throw new Error(this.clientid + ": Chunk reference error for type 1: previous chunk for id " + message.chunkStreamID + " is not found (possibly a bug)");
          }
          chunkBody = chunkMessageHeader.slice(7);
          headerLen += 7;
        } else if (message.formatType === 2) {
          if (chunkMessageHeader.length < 3) {
            break;
          }
          message.timestampDelta = (chunkMessageHeader[0] << 16) + (chunkMessageHeader[1] << 8) + chunkMessageHeader[2];
          previousChunk = this.previousChunkMessage[message.chunkStreamID];
          if (previousChunk != null) {
            message.timestamp = previousChunk.timestamp;
            message.messageStreamID = previousChunk.messageStreamID;
            message.messageLength = previousChunk.messageLength;
            message.messageTypeID = previousChunk.messageTypeID;
          } else {
            throw new Error(this.clientid + ": Chunk reference error for type 2: previous chunk for id " + message.chunkStreamID + " is not found (possibly a bug)");
          }
          chunkBody = chunkMessageHeader.slice(3);
          headerLen += 3;
        } else if (message.formatType === 3) {
          previousChunk = this.previousChunkMessage[message.chunkStreamID];
          if (previousChunk != null) {
            message.timestamp = previousChunk.timestamp;
            message.messageStreamID = previousChunk.messageStreamID;
            message.messageLength = previousChunk.messageLength;
            message.timestampDelta = previousChunk.timestampDelta;
            message.messageTypeID = previousChunk.messageTypeID;
          } else {
            throw new Error(this.clientid + ": Chunk reference error for type 3: previous chunk for id " + message.chunkStreamID + " is not found (possibly a bug)");
          }
          chunkBody = chunkMessageHeader;
        } else {
          throw new Error("Unknown format type: " + formatType);
        }
        if (message.formatType === 0) {
          if (message.timestamp === 0xffffff) {
            if (chunkBody.length < 4) {
              break;
            }
            message.timestamp = (chunkBody[0] * Math.pow(256, 3)) + (chunkBody[1] << 16) + (chunkBody[2] << 8) + chunkBody[3];
            chunkBody = chunkBody.slice(4);
            headerLen += 4;
          }
        } else if (message.timestampDelta === 0xffffff) {
          if (chunkBody.length < 4) {
            break;
          }
          message.timestampDelta = (chunkBody[0] * Math.pow(256, 3)) + (chunkBody[1] << 16) + (chunkBody[2] << 8) + chunkBody[3];
          chunkBody = chunkBody.slice(4);
          headerLen += 4;
        }
        previousChunk = this.previousChunkMessage[message.chunkStreamID];
        if ((previousChunk != null) && previousChunk.isIncomplete) {
          remainingMessageLen = message.messageLength - previousChunk.body.length;
        } else {
          remainingMessageLen = message.messageLength;
        }
        chunkPayloadSize = Math.min(this.receiveChunkSize, remainingMessageLen);
        if (chunkBody.length < chunkPayloadSize) {
          break;
        }
        rtmpMessage = chunkBody.slice(chunkPayloadSize);
        chunkBody = chunkBody.slice(0, chunkPayloadSize);
        consumedLen += headerLen + chunkPayloadSize;
        if ((previousChunk != null) && previousChunk.isIncomplete) {
          message.body = Buffer.concat([previousChunk.body, chunkBody]);
        } else {
          message.body = chunkBody;
          if (message.timestampDelta != null) {
            if (message.timestamp == null) {
              throw new Error("timestamp delta is given, but base timestamp is not known");
            }
            message.timestamp += message.timestampDelta;
          }
        }
        if (message.body.length >= message.messageLength) {
          if (message.body.length !== message.messageLength) {
            logger.warn("[rtmp] warning: message lengths don't match: " + ("got=" + message.body.length + " expected=" + message.messageLength));
          }
          messages.push(message);
        } else {
          message.isIncomplete = true;
        }
        this.previousChunkMessage[message.chunkStreamID] = message;
        if (messages.length === 1) {
          break;
        }
      }
      return {
        consumedLen: consumedLen,
        rtmpMessages: messages
      };
    };

    RTMPSession.prototype.respondReleaseStream = function(requestCommand, callback) {
      var _result, ref, streamName;
      streamName = (ref = requestCommand.objects[1]) != null ? ref.value : void 0;
      logger.debug("[rtmp] releaseStream: " + this.app + "/" + streamName);
      _result = createAMF0CommandMessage({
        chunkStreamID: 3,
        timestamp: 0,
        messageStreamID: 0,
        command: '_result',
        transactionID: requestCommand.transactionID,
        objects: [createAMF0Data(null), createAMF0Data(null)]
      });
      return callback(null, _result);
    };

    RTMPSession.prototype.receiveSetDataFrame = function(requestData) {
      if (requestData.objects[1].value === 'onMetaData') {
        return logger.debug("[rtmp:receive] received @setDataFrame onMetaData");
      } else {
        throw new Error("Unknown @setDataFrame: " + requestData.objects[1].value);
      }
    };

    RTMPSession.prototype.respondFCUnpublish = function(requestCommand, callback) {
      var _result, ref, streamName, unpublishSuccess;
      streamName = (ref = requestCommand.objects[1]) != null ? ref.value : void 0;
      logger.info("[rtmp] FCUnpublish: " + streamName);
      _result = createAMF0CommandMessage({
        chunkStreamID: 3,
        timestamp: 0,
        messageStreamID: 0,
        command: '_result',
        transactionID: requestCommand.transactionID,
        objects: [createAMF0Data(null), createAMF0Data(null)]
      });
      unpublishSuccess = createAMF0CommandMessage({
        chunkStreamID: 4,
        timestamp: 0,
        messageStreamID: 1,
        command: 'onStatus',
        transactionID: requestCommand.transactionID,
        objects: [
          createAMF0Data(null), createAMF0Object({
            level: 'status',
            code: 'NetStream.Unpublish.Success',
            description: '',
            details: streamName,
            clientid: this.clientid
          })
        ]
      }, this.chunkSize);
      return callback(null, this.concatenate([_result, unpublishSuccess]));
    };

    RTMPSession.prototype.respondPublish = function(requestCommand, callback) {
      var j, kv, len1, match, pair, pairs, params, publishStart, publishingName, publishingType, ref, ref1, stream, streamName, urlInfo;
      this.receiveTimestamp = null;
      publishingName = (ref = requestCommand.objects[1]) != null ? ref.value : void 0;
      if (typeof publishingName !== 'string') {
        publishStart = createAMF0CommandMessage({
          chunkStreamID: 4,
          timestamp: 0,
          messageStreamID: 1,
          command: 'onStatus',
          transactionID: requestCommand.transactionID,
          objects: [
            createAMF0Data(null), createAMF0Object({
              level: 'error',
              code: 'NetStream.Publish.Start',
              description: 'Publishing Name parameter is invalid.',
              details: this.app,
              clientid: this.clientid
            })
          ]
        }, this.chunkSize);
        return callback(null, publishStart);
      }
      urlInfo = url.parse(publishingName);
      if (urlInfo.query != null) {
        pairs = urlInfo.query.split('&');
        params = {};
        for (j = 0, len1 = pairs.length; j < len1; j++) {
          pair = pairs[j];
          kv = pair.split('=');
          params[kv[0]] = kv[1];
        }
        logger.info(JSON.stringify(params));
      }
      publishingName = this.app + '/' + urlInfo.pathname;
      this.streamId = publishingName;
      stream = avstreams.get(this.streamId);
      if (stream != null) {
        stream.reset();
      } else {
        stream = avstreams.create(this.streamId);
        stream.type = avstreams.STREAM_TYPE_LIVE;
      }
      this.stream = stream;
      publishingType = (ref1 = requestCommand.objects[2]) != null ? ref1.value : void 0;
      if (publishingType.toLowerCase() !== 'live') {
        logger.warn("[rtmp] warn: publishing type other than 'live' is not supported (got " + publishingType + "); assuming 'live'");
      }
      logger.info("[rtmp] publish: stream=" + publishingName + " publishingType=" + publishingType);
      if ((match = /^(.*?)\?/.exec(publishingName)) != null) {
        streamName = match[1];
      } else {
        streamName = publishingName;
      }
      this.isFirstVideoReceived = false;
      this.isFirstAudioReceived = false;
      publishStart = createAMF0CommandMessage({
        chunkStreamID: 4,
        timestamp: 0,
        messageStreamID: 1,
        command: 'onStatus',
        transactionID: requestCommand.transactionID,
        objects: [
          createAMF0Data(null), createAMF0Object({
            level: 'status',
            code: 'NetStream.Publish.Start',
            description: '',
            details: streamName,
            clientid: this.clientid
          })
        ]
      }, this.chunkSize);
      return callback(null, publishStart);
    };

    RTMPSession.prototype.respondWithError = function(requestCommand, callback) {
      var _error;
      _error = createAMF0CommandMessage({
        chunkStreamID: 3,
        timestamp: 0,
        messageStreamID: 0,
        command: '_error',
        transactionID: requestCommand.transactionID,
        objects: [
          createAMF0Data(null), createAMF0Object({
            level: 'error',
            code: '',
            description: 'Request failed.',
            details: this.app,
            clientid: this.clientid
          })
        ]
      });
      return callback(null, _error);
    };

    RTMPSession.prototype.respondFCPublish = function(requestCommand, callback) {
      var _result, ref, streamName;
      streamName = (ref = requestCommand.objects[1]) != null ? ref.value : void 0;
      logger.debug("[rtmp] FCPublish: " + this.app + "/" + streamName);
      _result = createAMF0CommandMessage({
        chunkStreamID: 3,
        timestamp: 0,
        messageStreamID: 0,
        command: '_result',
        transactionID: requestCommand.transactionID,
        objects: [createAMF0Data(null), createAMF0Data(null)]
      });
      return callback(null, _result);
    };

    RTMPSession.prototype.respondCreateStream = function(requestCommand, callback) {
      var _result;
      _result = createAMF0CommandMessage({
        chunkStreamID: 3,
        timestamp: 0,
        messageStreamID: 0,
        command: '_result',
        transactionID: requestCommand.transactionID,
        objects: [createAMF0Data(null), createAMF0Data(1)]
      });
      return callback(null, _result);
    };

    RTMPSession.prototype.respondPlay = function(commandMessage, callback, streamId) {
      var _error, close, codecConfigs, dataStart, messages, metadata, onMetaData, playReset, playStart, ref, rtmpSampleAccess, setChunkSize, stream, streamBegin1, streamIsRecorded;
      if (streamId == null) {
        streamId = null;
      }
      if (streamId == null) {
        streamId = this.app + '/' + ((ref = commandMessage.objects[1]) != null ? ref.value : void 0);
      }
      logger.info("[rtmp:client=" + this.clientid + "] requested stream " + streamId);
      this.chunkSize = config.rtmpPlayChunkSize;
      this.stream = avstreams.get(streamId);
      if (this.stream == null) {
        logger.error("[rtmp:client=" + this.clientid + "] error: stream not found: " + streamId);
        _error = createAMF0CommandMessage({
          chunkStreamID: 3,
          timestamp: 0,
          messageStreamID: 0,
          command: '_error',
          transactionID: commandMessage.transactionID,
          objects: [
            createAMF0Data(null), createAMF0Object({
              level: 'error',
              code: 'NetStream.Play.StreamNotFound',
              description: '',
              details: streamId,
              clientid: this.clientid
            })
          ]
        });
        close = createAMF0CommandMessage({
          chunkStreamID: 3,
          timestamp: 0,
          messageStreamID: 0,
          command: 'close',
          transactionID: 0,
          objects: [createAMF0Data(null)]
        });
        callback(null, this.concatenate([_error, close]));
        return;
      }
      setChunkSize = createRTMPMessage({
        chunkStreamID: 2,
        timestamp: 0,
        messageTypeID: 0x01,
        messageStreamID: 0,
        body: new Buffer([(this.chunkSize >>> 24) & 0x7f, (this.chunkSize >>> 16) & 0xff, (this.chunkSize >>> 8) & 0xff, this.chunkSize & 0xff])
      });
      logger.debug("[rtmp:client=" + this.clientid + "] stream type: " + this.stream.type);
      if (this.stream.isRecorded()) {
        streamIsRecorded = createRTMPMessage({
          chunkStreamID: 2,
          timestamp: 0,
          messageTypeID: 0x04,
          messageStreamID: 0,
          body: new Buffer([0, 4, 0, 0, 0, 1])
        }, this.chunkSize);
      }
      streamBegin1 = createRTMPMessage({
        chunkStreamID: 2,
        timestamp: 0,
        messageTypeID: 0x04,
        messageStreamID: 0,
        body: new Buffer([0, 0, 0, 0, 0, 1])
      }, this.chunkSize);
      playReset = createAMF0CommandMessage({
        chunkStreamID: 4,
        timestamp: 0,
        messageStreamID: 1,
        command: 'onStatus',
        transactionID: 0,
        objects: [
          createAMF0Data(null), createAMF0Object({
            level: 'status',
            code: 'NetStream.Play.Reset',
            description: "Playing and resetting " + streamId + ".",
            details: streamId,
            clientid: this.clientid
          })
        ]
      }, this.chunkSize);
      playStart = createAMF0CommandMessage({
        chunkStreamID: 4,
        timestamp: 0,
        messageStreamID: 1,
        command: 'onStatus',
        transactionID: 0,
        objects: [
          createAMF0Data(null), createAMF0Object({
            level: 'status',
            code: 'NetStream.Play.Start',
            description: "Started playing " + streamId + ".",
            details: streamId,
            clientid: this.clientid
          })
        ]
      }, this.chunkSize);
      rtmpSampleAccess = createAMF0DataMessage({
        chunkStreamID: 4,
        timestamp: 0,
        messageStreamID: 1,
        objects: [createAMF0Data('|RtmpSampleAccess'), createAMF0Data(false), createAMF0Data(false)]
      }, this.chunkSize);
      dataStart = createAMF0DataMessage({
        chunkStreamID: 4,
        timestamp: 0,
        messageStreamID: 1,
        objects: [
          createAMF0Data('onStatus'), createAMF0Object({
            code: 'NetStream.Data.Start'
          })
        ]
      }, this.chunkSize);
      metadata = {
        canSeekToEnd: false,
        cuePoints: [],
        hasMetadata: true,
        hasCuePoints: false
      };
      if (this.stream != null) {
        stream = this.stream;
        if (stream != null) {
          if (stream.isVideoStarted) {
            metadata.hasVideo = true;
            metadata.framerate = stream.videoFrameRate;
            metadata.height = stream.videoHeight;
            metadata.videocodecid = config.flv.videocodecid;
            metadata.videodatarate = config.videoBitrateKbps;
            metadata.width = stream.videoWidth;
            metadata.avclevel = stream.videoAVCLevel;
            metadata.avcprofile = stream.videoAVCProfile;
          }
          if (stream.isAudioStarted) {
            metadata.hasAudio = true;
            metadata.audiocodecid = config.flv.audiocodecid;
            metadata.audiodatarate = config.audioBitrateKbps;
            metadata.audiodelay = 0;
            metadata.audiosamplerate = stream.audioSampleRate;
            metadata.stereo = stream.audioChannels > 1;
            metadata.audiochannels = stream.audioChannels;
            metadata.aacaot = stream.audioObjectType;
          }
          if (stream.isRecorded()) {
            metadata.duration = stream.durationSeconds;
            metadata.lasttimestamp = stream.lastTagTimestamp;
          }
        } else {
          logger.error("[rtmp] error: respondPlay: no such stream: " + stream.id);
        }
      } else {
        logger.error("[rtmp] error: respondPlay: stream not set for this session");
      }
      logger.debug("[rtmp] metadata:");
      logger.debug(metadata);
      onMetaData = createAMF0DataMessage({
        chunkStreamID: 4,
        timestamp: 0,
        messageStreamID: 1,
        objects: [createAMF0Data('onMetaData'), createAMF0Data(metadata)]
      }, this.chunkSize);
      codecConfigs = this.getCodecConfigs(0);
      messages = [setChunkSize];
      if (this.stream.isRecorded()) {
        messages.push(streamIsRecorded);
      }
      messages.push(streamBegin1, playReset, playStart, rtmpSampleAccess, dataStart, onMetaData, codecConfigs);
      callback(null, this.concatenate(messages));
      if (this.stream.isRecorded()) {
        this.stream.play();
      }
      this.isWaitingForKeyFrame = true;
      this.seekedDuringPause = false;
      if (config.rtmpWaitForKeyFrame) {
        return logger.info("[rtmp:client=" + this.clientid + "] waiting for keyframe");
      }
    };

    RTMPSession.prototype.getCodecConfigs = function(timestamp) {
      var ascInfo, audioConfigMessage, buf, configMessages, ppsLen, spsLen, stream, videoConfigMessage;
      if (timestamp == null) {
        timestamp = 0;
      }
      configMessages = [];
      stream = this.stream;
      if (stream == null) {
        logger.error("[rtmp] error: getCodecConfigs: stream not set for this session");
        return new Buffer([]);
      }
      if (stream.isVideoStarted) {
        if ((stream.spsNALUnit == null) || (stream.ppsNALUnit == null)) {
          logger.error("[rtmp] error: getCodecConfigs: SPS or PPS is not present");
          return new Buffer([]);
        }
        spsLen = stream.spsNALUnit.length;
        ppsLen = stream.ppsNALUnit.length;
        buf = new Buffer([(1 << 4) | config.flv.videocodecid, 0x00, 0x00, 0x00, 0x00, 0x01].concat(slice.call(stream.spsNALUnit.slice(1, 4)), [0xff], [0xe1], [(spsLen >> 8) & 0xff], [spsLen & 0xff], slice.call(stream.spsNALUnit), [0x01], [(ppsLen >> 8) & 0xff], [ppsLen & 0xff], slice.call(stream.ppsNALUnit)));
        videoConfigMessage = createVideoMessage({
          body: buf,
          timestamp: timestamp,
          chunkSize: this.chunkSize
        });
        configMessages.push(videoConfigMessage);
      }
      if (stream.isAudioStarted) {
        buf = flv.createAACAudioDataTag({
          aacPacketType: flv.AAC_PACKET_TYPE_SEQUENCE_HEADER
        });
        ascInfo = stream.audioASCInfo;
        if (ascInfo != null) {
          if (ascInfo.explicitHierarchicalSBR && config.rtmpDisableHierarchicalSBR) {
            logger.debug("[rtmp] converting hierarchical signaling of SBR" + (" (AudioSpecificConfig=0x" + (stream.audioSpecificConfig.toString('hex')) + ")") + " to backward compatible signaling");
            buf = buf.concat(aac.createAudioSpecificConfig(ascInfo));
            buf = new Buffer(buf);
          } else {
            buf = Buffer.concat([new Buffer(buf), stream.audioSpecificConfig]);
          }
          logger.debug("[rtmp] sending AudioSpecificConfig: 0x" + (buf.toString('hex')));
        } else {
          buf = buf.concat(aac.createAudioSpecificConfig({
            audioObjectType: stream.audioObjectType,
            samplingFrequency: stream.audioSampleRate,
            channels: stream.audioChannels,
            frameLength: 1024
          }));
          buf = new Buffer(buf);
        }
        audioConfigMessage = createAudioMessage({
          body: buf,
          timestamp: timestamp,
          chunkSize: this.chunkSize
        });
        configMessages.push(audioConfigMessage);
      }
      return this.concatenate(configMessages);
    };

    RTMPSession.prototype.respondSeek = function(requestCommand, callback) {
      var _isPaused, _isPlaying, msec, ref;
      msec = requestCommand.objects[1].value;
      logger.info("[rtmp:client=" + this.clientid + "] seek to " + (msec / 1000) + " sec");
      msec = Math.floor(msec);
      this.lastSentTimestamp = null;
      if (((ref = this.stream) != null ? ref.type : void 0) === avstreams.STREAM_TYPE_RECORDED) {
        clearQueuedRTMPMessages(this.stream);
        _isPlaying = this.isPlaying;
        this.isPlaying = false;
        _isPaused = this.stream.isPaused();
        if (!_isPaused) {
          this.stream.pause();
        }
        return this.stream.seek(msec / 1000, (function(_this) {
          return function(err, actualStartTime) {
            var seq;
            if (err) {
              logger.error("seek failed: " + err);
              return;
            }
            _this.isPlaying = _isPlaying;
            seq = new Sequent;
            if (!_isPaused) {
              _this.stream.sendVideoPacketsSinceLastKeyFrame(msec / 1000, function() {
                _this.stream.resume();
                _this.seekedDuringPause = false;
                return seq.done();
              });
            } else {
              _this.seekedDuringPause = true;
              seq.done();
            }
            return seq.wait(1, function() {
              var codecConfigs, dataStart, metadata, onMetaData, playStart, rtmpSampleAccess, seekNotify, setChunkSize, stream, streamBegin1, streamEOF1, streamIsRecorded;
              streamEOF1 = createRTMPMessage({
                chunkStreamID: 2,
                timestamp: 0,
                messageTypeID: 0x04,
                messageStreamID: 0,
                body: new Buffer([0, 1, 0, 0, 0, 1])
              });
              setChunkSize = createRTMPMessage({
                chunkStreamID: 2,
                timestamp: 0,
                messageTypeID: 0x01,
                messageStreamID: 0,
                body: new Buffer([(_this.chunkSize >>> 24) & 0x7f, (_this.chunkSize >>> 16) & 0xff, (_this.chunkSize >>> 8) & 0xff, _this.chunkSize & 0xff])
              });
              streamIsRecorded = createRTMPMessage({
                chunkStreamID: 2,
                timestamp: 0,
                messageTypeID: 0x04,
                messageStreamID: 0,
                body: new Buffer([0, 4, 0, 0, 0, 1])
              }, _this.chunkSize);
              streamBegin1 = createRTMPMessage({
                chunkStreamID: 2,
                timestamp: 0,
                messageTypeID: 0x04,
                messageStreamID: 0,
                body: new Buffer([0, 0, 0, 0, 0, 1])
              }, _this.chunkSize);
              seekNotify = createAMF0CommandMessage({
                chunkStreamID: 4,
                timestamp: msec,
                messageStreamID: 1,
                command: 'onStatus',
                transactionID: requestCommand.transactionID,
                objects: [
                  createAMF0Data(null), createAMF0Object({
                    level: 'status',
                    code: 'NetStream.Seek.Notify',
                    description: "Seeking " + msec + " (stream ID: 1).",
                    details: _this.stream.id,
                    clientid: _this.clientid
                  })
                ]
              }, _this.chunkSize);
              playStart = createAMF0CommandMessage({
                chunkStreamID: 4,
                timestamp: msec,
                messageStreamID: 1,
                command: 'onStatus',
                transactionID: 0,
                objects: [
                  createAMF0Data(null), createAMF0Object({
                    level: 'status',
                    code: 'NetStream.Play.Start',
                    description: "Started playing " + _this.stream.id + ".",
                    details: _this.stream.id,
                    clientid: _this.clientid
                  })
                ]
              }, _this.chunkSize);
              rtmpSampleAccess = createAMF0DataMessage({
                chunkStreamID: 4,
                timestamp: msec,
                messageStreamID: 1,
                objects: [createAMF0Data('|RtmpSampleAccess'), createAMF0Data(false), createAMF0Data(false)]
              }, _this.chunkSize);
              dataStart = createAMF0DataMessage({
                chunkStreamID: 4,
                timestamp: msec,
                messageStreamID: 1,
                objects: [
                  createAMF0Data('onStatus'), createAMF0Object({
                    code: 'NetStream.Data.Start'
                  })
                ]
              }, _this.chunkSize);
              metadata = {
                canSeekToEnd: false,
                cuePoints: [],
                hasMetadata: true,
                hasCuePoints: false
              };
              stream = _this.stream;
              if (stream.isVideoStarted) {
                metadata.hasVideo = true;
                metadata.framerate = stream.videoFrameRate;
                metadata.height = stream.videoHeight;
                metadata.videocodecid = config.flv.videocodecid;
                metadata.videodatarate = config.videoBitrateKbps;
                metadata.width = stream.videoWidth;
                metadata.avclevel = stream.videoAVCLevel;
                metadata.avcprofile = stream.videoAVCProfile;
              }
              if (stream.isAudioStarted) {
                metadata.hasAudio = true;
                metadata.audiocodecid = config.flv.audiocodecid;
                metadata.audiodatarate = config.audioBitrateKbps;
                metadata.audiodelay = 0;
                metadata.audiosamplerate = stream.audioSampleRate;
                metadata.stereo = stream.audioChannels > 1;
                metadata.audiochannels = stream.audioChannels;
                metadata.aacaot = stream.audioObjectType;
              }
              metadata.duration = stream.durationSeconds;
              metadata.lasttimestamp = stream.lastTagTimestamp;
              logger.debug("[rtmp] metadata:");
              logger.debug(metadata);
              onMetaData = createAMF0DataMessage({
                chunkStreamID: 4,
                timestamp: msec,
                messageStreamID: 1,
                objects: [createAMF0Data('onMetaData'), createAMF0Data(metadata)]
              }, _this.chunkSize);
              codecConfigs = _this.getCodecConfigs(msec);
              return callback(null, _this.concatenate([streamEOF1, setChunkSize, streamIsRecorded, streamBegin1, seekNotify, playStart, rtmpSampleAccess, dataStart, onMetaData, codecConfigs]));
            });
          };
        })(this));
      } else {
        return this.respondPlay(requestCommand, callback);
      }
    };

    RTMPSession.prototype.respondPause = function(requestCommand, callback) {
      var base, doPause, msec, pauseNotify, ref, ref1, ref2, seekMsec, streamEOF1;
      doPause = requestCommand.objects[1].value === true;
      msec = requestCommand.objects[2].value;
      if (doPause) {
        this.isPlaying = false;
        this.isWaitingForKeyFrame = false;
        if (((ref = this.stream) != null ? ref.type : void 0) === avstreams.STREAM_TYPE_RECORDED) {
          if (typeof (base = this.stream).pause === "function") {
            base.pause();
          }
          logger.info("[rtmp:client=" + this.clientid + "] stream " + this.stream.id + " paused at " + (msec / 1000) + " sec (client player time)");
          streamEOF1 = createRTMPMessage({
            chunkStreamID: 2,
            timestamp: 0,
            messageTypeID: 0x04,
            messageStreamID: 0,
            body: new Buffer([0, 1, 0, 0, 0, 1])
          });
          pauseNotify = createAMF0CommandMessage({
            chunkStreamID: 4,
            timestamp: msec,
            messageStreamID: 1,
            command: 'onStatus',
            transactionID: requestCommand.transactionID,
            objects: [
              createAMF0Data(null), createAMF0Object({
                level: 'status',
                code: 'NetStream.Pause.Notify',
                description: "Pausing " + this.stream.id + ".",
                details: this.stream.id,
                clientid: this.clientid
              })
            ]
          }, this.chunkSize);
          return callback(null, this.concatenate([streamEOF1, pauseNotify]));
        } else {
          return callback(null);
        }
      } else {
        if (((ref1 = this.stream) != null ? ref1.type : void 0) === avstreams.STREAM_TYPE_RECORDED) {
          clearQueuedRTMPMessages(this.stream);
          if (msec === 0) {
            seekMsec = 0;
          } else {
            seekMsec = msec + 1;
          }
          return this.stream.seek(seekMsec / 1000, (function(_this) {
            return function(err, actualStartTime) {
              var codecConfigs, dataStart, metadata, onMetaData, playStart, rtmpSampleAccess, seq, setChunkSize, stream, streamBegin1, streamIsRecorded, unpauseNotify;
              if (err) {
                logger.error("[rtmp] seek failed: " + err);
                return;
              }
              setChunkSize = createRTMPMessage({
                chunkStreamID: 2,
                timestamp: 0,
                messageTypeID: 0x01,
                messageStreamID: 0,
                body: new Buffer([(_this.chunkSize >>> 24) & 0x7f, (_this.chunkSize >>> 16) & 0xff, (_this.chunkSize >>> 8) & 0xff, _this.chunkSize & 0xff])
              });
              if (_this.stream.isRecorded()) {
                streamIsRecorded = createRTMPMessage({
                  chunkStreamID: 2,
                  timestamp: 0,
                  messageTypeID: 0x04,
                  messageStreamID: 0,
                  body: new Buffer([0, 4, 0, 0, 0, 1])
                }, _this.chunkSize);
              }
              streamBegin1 = createRTMPMessage({
                chunkStreamID: 2,
                timestamp: 0,
                messageTypeID: 0x04,
                messageStreamID: 0,
                body: new Buffer([0, 0, 0, 0, 0, 1])
              }, _this.chunkSize);
              unpauseNotify = createAMF0CommandMessage({
                chunkStreamID: 4,
                timestamp: msec,
                messageStreamID: 1,
                command: 'onStatus',
                transactionID: requestCommand.transactionID,
                objects: [
                  createAMF0Data(null), createAMF0Object({
                    level: 'status',
                    code: 'NetStream.Unpause.Notify',
                    description: "Unpausing " + _this.stream.id + ".",
                    details: _this.stream.id,
                    clientid: _this.clientid
                  })
                ]
              }, _this.chunkSize);
              playStart = createAMF0CommandMessage({
                chunkStreamID: 4,
                timestamp: msec,
                messageStreamID: 1,
                command: 'onStatus',
                transactionID: 0,
                objects: [
                  createAMF0Data(null), createAMF0Object({
                    level: 'status',
                    code: 'NetStream.Play.Start',
                    description: "Started playing " + _this.stream.id + ".",
                    details: _this.stream.id,
                    clientid: _this.clientid
                  })
                ]
              }, _this.chunkSize);
              rtmpSampleAccess = createAMF0DataMessage({
                chunkStreamID: 4,
                timestamp: msec,
                messageStreamID: 1,
                objects: [createAMF0Data('|RtmpSampleAccess'), createAMF0Data(false), createAMF0Data(false)]
              }, _this.chunkSize);
              dataStart = createAMF0DataMessage({
                chunkStreamID: 4,
                timestamp: msec,
                messageStreamID: 1,
                objects: [
                  createAMF0Data('onStatus'), createAMF0Object({
                    code: 'NetStream.Data.Start'
                  })
                ]
              }, _this.chunkSize);
              metadata = {
                canSeekToEnd: false,
                cuePoints: [],
                hasMetadata: true,
                hasCuePoints: false
              };
              stream = _this.stream;
              if (stream.isVideoStarted) {
                metadata.hasVideo = true;
                metadata.framerate = stream.videoFrameRate;
                metadata.height = stream.videoHeight;
                metadata.videocodecid = config.flv.videocodecid;
                metadata.videodatarate = config.videoBitrateKbps;
                metadata.width = stream.videoWidth;
                metadata.avclevel = stream.videoAVCLevel;
                metadata.avcprofile = stream.videoAVCProfile;
              }
              if (stream.isAudioStarted) {
                metadata.hasAudio = true;
                metadata.audiocodecid = config.flv.audiocodecid;
                metadata.audiodatarate = config.audioBitrateKbps;
                metadata.audiodelay = 0;
                metadata.audiosamplerate = stream.audioSampleRate;
                metadata.stereo = stream.audioChannels > 1;
                metadata.audiochannels = stream.audioChannels;
                metadata.aacaot = stream.audioObjectType;
              }
              metadata.duration = stream.durationSeconds;
              metadata.lasttimestamp = stream.lastTagTimestamp;
              logger.debug("[rtmp] metadata:");
              logger.debug(metadata);
              onMetaData = createAMF0DataMessage({
                chunkStreamID: 4,
                timestamp: msec,
                messageStreamID: 1,
                objects: [createAMF0Data('onMetaData'), createAMF0Data(metadata)]
              }, _this.chunkSize);
              codecConfigs = _this.getCodecConfigs(msec);
              callback(null, _this.concatenate([setChunkSize, streamIsRecorded, streamBegin1, unpauseNotify, playStart, rtmpSampleAccess, dataStart, onMetaData, codecConfigs]));
              seq = new Sequent;
              _this.startPlaying();
              if (_this.seekedDuringPause) {
                _this.stream.sendVideoPacketsSinceLastKeyFrame(seekMsec / 1000, function() {
                  return seq.done();
                });
              } else {
                _this.isResuming = true;
                seq.done();
              }
              return seq.wait(1, function() {
                var isResumed;
                isResumed = _this.stream.resume();
                _this.seekedDuringPause = false;
                if (!isResumed) {
                  return logger.debug("[rtmp:client=" + _this.clientid + "] cannot resume (EOF reached)");
                } else {
                  return logger.info("[rtmp:client=" + _this.clientid + "] resumed at " + (msec / 1000) + " sec (client player time)");
                }
              });
            };
          })(this));
        } else {
          this.startPlaying();
          return this.respondPlay(requestCommand, callback, (ref2 = this.stream) != null ? ref2.id : void 0);
        }
      }
    };

    RTMPSession.prototype.closeStream = function(callback) {
      this.isPlaying = false;
      this.isWaitingForKeyFrame = false;
      return callback(null);
    };

    RTMPSession.prototype.deleteStream = function(requestCommand, callback) {
      var _result;
      this.isPlaying = false;
      this.isWaitingForKeyFrame = false;
      _result = createAMF0CommandMessage({
        chunkStreamID: 3,
        timestamp: 0,
        messageStreamID: 0,
        command: '_result',
        transactionID: requestCommand.transactionID,
        objects: [createAMF0Data(null), createAMF0Data(null)]
      });
      return callback(null, _result);
    };

    RTMPSession.prototype.handleAMFDataMessage = function(dataMessage, callback) {
      callback(null);
      if (dataMessage.objects.length === 0) {
        logger.warn("[rtmp:receive] empty AMF data");
      }
      switch (dataMessage.objects[0].value) {
        case '@setDataFrame':
          this.receiveSetDataFrame(dataMessage);
          break;
        default:
          logger.warn("[rtmp:receive] unknown (not implemented) AMF data: " + dataMessage.objects[0].value);
          logger.debug(dataMessage);
      }
    };

    RTMPSession.prototype.handleAMFCommandMessage = function(commandMessage, callback) {
      var ref, ref1, ref2, streamId;
      switch (commandMessage.command) {
        case 'connect':
          this.objectEncoding = (ref = commandMessage.objects[0]) != null ? (ref1 = ref.value) != null ? ref1.objectEncoding : void 0 : void 0;
          return this.respondConnect(commandMessage, callback);
        case 'createStream':
          return this.respondCreateStream(commandMessage, callback);
        case 'play':
          streamId = (ref2 = commandMessage.objects[1]) != null ? ref2.value : void 0;
          return this.respondPlay(commandMessage, callback);
        case 'closeStream':
          return this.closeStream(callback);
        case 'deleteStream':
          return this.deleteStream(commandMessage, callback);
        case 'pause':
          return this.respondPause(commandMessage, callback);
        case 'pauseRaw':
          logger.debug("[rtmp] ignoring pauseRaw");
          return callback(null);
        case 'seek':
          return this.respondSeek(commandMessage, callback);
        case 'releaseStream':
          return this.respondReleaseStream(commandMessage, callback);
        case 'FCPublish':
          return this.respondFCPublish(commandMessage, callback);
        case 'publish':
          return this.respondPublish(commandMessage, callback);
        case 'FCUnpublish':
          return this.respondFCUnpublish(commandMessage, callback);
        default:
          logger.warn("[rtmp:receive] unknown (not implemented) AMF command: " + commandMessage.command);
          logger.debug(commandMessage);
          return callback(null);
      }
    };

    RTMPSession.prototype.createAck = function() {
      if (DEBUG_OUTGOING_RTMP_PACKETS) {
        logger.info("createAck");
      }
      return createRTMPMessage({
        chunkStreamID: 2,
        timestamp: 0,
        messageTypeID: 3,
        messageStreamID: 0,
        body: new Buffer([(this.receivedBytes >>> 24) & 0xff, (this.receivedBytes >>> 16) & 0xff, (this.receivedBytes >>> 8) & 0xff, this.receivedBytes & 0xff])
      });
    };

    RTMPSession.prototype.handleData = function(buf, callback) {
      var consumeNextRTMPMessage, onConsumeAllPackets, outputs, seq;
      this.scheduleTimeout();
      outputs = [];
      seq = new Sequent;
      if (this.windowAckSize != null) {
        this.receivedBytes += buf.length;
        if (this.receivedBytes - this.lastSentAckBytes > this.windowAckSize / 2) {
          outputs.push(this.createAck());
          this.lastSentAckBytes = this.receivedBytes;
        }
      }
      if (this.state === SESSION_STATE_NEW) {
        if (this.tmpBuf != null) {
          buf = Buffer.concat([this.tmpBuf, buf], this.tmpBuf.length + buf.length);
          this.tmpBuf = null;
        }
        if (buf.length < 1537) {
          logger.debug("[rtmp] waiting for C0+C1");
          this.tmpBuf = buf;
          return;
        }
        this.tmpBuf = null;
        this.state = SESSION_STATE_HANDSHAKE_ONGOING;
        this.respondHandshake(buf, callback);
        return;
      } else if (this.state === SESSION_STATE_HANDSHAKE_ONGOING) {
        if (this.tmpBuf != null) {
          buf = Buffer.concat([this.tmpBuf, buf], this.tmpBuf.length + buf.length);
          this.tmpBuf = null;
        }
        if (buf.length < 1536) {
          logger.debug("[rtmp] waiting for C2");
          this.tmpBuf = buf;
          return;
        }
        this.tmpBuf = null;
        this.state = SESSION_STATE_HANDSHAKE_DONE;
        logger.debug("[rtmp] handshake success");
        if (buf.length <= 1536) {
          callback(null);
          return;
        }
        buf = buf.slice(1536);
      }
      if (this.state !== SESSION_STATE_HANDSHAKE_DONE) {
        logger.error("[rtmp:receive] unknown session state: " + this.state);
        return callback(new Error("Unknown session state"));
      } else {
        if (this.useEncryption) {
          buf = this.decrypt(buf);
        }
        if (this.tmpBuf != null) {
          buf = Buffer.concat([this.tmpBuf, buf], this.tmpBuf.length + buf.length);
          this.tmpBuf = null;
        }
        onConsumeAllPackets = (function(_this) {
          return function() {
            var outbuf;
            outbuf = _this.concatenate(outputs);
            if (_this.useEncryption) {
              outbuf = _this.encrypt(outbuf);
            }
            return callback(null, outbuf);
          };
        })(this);
        consumeNextRTMPMessage = (function(_this) {
          return function() {
            var acknowledgementMessage, audioData, bufferLength, commandMessage, dataMessage, debugMsg, dts, e, j, len1, msec, newChunkSize, packageJson, parseResult, pts, ref, results, rtmpMessage, stream, streamID, timestamp, userControlMessage, videoData;
            if (buf == null) {
              onConsumeAllPackets();
              return;
            }
            parseResult = _this.parseRTMPMessages(buf);
            if (parseResult.consumedLen === 0) {
              _this.tmpBuf = buf;
              onConsumeAllPackets();
              return;
            } else if (parseResult.consumedLen < buf.length) {
              buf = buf.slice(parseResult.consumedLen);
            } else {
              buf = null;
            }
            seq.reset();
            seq.wait(parseResult.rtmpMessages.length, function(err, output) {
              if (err != null) {
                logger.error("[rtmp:receive] ignoring invalid packet (" + err + ")");
              }
              if (output != null) {
                outputs.push(output);
              }
              return consumeNextRTMPMessage();
            });
            ref = parseResult.rtmpMessages;
            results = [];
            for (j = 0, len1 = ref.length; j < len1; j++) {
              rtmpMessage = ref[j];
              switch (rtmpMessage.messageTypeID) {
                case 1:
                  newChunkSize = rtmpMessage.body[0] * Math.pow(256, 3) + (rtmpMessage.body[1] << 16) + (rtmpMessage.body[2] << 8) + rtmpMessage.body[3];
                  if (DEBUG_INCOMING_RTMP_PACKETS) {
                    logger.info("[rtmp:receive] Set Chunk Size: " + newChunkSize);
                  }
                  _this.receiveChunkSize = newChunkSize;
                  results.push(seq.done());
                  break;
                case 3:
                  acknowledgementMessage = parseAcknowledgementMessage(rtmpMessage.body);
                  if (DEBUG_INCOMING_RTMP_PACKETS) {
                    logger.info("[rtmp:receive] Ack: " + acknowledgementMessage.sequenceNumber);
                  }
                  results.push(seq.done());
                  break;
                case 4:
                  userControlMessage = parseUserControlMessage(rtmpMessage.body);
                  if (userControlMessage.eventType === 3) {
                    streamID = (userControlMessage.eventData[0] << 24) + (userControlMessage.eventData[1] << 16) + (userControlMessage.eventData[2] << 8) + userControlMessage.eventData[3];
                    bufferLength = (userControlMessage.eventData[4] << 24) + (userControlMessage.eventData[5] << 16) + (userControlMessage.eventData[6] << 8) + userControlMessage.eventData[7];
                    if (DEBUG_INCOMING_RTMP_PACKETS) {
                      logger.info("[rtmp:receive] SetBufferLength: streamID=" + streamID + " bufferLength=" + bufferLength);
                    }
                  } else if (userControlMessage.eventType === 7) {
                    timestamp = (userControlMessage.eventData[0] << 24) + (userControlMessage.eventData[1] << 16) + (userControlMessage.eventData[2] << 8) + userControlMessage.eventData[3];
                    if (DEBUG_INCOMING_RTMP_PACKETS) {
                      logger.info("[rtmp:receive] PingResponse: timestamp=" + timestamp);
                    }
                  } else {
                    if (DEBUG_INCOMING_RTMP_PACKETS) {
                      logger.info("[rtmp:receive] User Control Message");
                      logger.info(userControlMessage);
                    }
                  }
                  results.push(seq.done());
                  break;
                case 5:
                  _this.windowAckSize = (rtmpMessage.body[0] << 24) + (rtmpMessage.body[1] << 16) + (rtmpMessage.body[2] << 8) + rtmpMessage.body[3];
                  if (DEBUG_INCOMING_RTMP_PACKETS) {
                    logger.info("[rtmp:receive] WindowAck: " + _this.windowAckSize);
                  }
                  results.push(seq.done());
                  break;
                case 8:
                  if (DEBUG_INCOMING_RTMP_PACKETS) {
                    logger.info("[rtmp:receive] Audio Message");
                  }
                  audioData = _this.parseAudioMessage(rtmpMessage.body);
                  if (audioData.adtsFrame != null) {
                    if (!_this.isFirstAudioReceived) {
                      _this.emit('audio_start', _this.stream.id);
                      _this.isFirstAudioReceived = true;
                    }
                    pts = dts = flv.convertMsToPTS(rtmpMessage.timestamp);
                    _this.emit('audio_data', _this.stream.id, pts, dts, audioData.adtsFrame);
                  }
                  results.push(seq.done());
                  break;
                case 9:
                  if (DEBUG_INCOMING_RTMP_PACKETS) {
                    logger.info("[rtmp:receive] Video Message");
                  }
                  videoData = _this.parseVideoMessage(rtmpMessage.body);
                  if (videoData.nalUnitGlob != null) {
                    if (!_this.isFirstVideoReceived) {
                      _this.emit('video_start', _this.stream.id);
                      _this.isFirstVideoReceived = true;
                    }
                    dts = rtmpMessage.timestamp;
                    pts = dts + videoData.info.videoDataTag.compositionTime;
                    pts = flv.convertMsToPTS(pts);
                    dts = flv.convertMsToPTS(dts);
                    _this.emit('video_data', _this.stream.id, pts, dts, videoData.nalUnitGlob);
                  }
                  if (videoData.isEOS) {
                    logger.info("[rtmp:client=" + _this.clientid + "] received EOS for stream: " + _this.stream.id);
                    stream = avstreams.get(_this.stream.id);
                    if (stream == null) {
                      logger.error("[rtmp:client=" + _this.clientid + "] error: unknown stream: " + _this.stream.id);
                    }
                    stream.emit('end');
                  }
                  results.push(seq.done());
                  break;
                case 15:
                  try {
                    dataMessage = parseAMF0DataMessage(rtmpMessage.body.slice(1));
                  } catch (error) {
                    e = error;
                    logger.error("[rtmp] error: failed to parse AMF0 data message: " + e.stack);
                    logger.error("messageTypeID=" + rtmpMessage.messageTypeID + " body:");
                    Bits.hexdump(rtmpMessage.body);
                    seq.done(e);
                  }
                  if (dataMessage != null) {
                    if (DEBUG_INCOMING_RTMP_PACKETS) {
                      logger.info("[rtmp:receive] AMF3 data:");
                      logger.info(dataMessage);
                    }
                    results.push(_this.handleAMFDataMessage(dataMessage, function(err, output) {
                      if (err != null) {
                        logger.error("[rtmp:receive] packet error: " + err);
                      }
                      if (output != null) {
                        outputs.push(output);
                      }
                      return seq.done();
                    }));
                  } else {
                    results.push(void 0);
                  }
                  break;
                case 17:
                  commandMessage = parseAMF0CommandMessage(rtmpMessage.body.slice(1));
                  if (DEBUG_INCOMING_RTMP_PACKETS) {
                    debugMsg = "[rtmp:receive] AMF3 command: " + commandMessage.command;
                    if (commandMessage.command === 'pause') {
                      msec = commandMessage.objects[2].value;
                      if (commandMessage.objects[1].value === true) {
                        debugMsg += " (doPause=true msec=" + msec + ")";
                      } else {
                        debugMsg += " (doPause=false msec=" + msec + ")";
                      }
                    } else if (commandMessage.command === 'seek') {
                      msec = commandMessage.objects[1].value;
                      debugMsg += " (msec=" + msec + ")";
                    }
                    logger.debug(debugMsg);
                  }
                  results.push(_this.handleAMFCommandMessage(commandMessage, function(err, output) {
                    if (err != null) {
                      logger.error("[rtmp:receive] packet error: " + err);
                    }
                    if (output != null) {
                      outputs.push(output);
                    }
                    return seq.done();
                  }));
                  break;
                case 18:
                  try {
                    dataMessage = parseAMF0DataMessage(rtmpMessage.body);
                  } catch (error) {
                    e = error;
                    logger.error("[rtmp] error: failed to parse AMF0 data message: " + e.stack);
                    logger.error("messageTypeID=" + rtmpMessage.messageTypeID + " body:");
                    Bits.hexdump(rtmpMessage.body);
                    seq.done(e);
                  }
                  if (dataMessage != null) {
                    if (DEBUG_INCOMING_RTMP_PACKETS) {
                      logger.info("[rtmp:receive] AMF0 data:");
                      logger.info(dataMessage);
                    }
                    results.push(_this.handleAMFDataMessage(dataMessage, function(err, output) {
                      if (err != null) {
                        logger.error("[rtmp:receive] packet error: " + err);
                      }
                      if (output != null) {
                        outputs.push(output);
                      }
                      return seq.done();
                    }));
                  } else {
                    results.push(void 0);
                  }
                  break;
                case 20:
                  commandMessage = parseAMF0CommandMessage(rtmpMessage.body);
                  if (DEBUG_INCOMING_RTMP_PACKETS) {
                    logger.info("[rtmp:receive] AMF0 command: " + commandMessage.command);
                  }
                  results.push(_this.handleAMFCommandMessage(commandMessage, function(err, output) {
                    if (err != null) {
                      logger.error("[rtmp:receive] packet error: " + err);
                    }
                    if (output != null) {
                      outputs.push(output);
                    }
                    return seq.done();
                  }));
                  break;
                default:
                  logger.error("----- BUG -----");
                  logger.error("[rtmp:receive] received unknown (not implemented) message type ID: " + rtmpMessage.messageTypeID);
                  logger.error(rtmpMessage);
                  packageJson = require('./package.json');
                  logger.error("server version: " + packageJson.version);
                  logger.error("Please report this bug along with the video file or relevant part of");
                  logger.error("pcap file, and the full (uncut) output of node-rtsp-rtsp-server. Thanks.");
                  logger.error("https://github.com/iizukanao/node-rtsp-rtmp-server/issues");
                  logger.error("---------------");
                  results.push(seq.done());
              }
            }
            return results;
          };
        })(this);
        return consumeNextRTMPMessage();
      }
    };

    return RTMPSession;

  })();

  RTMPServer = (function() {
    function RTMPServer(opts) {
      var ref;
      this.eventListeners = {};
      this.port = (ref = opts != null ? opts.rtmpServerPort : void 0) != null ? ref : 1935;
      this.server = net.createServer((function(_this) {
        return function(c) {
          var sess;
          c.clientId = ++clientMaxId;
          sess = new RTMPSession(c);
          logger.info("[rtmp:client=" + sess.clientid + "] connected");
          sessions[c.clientId] = sess;
          sessionsCount++;
          c.rtmpSession = sess;
          sess.on('data', function(data) {
            if ((data != null) && data.length > 0) {
              return c.write(data);
            }
          });
          sess.on('video_start', function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.emit.apply(_this, ['video_start'].concat(slice.call(args)));
          });
          sess.on('audio_start', function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.emit.apply(_this, ['audio_start'].concat(slice.call(args)));
          });
          sess.on('video_data', function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.emit.apply(_this, ['video_data'].concat(slice.call(args)));
          });
          sess.on('audio_data', function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.emit.apply(_this, ['audio_data'].concat(slice.call(args)));
          });
          c.on('close', function() {
            logger.info("[rtmp:client=" + sess.clientid + "] disconnected");
            if (sessions[c.clientId] != null) {
              sessions[c.clientId].teardown();
              delete sessions[c.clientId];
              sessionsCount--;
            }
            return _this.dumpSessions();
          });
          c.on('error', function(err) {
            logger.error("[rtmp:client=" + sess.clientid + "] socket error: " + err);
            return c.destroy();
          });
          c.on('data', function(data) {
            return c.rtmpSession.handleData(data, function(err, output) {
              if (err) {
                return logger.error("[rtmp] error: " + err);
              } else if (output != null) {
                if (output.length > 0) {
                  return c.write(output);
                }
              }
            });
          });
          return _this.dumpSessions();
        };
      })(this));
    }

    RTMPServer.prototype.start = function(opts, callback) {
      var ref, serverPort;
      serverPort = (ref = opts != null ? opts.port : void 0) != null ? ref : this.port;
      logger.debug("[rtmp] starting server on port " + serverPort);
      return this.server.listen(serverPort, '0.0.0.0', 511, (function(_this) {
        return function() {
          logger.info("[rtmp] server started on port " + serverPort);
          return typeof callback === "function" ? callback() : void 0;
        };
      })(this));
    };

    RTMPServer.prototype.stop = function(callback) {
      return this.server.close(callback);
    };

    RTMPServer.prototype.on = function(event, listener) {
      if (this.eventListeners[event] != null) {
        this.eventListeners[event].push(listener);
      } else {
        this.eventListeners[event] = [listener];
      }
    };

    RTMPServer.prototype.emit = function() {
      var args, event, j, len1, listener, ref;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (this.eventListeners[event] != null) {
        ref = this.eventListeners[event];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          listener = ref[j];
          listener.apply(null, args);
        }
      }
    };

    RTMPServer.prototype.dumpSessions = function() {
      var rtmptSession, session, sessionID;
      logger.raw("[rtmp: " + sessionsCount + " sessions]");
      for (sessionID in sessions) {
        session = sessions[sessionID];
        logger.raw(" " + session.toString());
      }
      if (rtmptSessionsCount > 0) {
        logger.raw("[rtmpt: " + rtmptSessionsCount + " sessions]");
        for (sessionID in rtmptSessions) {
          rtmptSession = rtmptSessions[sessionID];
          logger.raw(" " + rtmptSession.toString());
        }
      }
    };

    RTMPServer.prototype.teardownRTMPTClient = function(socket) {
      var ref, tsession;
      if (socket.rtmptClientID != null) {
        logger.debug("[rtmp] teardownRTMPTClient: " + socket.rtmptClientID);
        tsession = rtmptSessions[socket.rtmptClientID];
        if (tsession != null) {
          if ((ref = tsession.rtmpSession) != null) {
            ref.teardown();
          }
          delete rtmptSessions[socket.rtmptClientID];
          return rtmptSessionsCount--;
        }
      }
    };

    RTMPServer.prototype.updateConfig = function(newConfig) {
      return config = newConfig;
    };

    RTMPServer.prototype.sendVideoPacket = function(stream, nalUnits, pts, dts) {
      var buf, compositionTimeMs, firstByte, hasKeyFrame, j, k, len1, len2, message, nalUnit, nalUnitType, payloadLen, timestamp, totalBytes;
      if (DEBUG_INCOMING_STREAM_DATA) {
        totalBytes = 0;
        for (j = 0, len1 = nalUnits.length; j < len1; j++) {
          nalUnit = nalUnits[j];
          totalBytes += nalUnit.length;
        }
        logger.info("received video: stream=" + stream.id + " " + totalBytes + " bytes; " + nalUnits.length + " NAL units (" + (nalUnits.map(function(nalu) {
          return nalu[0] & 0x1f;
        }).join(',')) + "); pts=" + pts);
      }
      if (dts > pts) {
        throw new Error("pts must be >= dts (pts=" + pts + " dts=" + dts + ")");
      }
      timestamp = convertPTSToMilliseconds(dts);
      if (sessionsCount + rtmptSessionsCount === 0) {
        return;
      }
      message = [];
      hasKeyFrame = false;
      for (k = 0, len2 = nalUnits.length; k < len2; k++) {
        nalUnit = nalUnits[k];
        nalUnitType = h264.getNALUnitType(nalUnit);
        if (config.dropH264AccessUnitDelimiter && (nalUnitType === h264.NAL_UNIT_TYPE_ACCESS_UNIT_DELIMITER)) {
          continue;
        }
        if (nalUnitType === h264.NAL_UNIT_TYPE_IDR_PICTURE) {
          hasKeyFrame = true;
        }
        payloadLen = nalUnit.length;
        message.push(new Buffer([(payloadLen >>> 24) & 0xff, (payloadLen >>> 16) & 0xff, (payloadLen >>> 8) & 0xff, payloadLen & 0xff]));
        message.push(nalUnit);
      }
      if (message.length === 0) {
        return;
      }
      if (hasKeyFrame) {
        firstByte = (1 << 4) | config.flv.videocodecid;
      } else {
        firstByte = (2 << 4) | config.flv.videocodecid;
      }
      compositionTimeMs = Math.floor((pts - dts) / 90);
      if (compositionTimeMs > 0x7fffff) {
        compositionTimeMs = 0x7fffff;
      }
      message.unshift(new Buffer([firstByte, AVC_PACKET_TYPE_NALU, (compositionTimeMs >> 16) & 0xff, (compositionTimeMs >> 8) & 0xff, compositionTimeMs & 0xff]));
      buf = Buffer.concat(message);
      queueVideoMessage(stream, {
        body: buf,
        timestamp: timestamp,
        isKeyFrame: hasKeyFrame,
        compositionTime: compositionTimeMs
      });
      stream.rtmpLastTimestamp = timestamp;
    };

    RTMPServer.prototype.sendAudioPacket = function(stream, rawDataBlock, timestamp) {
      var buf, headerBytes;
      if (DEBUG_INCOMING_STREAM_DATA) {
        logger.info("received audio: stream=" + stream.id + " " + rawDataBlock.length + " bytes; timestamp=" + timestamp);
      }
      timestamp = convertPTSToMilliseconds(timestamp);
      if (sessionsCount + rtmptSessionsCount === 0) {
        return;
      }
      headerBytes = new Buffer(flv.createAACAudioDataTag({
        aacPacketType: flv.AAC_PACKET_TYPE_RAW
      }));
      buf = Buffer.concat([headerBytes, rawDataBlock], rawDataBlock.length + 2);
      queueAudioMessage(stream, {
        body: buf,
        timestamp: timestamp
      });
      stream.rtmpLastTimestamp = timestamp;
    };

    RTMPServer.prototype.sendEOS = function(stream) {
      var lastTimestamp, playComplete, playStop, ref, streamEOF1;
      logger.debug("[rtmp] sendEOS for stream " + stream.id);
      lastTimestamp = (ref = stream.rtmpLastTimestamp) != null ? ref : 0;
      playComplete = createAMF0DataMessageParams({
        chunkStreamID: 4,
        timestamp: lastTimestamp,
        messageStreamID: 1,
        objects: [
          createAMF0Data('onPlayStatus'), createAMF0Object({
            level: 'status',
            code: 'NetStream.Play.Complete',
            duration: 0,
            bytes: 0
          })
        ]
      });
      playStop = createAMF0CommandMessageParams({
        chunkStreamID: 4,
        timestamp: lastTimestamp,
        messageStreamID: 1,
        command: 'onStatus',
        transactionID: 0,
        objects: [
          createAMF0Data(null), createAMF0Object({
            level: 'status',
            code: 'NetStream.Play.Stop',
            description: "Stopped playing " + stream.id + ".",
            clientid: this.clientid,
            reason: '',
            details: stream.id
          })
        ]
      });
      streamEOF1 = {
        chunkStreamID: 2,
        timestamp: 0,
        messageTypeID: 0x04,
        messageStreamID: 0,
        body: new Buffer([0, 1, 0, 0, 0, 1])
      };
      return queueRTMPMessages(stream, [playComplete, playStop, streamEOF1], {
        forceFlush: true,
        hasControlMessage: true
      });
    };

    RTMPServer.prototype.handleRTMPTRequest = function(req, callback) {
      var client, command, index, info, match, response, results, session;
      if ((match = /^\/([^\/]+)\/([^\/]+)(?:\/([^\/]+))?/.exec(req.uri)) != null) {
        command = match[1];
        client = match[2];
        index = match[3];
        if (index == null) {
          index = client;
        }
        if ((command === 'fcs') && (index === 'ident2')) {
          response = "HTTP/1.1 400 RTMPT command /fcs/ident2 is not supported\nCache-Control: no-cache\nContent-Type: text/plain\nContent-Length: 0\nConnection: keep-alive\n\n".replace(/\n/g, '\r\n');
          return callback(null, response);
        } else if (command === 'open') {
          session = new RTMPTSession(req.socket, (function(_this) {
            return function() {
              rtmptSessions[session.id] = session;
              rtmptSessionsCount++;
              session.respondOpen(req, callback);
              return _this.dumpSessions();
            };
          })(this));
          session.on('video_start', (function(_this) {
            return function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              return _this.emit.apply(_this, ['video_start'].concat(slice.call(args)));
            };
          })(this));
          session.on('audio_start', (function(_this) {
            return function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              return _this.emit.apply(_this, ['audio_start'].concat(slice.call(args)));
            };
          })(this));
          session.on('video_data', (function(_this) {
            return function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              return _this.emit.apply(_this, ['video_data'].concat(slice.call(args)));
            };
          })(this));
          return session.on('audio_data', (function(_this) {
            return function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              return _this.emit.apply(_this, ['audio_data'].concat(slice.call(args)));
            };
          })(this));
        } else if (command === 'idle') {
          session = rtmptSessions[client];
          if (session != null) {
            index = parseInt(index);
            session.respondIdle(req, callback);
            if (session.requestBuffer != null) {
              return session.requestBuffer.nextIndex = index + 1;
            } else {
              return session.requestBuffer = {
                nextIndex: index + 1,
                reqs: []
              };
            }
          } else {
            return callback(new Error("No such session"));
          }
        } else if (command === 'send') {
          session = rtmptSessions[client];
          if (session != null) {
            index = parseInt(index);
            if (session.requestBuffer != null) {
              if (index > session.requestBuffer.nextIndex) {
                session.requestBuffer.reqs.push({
                  req: req,
                  index: index,
                  callback: callback
                });
                session.requestBuffer.reqs.sort(function(a, b) {
                  return a.index - b.index;
                });
              } else if (index === session.requestBuffer.nextIndex) {
                session.respondSend(req, callback);
                session.requestBuffer.nextIndex = index + 1;
              } else {
                logger.warn("[rtmpt] received stale request: " + index);
              }
              if ((session.requestBuffer.reqs.length > 0) && (index - session.requestBuffer.reqs[0].index > RTMPT_SEND_REQUEST_BUFFER_SIZE)) {
                info = session.requestBuffer.reqs[0];
                if (info.index === session.requestBuffer.nextIndex + 1) {
                  logger.warn("[rtmpt] discarded lost request: " + session.requestBuffer.nextIndex);
                } else {
                  logger.warn("[rtmpt] discarded lost requests: " + session.requestBuffer.nextIndex + "-" + (info.index - 1));
                }
                session.requestBuffer.nextIndex = info.index;
              }
              results = [];
              while ((session.requestBuffer.reqs.length > 0) && (session.requestBuffer.reqs[0].index === session.requestBuffer.nextIndex)) {
                info = session.requestBuffer.reqs.shift();
                session.respondSend(info.req, info.callback);
                results.push(session.requestBuffer.nextIndex = info.index + 1);
              }
              return results;
            } else {
              session.requestBuffer = {
                nextIndex: index + 1,
                reqs: []
              };
              return session.respondSend(req, callback);
            }
          } else {
            return callback(new Error("No such session"));
          }
        } else if (command === 'close') {
          session = rtmptSessions[client];
          if (session != null) {
            return session.respondClose(req, callback);
          } else {
            return callback(new Error("No such session"));
          }
        } else {
          return callback(new Error("Unknown command: " + command));
        }
      } else {
        return callback(new Error("Unknown URI: " + req.uri));
      }
    };

    return RTMPServer;

  })();

  generateNewSessionID = function(callback) {
    return generateSessionID(function(err, sid) {
      if (err) {
        callback(err);
        return;
      }
      if (rtmptSessions[sid] != null) {
        return generateNewSessionID(callback);
      } else {
        return callback(null, sid);
      }
    });
  };

  generateSessionID = function(callback) {
    return crypto.randomBytes(16, function(err, buf) {
      var sid;
      if (err) {
        return callback(err);
      } else {
        sid = buf.toString('hex').slice(0, 31);
        return callback(null, sid);
      }
    });
  };

  RTMPTSession = (function() {
    function RTMPTSession(socket, callback) {
      this.creationDate = new Date;
      this.eventListeners = {};
      this.socket = socket;
      this.pollingDelay = 1;
      this.pendingResponses = [];
      this.requestBuffer = null;
      this.rtmpSession = new RTMPSession(socket);
      this.rtmpSession.on('data', (function(_this) {
        return function(data) {
          _this.scheduleTimeout();
          return _this.pendingResponses.push(data);
        };
      })(this));
      this.rtmpSession.on('video_start', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.emit.apply(_this, ['video_start'].concat(slice.call(args)));
        };
      })(this));
      this.rtmpSession.on('audio_start', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.emit.apply(_this, ['audio_start'].concat(slice.call(args)));
        };
      })(this));
      this.rtmpSession.on('video_data', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.emit.apply(_this, ['video_data'].concat(slice.call(args)));
        };
      })(this));
      this.rtmpSession.on('audio_data', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.emit.apply(_this, ['audio_data'].concat(slice.call(args)));
        };
      })(this));
      this.rtmpSession.on('teardown', (function(_this) {
        return function() {
          logger.info("[rtmpt:" + _this.rtmpSession.clientid + "] received teardown");
          return _this.close();
        };
      })(this));
      generateNewSessionID((function(_this) {
        return function(err, sid) {
          if (err) {
            return callback(err);
          } else {
            _this.id = sid;
            _this.socket.rtmptClientID = _this.id;
            _this.scheduleTimeout();
            return typeof callback === "function" ? callback(null) : void 0;
          }
        };
      })(this));
    }

    RTMPTSession.prototype.toString = function() {
      return this.id + ": rtmp_session=" + this.rtmpSession.clientid + " created_at=" + this.creationDate;
    };

    RTMPTSession.prototype.on = function(event, listener) {
      if (this.eventListeners[event] != null) {
        this.eventListeners[event].push(listener);
      } else {
        this.eventListeners[event] = [listener];
      }
    };

    RTMPTSession.prototype.emit = function() {
      var args, event, j, len1, listener, ref;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (this.eventListeners[event] != null) {
        ref = this.eventListeners[event];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          listener = ref[j];
          listener.apply(null, args);
        }
      }
    };

    RTMPTSession.prototype.clearTimeout = function() {
      if (this.timeoutTimer != null) {
        clearTimeout(this.timeoutTimer);
        return this.timeoutTimer = null;
      }
    };

    RTMPTSession.prototype.scheduleTimeout = function() {
      if (this.isClosed) {
        return;
      }
      this.clearTimeout();
      this.lastTimeoutScheduledTime = Date.now();
      return this.timeoutTimer = setTimeout((function(_this) {
        return function() {
          if (_this.isClosed) {
            return;
          }
          if (_this.timeoutTimer == null) {
            return;
          }
          if (Date.now() - _this.lastTimeoutScheduledTime < config.rtmptSessionTimeoutMs) {
            return;
          }
          logger.info("[rtmpt] session timeout: " + _this.id);
          return _this.close();
        };
      })(this), config.rtmptSessionTimeoutMs);
    };

    RTMPTSession.prototype.close = function() {
      if (this.isClosed) {
        return;
      }
      logger.info("[rtmpt:" + this.rtmpSession.clientid + "] close");
      this.isClosed = true;
      this.clearTimeout();
      if (this.rtmpSession != null) {
        this.rtmpSession.teardown();
        this.rtmpSession = null;
      }
      if (rtmptSessions[this.id] != null) {
        delete rtmptSessions[this.id];
        return rtmptSessionsCount--;
      }
    };

    RTMPTSession.prototype.createHTTPResponse = function(buf) {
      var allBytes, contentLength, header;
      this.scheduleTimeout();
      if (buf != null) {
        contentLength = buf.length;
      } else {
        contentLength = 0;
      }
      header = ("HTTP/1.1 200 OK\nCache-Control: no-cache\nContent-Length: " + contentLength + "\nConnection: keep-alive\nContent-Type: application/x-fcs\n\n").replace(/\n/g, '\r\n');
      allBytes = new Buffer(header, 'utf8');
      if (buf != null) {
        allBytes = Buffer.concat([allBytes, buf], allBytes.length + buf.length);
      }
      return allBytes;
    };

    RTMPTSession.prototype.respondOpen = function(req, callback) {
      var body, bodyBytes;
      this.scheduleTimeout();
      body = this.id + '\n';
      bodyBytes = new Buffer(body, 'utf8');
      return callback(null, this.createHTTPResponse(bodyBytes));
    };

    RTMPTSession.prototype.respondIdle = function(req, callback) {
      var allBytes, bufs, j, len1, ref, resp, totalLength;
      this.scheduleTimeout();
      bufs = [new Buffer([this.pollingDelay])];
      totalLength = 1;
      ref = this.pendingResponses;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        resp = ref[j];
        bufs.push(resp);
        totalLength += resp.length;
      }
      this.pendingResponses = [];
      allBytes = Buffer.concat(bufs, totalLength);
      return callback(null, this.createHTTPResponse(allBytes));
    };

    RTMPTSession.prototype.respondSend = function(req, callback) {
      this.scheduleTimeout();
      return this.rtmpSession.handleData(req.rawbody, (function(_this) {
        return function(err, output) {
          var allBytes, interval;
          if (err) {
            logger.error("[rtmpt:send-resp] Error: " + err);
            return callback(err);
          } else if (output != null) {
            interval = new Buffer([_this.pollingDelay]);
            allBytes = Buffer.concat([interval, output], 1 + output.length);
            return callback(null, _this.createHTTPResponse(allBytes));
          } else {
            allBytes = new Buffer([_this.pollingDelay]);
            return callback(null, _this.createHTTPResponse(allBytes));
          }
        };
      })(this));
    };

    RTMPTSession.prototype.respondClose = function(req, callback) {
      var allBytes;
      allBytes = new Buffer([this.pollingDelay]);
      this.close();
      return callback(null, this.createHTTPResponse(allBytes));
    };

    return RTMPTSession;

  })();

  api = {
    RTMPServer: RTMPServer
  };

  module.exports = api;

}).call(this);
