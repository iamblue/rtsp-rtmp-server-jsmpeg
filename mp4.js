// Generated by CoffeeScript 1.12.4
(function() {
  var AVCConfigurationBox, AVCSampleEntry, AudioSampleEntry, Bits, Box, CTOOBox, ChunkOffsetBox, CompositionOffsetBox, Container, DEBUG, DEBUG_OUTGOING_MP4_DATA, DataEntryUrlBox, DataEntryUrnBox, DataInformationBox, DataReferenceBox, ESDBox, EditBox, EditListBox, EventEmitterModule, FileTypeBox, FreeSpaceBox, GenericDataBox, GoogleGSHHBox, GoogleGSPMBox, GoogleGSPUBox, GoogleGSSDBox, GoogleGSSTBox, GoogleGSTDBox, HandlerBox, HintSampleEntry, ItemInfoBox, ItemInfoEntry, ItemLocationBox, ItemProtectionBox, MIN_TIME_DIFF, MP4AudioSampleEntry, MP4File, MPEG4BitRateBox, MPEG4ExtensionDescriptorsBox, MediaBox, MediaDataBox, MediaHeaderBox, MediaInformationBox, MetaBox, MetadataItemListBox, MovieBox, MovieHeaderBox, ObjectDescriptorBox, PrimaryItemBox, QUEUE_BUFFER_TIME, READ_BUFFER_TIME, SampleDescriptionBox, SampleSizeBox, SampleTableBox, SampleToChunkBox, Sequent, SoundMediaHeaderBox, SyncSampleBox, TAG_CTOO, TimeToSampleBox, TrackBox, TrackHeaderBox, UserDataBox, VideoMediaHeaderBox, VisualSampleEntry, api, formatDate, fs, getCurrentTime, h264, logger,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Bits = require('./bits');

  EventEmitterModule = require('./event_emitter');

  Sequent = require('sequent');

  fs = require('fs');

  logger = require('./logger');

  h264 = require('./h264');

  formatDate = function(date) {
    return date.toISOString();
  };

  TAG_CTOO = new Buffer([0xa9, 0x74, 0x6f, 0x6f]).toString('utf8');

  MIN_TIME_DIFF = 0.01;

  READ_BUFFER_TIME = 3.0;

  QUEUE_BUFFER_TIME = 1.5;

  DEBUG = false;

  DEBUG_OUTGOING_MP4_DATA = false;

  getCurrentTime = function() {
    var time;
    time = process.hrtime();
    return time[0] + time[1] / 1e9;
  };

  MP4File = (function() {
    function MP4File(filename) {
      if (filename != null) {
        this.open(filename);
      }
      this.isStopped = false;
    }

    MP4File.prototype.clearBuffers = function() {
      this.consumedAudioChunks = 0;
      this.consumedVideoChunks = 0;
      this.bufferedAudioTime = 0;
      this.bufferedVideoTime = 0;
      this.queuedAudioTime = 0;
      this.queuedVideoTime = 0;
      this.bufferedAudioSamples = [];
      this.queuedAudioSampleIndex = 0;
      this.bufferedVideoSamples = [];
      this.queuedVideoSampleIndex = 0;
      this.isAudioEOF = false;
      this.isVideoEOF = false;
      return this.sessionId++;
    };

    MP4File.prototype.open = function(filename) {
      var diffTime, startTime;
      this.filename = filename;
      if (DEBUG) {
        startTime = process.hrtime();
      }
      this.fileBuf = fs.readFileSync(filename);
      this.bits = new Bits(this.fileBuf);
      if (DEBUG) {
        diffTime = process.hrtime(startTime);
        logger.debug("[mp4] took " + ((diffTime[0] * 1e9 + diffTime[1]) / 1000000) + " ms to read " + filename);
      }
      this.consumedAudioSamples = 0;
      this.consumedVideoSamples = 0;
      this.clearBuffers();
      this.currentPlayTime = 0;
      this.playStartTime = null;
      return this.sessionId = 0;
    };

    MP4File.prototype.close = function() {
      logger.debug("[mp4:" + this.filename + "] close");
      if (!this.isStopped) {
        this.stop();
      }
      this.bits = null;
      this.fileBuf = null;
      this.boxes = null;
      this.moovBox = null;
      this.mdatBox = null;
      this.audioTrakBox = null;
      this.videoTrakBox = null;
    };

    MP4File.prototype.parse = function() {
      var box, child, diffTime, k, len1, ref, startTime, tkhdBox;
      if (DEBUG) {
        startTime = process.hrtime();
      }
      this.boxes = [];
      while (this.bits.has_more_data()) {
        box = Box.parse(this.bits, null);
        if (box instanceof MovieBox) {
          this.moovBox = box;
        } else if (box instanceof MediaDataBox) {
          this.mdatBox = box;
        }
        this.boxes.push(box);
      }
      if (DEBUG) {
        diffTime = process.hrtime(startTime);
        logger.debug("[mp4] took " + ((diffTime[0] * 1e9 + diffTime[1]) / 1000000) + " ms to parse " + this.filename);
      }
      ref = this.moovBox.children;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        child = ref[k];
        if (child instanceof TrackBox) {
          tkhdBox = child.find('tkhd');
          if (tkhdBox.isAudioTrack) {
            this.audioTrakBox = child;
          } else {
            this.videoTrakBox = child;
          }
        }
      }
      this.numVideoSamples = this.getNumVideoSamples();
      this.numAudioSamples = this.getNumAudioSamples();
    };

    MP4File.prototype.getTree = function() {
      var box, k, len1, ref, tree;
      if (this.boxes == null) {
        throw new Error("parse() must be called before dump");
      }
      tree = {
        root: []
      };
      ref = this.boxes;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        box = ref[k];
        tree.root.push(box.getTree());
      }
      return tree;
    };

    MP4File.prototype.dump = function() {
      var box, k, len1, ref;
      if (this.boxes == null) {
        throw new Error("parse() must be called before dump");
      }
      ref = this.boxes;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        box = ref[k];
        process.stdout.write(box.dump(0, 2));
      }
    };

    MP4File.prototype.hasVideo = function() {
      return this.videoTrakBox != null;
    };

    MP4File.prototype.hasAudio = function() {
      return this.audioTrakBox != null;
    };

    MP4File.prototype.getSPS = function() {
      var avcCBox;
      avcCBox = this.videoTrakBox.find('avcC');
      return avcCBox.sequenceParameterSets[0];
    };

    MP4File.prototype.getPPS = function() {
      var avcCBox;
      avcCBox = this.videoTrakBox.find('avcC');
      return avcCBox.pictureParameterSets[0];
    };

    MP4File.prototype.getAudioSpecificConfig = function() {
      var esdsBox;
      esdsBox = this.audioTrakBox.find('esds');
      return esdsBox.decoderConfigDescriptor.decoderSpecificInfo.specificInfo;
    };

    MP4File.prototype.stop = function() {
      return this.isStopped = true;
    };

    MP4File.prototype.isPaused = function() {
      return this.isStopped;
    };

    MP4File.prototype.pause = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        return logger.debug("[mp4:" + this.filename + "] paused at " + this.currentPlayTime + " (server mp4 head time)");
      } else {
        return logger.debug("[mp4:" + this.filename + "] already paused");
      }
    };

    MP4File.prototype.sendVideoPacketsSinceLastKeyFrame = function(endSeconds, callback) {
      var isFirstSample, isKeyFrameFound, k, l, len1, len2, nalUnit, nalUnits, rawSample, sample, samples, stblBox, sttsBox, videoSample, videoSampleNumber;
      if (this.videoTrakBox == null) {
        if (typeof callback === "function") {
          callback(null);
        }
        return;
      }
      stblBox = this.videoTrakBox.child('mdia').child('minf').child('stbl');
      sttsBox = stblBox.child('stts');
      videoSample = sttsBox.getSampleAfterSeconds(endSeconds);
      if (videoSample != null) {
        videoSampleNumber = videoSample.sampleNumber;
      } else {
        videoSampleNumber = this.numVideoSamples + 1;
      }
      samples = [];
      isFirstSample = true;
      while (true) {
        rawSample = this.getSample(videoSampleNumber, this.videoTrakBox);
        isKeyFrameFound = false;
        if (rawSample != null) {
          nalUnits = this.parseH264Sample(rawSample.data);
          for (k = 0, len1 = nalUnits.length; k < len1; k++) {
            nalUnit = nalUnits[k];
            if ((nalUnit[0] & 0x1f) === h264.NAL_UNIT_TYPE_IDR_PICTURE) {
              isKeyFrameFound = true;
              break;
            }
          }
          if (!isFirstSample) {
            samples.unshift({
              pts: rawSample.pts,
              dts: rawSample.dts,
              time: rawSample.time,
              data: nalUnits
            });
          }
        }
        if (isFirstSample) {
          isFirstSample = false;
        }
        if (isKeyFrameFound) {
          break;
        }
        videoSampleNumber--;
        if (videoSampleNumber <= 0) {
          break;
        }
      }
      for (l = 0, len2 = samples.length; l < len2; l++) {
        sample = samples[l];
        this.emit('video_data', sample.data, sample.pts, sample.dts);
      }
      return typeof callback === "function" ? callback(null) : void 0;
    };

    MP4File.prototype.resume = function() {
      return this.play();
    };

    MP4File.prototype.isAudioEOFReached = function() {
      return (this.bufferedAudioSamples.length === 0) && (this.consumedAudioSamples === this.numAudioSamples);
    };

    MP4File.prototype.isVideoEOFReached = function() {
      return (this.bufferedVideoSamples.length === 0) && (this.consumedVideoSamples === this.numVideoSamples);
    };

    MP4File.prototype.fillBuffer = function(callback) {
      var seq;
      seq = new Sequent;
      this.bufferAudio((function(_this) {
        return function() {
          return seq.done();
        };
      })(this));
      this.bufferVideo((function(_this) {
        return function() {
          return seq.done();
        };
      })(this));
      return seq.wait(2, callback);
    };

    MP4File.prototype.seek = function(seekSeconds) {
      var audioSample, audioSampleNumber, minTime, stblBox, sttsBox, videoSample, videoSampleNumber, videoSampleSeconds;
      if (seekSeconds == null) {
        seekSeconds = 0;
      }
      logger.debug("[mp4:" + this.filename + "] seek: seconds=" + seekSeconds);
      this.clearBuffers();
      if (this.videoTrakBox != null) {
        stblBox = this.videoTrakBox.child('mdia').child('minf').child('stbl');
        sttsBox = stblBox.child('stts');
        videoSample = sttsBox.getSampleAfterSeconds(seekSeconds);
        if (videoSample != null) {
          logger.debug("video sample >= " + seekSeconds + " is " + (JSON.stringify(videoSample)));
          videoSampleSeconds = videoSample.seconds;
          this.currentPlayTime = videoSampleSeconds;
          videoSampleNumber = videoSample.sampleNumber;
        } else {
          logger.debug("video sample >= " + seekSeconds + " does not exist");
          this.isVideoEOF = true;
          this.currentPlayTime = this.getDurationSeconds();
          videoSampleNumber = this.numVideoSamples + 1;
          videoSampleSeconds = this.currentPlayTime;
        }
      } else {
        videoSampleNumber = null;
        videoSampleSeconds = null;
      }
      if (this.audioTrakBox != null) {
        stblBox = this.audioTrakBox.child('mdia').child('minf').child('stbl');
        sttsBox = stblBox.child('stts');
        audioSample = sttsBox.getSampleAfterSeconds(seekSeconds);
        if (audioSample != null) {
          logger.debug("audio sample >= " + seekSeconds + " is " + (JSON.stringify(audioSample)));
          audioSampleNumber = audioSample.sampleNumber;
          if ((videoSampleSeconds != null) && (videoSampleSeconds <= audioSample.seconds)) {
            minTime = videoSampleSeconds;
          } else {
            minTime = audioSample.seconds;
          }
          if (this.currentPlayTime !== minTime) {
            this.currentPlayTime = minTime;
          }
        } else {
          logger.debug("audio sample >= " + seekSeconds + " does not exist");
          audioSampleNumber = this.numAudioSamples + 1;
          this.isAudioEOF = true;
        }
      } else {
        audioSampleNumber = null;
      }
      if (audioSampleNumber != null) {
        this.consumedAudioSamples = audioSampleNumber - 1;
      }
      if (videoSampleNumber != null) {
        this.consumedVideoSamples = videoSampleNumber - 1;
      }
      logger.debug("[mp4:" + this.filename + "] set current play time to " + this.currentPlayTime);
      return this.currentPlayTime;
    };

    MP4File.prototype.play = function() {
      logger.debug("[mp4:" + this.filename + "] start playing from " + this.currentPlayTime + " (server mp4 head time)");
      return this.fillBuffer((function(_this) {
        return function() {
          _this.isStopped = false;
          _this.playStartTime = getCurrentTime() - _this.currentPlayTime;
          if (_this.isAudioEOFReached()) {
            _this.isAudioEOF = true;
          }
          if (_this.isVideoEOFReached()) {
            _this.isVideoEOF = true;
          }
          if (_this.checkEOF()) {
            return false;
          } else {
            _this.queueBufferedSamples();
            return true;
          }
        };
      })(this));
    };

    MP4File.prototype.checkAudioBuffer = function() {
      var timeDiff;
      timeDiff = this.bufferedAudioTime - this.currentPlayTime;
      if (timeDiff < READ_BUFFER_TIME) {
        if (this.readNextAudioChunk()) {
          this.queueBufferedSamples();
        }
      } else {
        this.queueBufferedSamples();
      }
    };

    MP4File.prototype.checkVideoBuffer = function() {
      var timeDiff;
      timeDiff = this.bufferedVideoTime - this.currentPlayTime;
      if (timeDiff < READ_BUFFER_TIME) {
        if (this.readNextVideoChunk()) {
          this.queueBufferedSamples();
        }
      } else {
        this.queueBufferedSamples();
      }
    };

    MP4File.prototype.startStreaming = function() {
      return this.queueBufferedSamples();
    };

    MP4File.prototype.updateCurrentPlayTime = function() {
      return this.currentPlayTime = getCurrentTime() - this.playStartTime;
    };

    MP4File.prototype.queueBufferedAudioSamples = function() {
      var audioSample, sessionId, timeDiff;
      audioSample = this.bufferedAudioSamples[this.queuedAudioSampleIndex];
      if (audioSample == null) {
        return;
      }
      timeDiff = audioSample.time - this.currentPlayTime;
      if (timeDiff <= MIN_TIME_DIFF) {
        this.bufferedAudioSamples.shift();
        this.queuedAudioSampleIndex--;
        if (DEBUG_OUTGOING_MP4_DATA) {
          logger.info("emit audio_data pts=" + audioSample.pts);
        }
        this.emit('audio_data', audioSample.data, audioSample.pts);
        this.updateCurrentPlayTime();
        if ((this.queuedAudioSampleIndex === 0) && (this.consumedAudioSamples === this.numAudioSamples)) {
          this.isAudioEOF = true;
          this.checkEOF();
        }
      } else {
        if (!this.isStopped) {
          sessionId = this.sessionId;
          setTimeout((function(_this) {
            return function() {
              if ((!_this.isStopped) && (_this.sessionId === sessionId)) {
                _this.bufferedAudioSamples.shift();
                _this.queuedAudioSampleIndex--;
                if (DEBUG_OUTGOING_MP4_DATA) {
                  logger.info("emit timed audio_data pts=" + audioSample.pts);
                }
                _this.emit('audio_data', audioSample.data, audioSample.pts);
                _this.updateCurrentPlayTime();
                if ((_this.queuedAudioSampleIndex === 0) && (_this.consumedAudioSamples === _this.numAudioSamples)) {
                  _this.isAudioEOF = true;
                  return _this.checkEOF();
                } else {
                  return _this.checkAudioBuffer();
                }
              }
            };
          })(this), timeDiff * 1000);
        }
      }
      this.queuedAudioSampleIndex++;
      this.queuedAudioTime = audioSample.time;
      if (this.queuedAudioTime - this.currentPlayTime < QUEUE_BUFFER_TIME) {
        return this.queueBufferedSamples();
      }
    };

    MP4File.prototype.queueBufferedVideoSamples = function() {
      var k, len1, nalUnit, ref, sessionId, timeDiff, totalBytes, videoSample;
      if (this.isStopped) {
        return;
      }
      videoSample = this.bufferedVideoSamples[this.queuedVideoSampleIndex];
      if (videoSample == null) {
        return;
      }
      timeDiff = videoSample.time - this.currentPlayTime;
      if (timeDiff <= MIN_TIME_DIFF) {
        this.bufferedVideoSamples.shift();
        this.queuedVideoSampleIndex--;
        if (DEBUG_OUTGOING_MP4_DATA) {
          totalBytes = 0;
          ref = videoSample.data;
          for (k = 0, len1 = ref.length; k < len1; k++) {
            nalUnit = ref[k];
            totalBytes += nalUnit.length;
          }
          logger.info("emit video_data pts=" + videoSample.pts + " dts=" + videoSample.dts + " bytes=" + totalBytes);
        }
        this.emit('video_data', videoSample.data, videoSample.pts, videoSample.dts);
        this.updateCurrentPlayTime();
        if ((this.queuedVideoSampleIndex === 0) && (this.consumedVideoSamples === this.numVideoSamples)) {
          this.isVideoEOF = true;
          this.checkEOF();
        }
      } else {
        sessionId = this.sessionId;
        setTimeout((function(_this) {
          return function() {
            var l, len2, ref1;
            if ((!_this.isStopped) && (_this.sessionId === sessionId)) {
              _this.bufferedVideoSamples.shift();
              _this.queuedVideoSampleIndex--;
              if (DEBUG_OUTGOING_MP4_DATA) {
                totalBytes = 0;
                ref1 = videoSample.data;
                for (l = 0, len2 = ref1.length; l < len2; l++) {
                  nalUnit = ref1[l];
                  totalBytes += nalUnit.length;
                }
                logger.info("emit timed video_data pts=" + videoSample.pts + " dts=" + videoSample.dts + " bytes=" + totalBytes);
              }
              _this.emit('video_data', videoSample.data, videoSample.pts, videoSample.dts);
              _this.updateCurrentPlayTime();
              if ((_this.queuedVideoSampleIndex === 0) && (_this.consumedVideoSamples === _this.numVideoSamples)) {
                _this.isVideoEOF = true;
                return _this.checkEOF();
              } else {
                return _this.checkVideoBuffer();
              }
            }
          };
        })(this), timeDiff * 1000);
      }
      this.queuedVideoSampleIndex++;
      this.queuedVideoTime = videoSample.time;
      if (this.queuedVideoTime - this.currentPlayTime < QUEUE_BUFFER_TIME) {
        return this.queueBufferedSamples();
      }
    };

    MP4File.prototype.queueBufferedSamples = function() {
      var firstAudioTime, firstVideoTime, ref, ref1;
      if (this.isStopped) {
        return;
      }
      firstAudioTime = (ref = this.bufferedAudioSamples[this.queuedAudioSampleIndex]) != null ? ref.time : void 0;
      firstVideoTime = (ref1 = this.bufferedVideoSamples[this.queuedVideoSampleIndex]) != null ? ref1.time : void 0;
      if ((firstAudioTime != null) && (firstVideoTime != null)) {
        if (firstVideoTime <= firstAudioTime) {
          this.queueBufferedVideoSamples();
          return this.queueBufferedAudioSamples();
        } else {
          this.queueBufferedAudioSamples();
          return this.queueBufferedVideoSamples();
        }
      } else {
        this.queueBufferedAudioSamples();
        return this.queueBufferedVideoSamples();
      }
    };

    MP4File.prototype.checkEOF = function() {
      if (this.isAudioEOF && this.isVideoEOF) {
        this.stop();
        this.emit('eof');
        return true;
      }
      return false;
    };

    MP4File.prototype.bufferAudio = function(callback) {
      while (this.bufferedAudioTime < this.currentPlayTime + READ_BUFFER_TIME) {
        if (!this.readNextAudioChunk()) {
          break;
        }
      }
      return typeof callback === "function" ? callback() : void 0;
    };

    MP4File.prototype.bufferVideo = function(callback) {
      while (this.bufferedVideoTime < this.currentPlayTime + READ_BUFFER_TIME) {
        if (!this.readNextVideoChunk()) {
          break;
        }
      }
      return typeof callback === "function" ? callback() : void 0;
    };

    MP4File.prototype.getNumVideoSamples = function() {
      var sttsBox;
      if (this.videoTrakBox != null) {
        sttsBox = this.videoTrakBox.find('stts');
        return sttsBox.getTotalSamples();
      } else {
        return 0;
      }
    };

    MP4File.prototype.getNumAudioSamples = function() {
      var sttsBox;
      if (this.audioTrakBox != null) {
        sttsBox = this.audioTrakBox.find('stts');
        return sttsBox.getTotalSamples();
      } else {
        return 0;
      }
    };

    MP4File.prototype.getLastTimestamp = function() {
      var audioLastTimestamp, numAudioSamples, numVideoSamples, sttsBox, videoLastTimestamp;
      if (this.videoTrakBox != null) {
        numVideoSamples = this.getNumVideoSamples();
        sttsBox = this.videoTrakBox.find('stts');
        videoLastTimestamp = sttsBox.getDecodingTime(numVideoSamples).seconds;
      } else {
        videoLastTimestamp = 0;
      }
      if (this.audioTrakBox != null) {
        numAudioSamples = this.getNumAudioSamples();
        sttsBox = this.audioTrakBox.find('stts');
        audioLastTimestamp = sttsBox.getDecodingTime(numAudioSamples).seconds;
      } else {
        audioLastTimestamp = 0;
      }
      if (audioLastTimestamp > videoLastTimestamp) {
        return audioLastTimestamp;
      } else {
        return videoLastTimestamp;
      }
    };

    MP4File.prototype.getDurationSeconds = function() {
      var mvhdBox;
      mvhdBox = this.moovBox.child('mvhd');
      return mvhdBox.durationSeconds;
    };

    MP4File.prototype.parseH264Sample = function(buf) {
      var avcCBox, bits, length, lengthSize, nalUnits;
      avcCBox = this.videoTrakBox.find('avcC');
      lengthSize = avcCBox.lengthSizeMinusOne + 1;
      bits = new Bits(buf);
      nalUnits = [];
      while (bits.has_more_data()) {
        length = bits.read_bits(lengthSize * 8);
        nalUnits.push(bits.read_bytes(length));
      }
      if (bits.get_remaining_bits() !== 0) {
        throw new Error("number of remaining bits is not zero: " + (bits.get_remaining_bits()));
      }
      return nalUnits;
    };

    MP4File.prototype.getSample = function(sampleNumber, trakBox) {
      var chunkNumber, chunkOffset, compositionTime, compositionTimeOffset, cttsBox, dts, firstSampleNumberInChunk, i, k, len1, mdhdBox, pts, sampleOffset, sampleSize, sampleSizes, sampleTime, samples, stblBox, stcoBox, stscBox, stszBox, sttsBox;
      stblBox = trakBox.child('mdia').child('minf').child('stbl');
      sttsBox = stblBox.child('stts');
      stscBox = stblBox.child('stsc');
      chunkNumber = stscBox.findChunk(sampleNumber);
      stcoBox = stblBox.child('stco');
      chunkOffset = stcoBox.getChunkOffset(chunkNumber);
      firstSampleNumberInChunk = stscBox.getFirstSampleNumberInChunk(chunkNumber);
      stszBox = stblBox.child('stsz');
      sampleSizes = stszBox.getSampleSizes(firstSampleNumberInChunk, sampleNumber - firstSampleNumberInChunk + 1);
      cttsBox = stblBox.child('ctts');
      samples = [];
      sampleOffset = 0;
      mdhdBox = trakBox.child('mdia').child('mdhd');
      for (i = k = 0, len1 = sampleSizes.length; k < len1; i = ++k) {
        sampleSize = sampleSizes[i];
        if (firstSampleNumberInChunk + i === sampleNumber) {
          compositionTimeOffset = 0;
          if (cttsBox != null) {
            compositionTimeOffset = cttsBox.getCompositionTimeOffset(sampleNumber);
          }
          sampleTime = sttsBox.getDecodingTime(sampleNumber);
          compositionTime = sampleTime.time + compositionTimeOffset;
          if (mdhdBox.timescale !== 90000) {
            pts = Math.floor(compositionTime * 90000 / mdhdBox.timescale);
            dts = Math.floor(sampleTime.time * 90000 / mdhdBox.timescale);
          } else {
            pts = compositionTime;
            dts = sampleTime.time;
          }
          return {
            pts: pts,
            dts: dts,
            time: sampleTime.seconds,
            data: this.fileBuf.slice(chunkOffset + sampleOffset, chunkOffset + sampleOffset + sampleSize)
          };
        }
        sampleOffset += sampleSize;
      }
      return null;
    };

    MP4File.prototype.readChunk = function(chunkNumber, fromSampleNumber, trakBox) {
      var chunkOffset, compositionTime, compositionTimeOffset, cttsBox, dts, firstSampleNumberInChunk, i, k, len1, mdhdBox, numSamplesInChunk, pts, sampleOffset, sampleSize, sampleSizes, sampleTime, samples, stblBox, stcoBox, stscBox, stszBox, sttsBox;
      stblBox = trakBox.child('mdia').child('minf').child('stbl');
      sttsBox = stblBox.child('stts');
      stscBox = stblBox.child('stsc');
      numSamplesInChunk = stscBox.getNumSamplesInChunk(chunkNumber);
      stcoBox = stblBox.child('stco');
      chunkOffset = stcoBox.getChunkOffset(chunkNumber);
      firstSampleNumberInChunk = stscBox.getFirstSampleNumberInChunk(chunkNumber);
      stszBox = stblBox.child('stsz');
      sampleSizes = stszBox.getSampleSizes(firstSampleNumberInChunk, numSamplesInChunk);
      cttsBox = stblBox.child('ctts');
      samples = [];
      sampleOffset = 0;
      mdhdBox = trakBox.child('mdia').child('mdhd');
      for (i = k = 0, len1 = sampleSizes.length; k < len1; i = ++k) {
        sampleSize = sampleSizes[i];
        if (firstSampleNumberInChunk + i >= fromSampleNumber) {
          compositionTimeOffset = 0;
          if (cttsBox != null) {
            compositionTimeOffset = cttsBox.getCompositionTimeOffset(firstSampleNumberInChunk + i);
          }
          sampleTime = sttsBox.getDecodingTime(firstSampleNumberInChunk + i);
          compositionTime = sampleTime.time + compositionTimeOffset;
          if (mdhdBox.timescale !== 90000) {
            pts = Math.floor(compositionTime * 90000 / mdhdBox.timescale);
            dts = Math.floor(sampleTime.time * 90000 / mdhdBox.timescale);
          } else {
            pts = compositionTime;
            dts = sampleTime.time;
          }
          samples.push({
            pts: pts,
            dts: dts,
            time: sampleTime.seconds,
            data: this.fileBuf.slice(chunkOffset + sampleOffset, chunkOffset + sampleOffset + sampleSize)
          });
        }
        sampleOffset += sampleSize;
      }
      return samples;
    };

    MP4File.prototype.readNextVideoChunk = function() {
      var chunkNumber, k, len1, nalUnits, numSamples, sample, samples, stscBox;
      if (this.consumedVideoSamples >= this.numVideoSamples) {
        return false;
      }
      if (this.consumedVideoChunks === 0 && this.consumedVideoSamples !== 0) {
        stscBox = this.videoTrakBox.find('stsc');
        chunkNumber = stscBox.findChunk(this.consumedVideoSamples + 1);
        samples = this.readChunk(chunkNumber, this.consumedVideoSamples + 1, this.videoTrakBox);
        this.consumedVideoChunks = chunkNumber;
      } else {
        samples = this.readChunk(this.consumedVideoChunks + 1, this.consumedVideoSamples + 1, this.videoTrakBox);
        this.consumedVideoChunks++;
      }
      for (k = 0, len1 = samples.length; k < len1; k++) {
        sample = samples[k];
        nalUnits = this.parseH264Sample(sample.data);
        sample.data = nalUnits;
      }
      numSamples = samples.length;
      this.consumedVideoSamples += numSamples;
      this.bufferedVideoTime = samples[numSamples - 1].time;
      this.bufferedVideoSamples = this.bufferedVideoSamples.concat(samples);
      return true;
    };

    MP4File.prototype.parseAACSample = function(buf) {};

    MP4File.prototype.readNextAudioChunk = function() {
      var chunkNumber, samples, stscBox;
      if (this.consumedAudioSamples >= this.numAudioSamples) {
        return false;
      }
      if (this.consumedAudioChunks === 0 && this.consumedAudioSamples !== 0) {
        stscBox = this.audioTrakBox.find('stsc');
        chunkNumber = stscBox.findChunk(this.consumedAudioSamples + 1);
        samples = this.readChunk(chunkNumber, this.consumedAudioSamples + 1, this.audioTrakBox);
        this.consumedAudioChunks = chunkNumber;
      } else {
        samples = this.readChunk(this.consumedAudioChunks + 1, this.consumedAudioSamples + 1, this.audioTrakBox);
        this.consumedAudioChunks++;
      }
      this.consumedAudioSamples += samples.length;
      this.bufferedAudioTime = samples[samples.length - 1].time;
      this.bufferedAudioSamples = this.bufferedAudioSamples.concat(samples);
      return true;
    };

    return MP4File;

  })();

  EventEmitterModule.mixin(MP4File);

  Box = (function() {
    Box.mp4TimeToDate = function(time) {
      return new Date(new Date('1904-01-01 00:00:00+0000').getTime() + time * 1000);
    };

    Box.prototype.getTree = function() {
      var child, k, len1, obj, ref;
      obj = {
        type: this.typeStr
      };
      if (this.children != null) {
        obj.children = [];
        ref = this.children;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          child = ref[k];
          obj.children.push(child.getTree());
        }
      }
      return obj;
    };

    Box.prototype.dump = function(depth, detailLevel) {
      var child, detailString, i, k, l, len1, ref, ref1, str;
      if (depth == null) {
        depth = 0;
      }
      if (detailLevel == null) {
        detailLevel = 0;
      }
      str = '';
      for (i = k = 0, ref = depth; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        str += '  ';
      }
      str += "" + this.typeStr;
      if (detailLevel > 0) {
        detailString = this.getDetails(detailLevel);
        if (detailString != null) {
          str += " (" + detailString + ")";
        }
      }
      str += "\n";
      if (this.children != null) {
        ref1 = this.children;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          child = ref1[l];
          str += child.dump(depth + 1, detailLevel);
        }
      }
      return str;
    };

    Box.prototype.getDetails = function(detailLevel) {
      return null;
    };

    function Box(info) {
      var name, value;
      for (name in info) {
        value = info[name];
        this[name] = value;
      }
      if (this.data != null) {
        this.read(this.data);
      }
    }

    Box.prototype.readFullBoxHeader = function(bits) {
      this.version = bits.read_byte();
      this.flags = bits.read_bits(24);
    };

    Box.prototype.findParent = function(typeStr) {
      if (this.parent != null) {
        if (this.parent.typeStr === typeStr) {
          return this.parent;
        } else {
          return this.parent.findParent(typeStr);
        }
      } else {
        return null;
      }
    };

    Box.prototype.child = function(typeStr) {
      var child, k, len1, ref;
      if (this.typeStr === typeStr) {
        return this;
      } else {
        if (this.children != null) {
          ref = this.children;
          for (k = 0, len1 = ref.length; k < len1; k++) {
            child = ref[k];
            if (child.typeStr === typeStr) {
              return child;
            }
          }
        }
        return null;
      }
    };

    Box.prototype.find = function(typeStr) {
      var box, child, k, len1, ref;
      if (this.typeStr === typeStr) {
        return this;
      } else {
        if (this.children != null) {
          ref = this.children;
          for (k = 0, len1 = ref.length; k < len1; k++) {
            child = ref[k];
            box = child.find(typeStr);
            if (box != null) {
              return box;
            }
          }
        }
        return null;
      }
    };

    Box.prototype.read = function(buf) {};

    Box.readHeader = function(bits, destObj) {
      var headerLen;
      destObj.size = bits.read_uint32();
      destObj.type = bits.read_bytes(4);
      destObj.typeStr = destObj.type.toString('utf8');
      headerLen = 8;
      if (destObj.size === 1) {
        destObj.size = bits.read_bits(64);
        headerLen += 8;
      }
      if (destObj.typeStr === 'uuid') {
        destObj.usertype = bits.read_bytes(16);
        headerLen += 16;
      }
      if (destObj.size > 0) {
        destObj.data = bits.read_bytes(destObj.size - headerLen);
      } else {
        destObj.data = bits.remaining_buffer();
        destObj.size = headerLen + destObj.data.length;
      }
    };

    Box.readLanguageCode = function(bits) {
      return Box.readASCII(bits) + Box.readASCII(bits) + Box.readASCII(bits);
    };

    Box.readASCII = function(bits) {
      var diff;
      diff = bits.read_bits(5);
      return String.fromCharCode(0x60 + diff);
    };

    Box.parse = function(bits, parent, cls) {
      var info;
      if (parent == null) {
        parent = null;
      }
      info = {};
      info.parent = parent;
      this.readHeader(bits, info);
      switch (info.typeStr) {
        case 'ftyp':
          return new FileTypeBox(info);
        case 'moov':
          return new MovieBox(info);
        case 'mvhd':
          return new MovieHeaderBox(info);
        case 'mdat':
          return new MediaDataBox(info);
        case 'trak':
          return new TrackBox(info);
        case 'tkhd':
          return new TrackHeaderBox(info);
        case 'edts':
          return new EditBox(info);
        case 'elst':
          return new EditListBox(info);
        case 'mdia':
          return new MediaBox(info);
        case 'iods':
          return new ObjectDescriptorBox(info);
        case 'mdhd':
          return new MediaHeaderBox(info);
        case 'hdlr':
          return new HandlerBox(info);
        case 'minf':
          return new MediaInformationBox(info);
        case 'vmhd':
          return new VideoMediaHeaderBox(info);
        case 'dinf':
          return new DataInformationBox(info);
        case 'dref':
          return new DataReferenceBox(info);
        case 'url ':
          return new DataEntryUrlBox(info);
        case 'urn ':
          return new DataEntryUrnBox(info);
        case 'stbl':
          return new SampleTableBox(info);
        case 'stsd':
          return new SampleDescriptionBox(info);
        case 'stts':
          return new TimeToSampleBox(info);
        case 'stss':
          return new SyncSampleBox(info);
        case 'stsc':
          return new SampleToChunkBox(info);
        case 'stsz':
          return new SampleSizeBox(info);
        case 'stco':
          return new ChunkOffsetBox(info);
        case 'smhd':
          return new SoundMediaHeaderBox(info);
        case 'meta':
          return new MetaBox(info);
        case 'pitm':
          return new PrimaryItemBox(info);
        case 'iloc':
          return new ItemLocationBox(info);
        case 'ipro':
          return new ItemProtectionBox(info);
        case 'infe':
          return new ItemInfoEntry(info);
        case 'iinf':
          return new ItemInfoBox(info);
        case 'ilst':
          return new MetadataItemListBox(info);
        case 'gsst':
          return new GoogleGSSTBox(info);
        case 'gstd':
          return new GoogleGSTDBox(info);
        case 'gssd':
          return new GoogleGSSDBox(info);
        case 'gspu':
          return new GoogleGSPUBox(info);
        case 'gspm':
          return new GoogleGSPMBox(info);
        case 'gshh':
          return new GoogleGSHHBox(info);
        case 'udta':
          return new UserDataBox(info);
        case 'avc1':
          return new AVCSampleEntry(info);
        case 'avcC':
          return new AVCConfigurationBox(info);
        case 'btrt':
          return new MPEG4BitRateBox(info);
        case 'm4ds':
          return new MPEG4ExtensionDescriptorsBox(info);
        case 'mp4a':
          return new MP4AudioSampleEntry(info);
        case 'esds':
          return new ESDBox(info);
        case 'free':
          return new FreeSpaceBox(info);
        case 'ctts':
          return new CompositionOffsetBox(info);
        case TAG_CTOO:
          return new CTOOBox(info);
        default:
          if (cls != null) {
            return new cls(info);
          } else {
            logger.warn("[mp4] warning: skipping unknown (not implemented) box type: " + info.typeStr + " (0x" + (info.type.toString('hex')) + ")");
            return new Box(info);
          }
      }
    };

    return Box;

  })();

  Container = (function(superClass) {
    extend(Container, superClass);

    function Container() {
      return Container.__super__.constructor.apply(this, arguments);
    }

    Container.prototype.read = function(buf) {
      var bits, box;
      bits = new Bits(buf);
      this.children = [];
      while (bits.has_more_data()) {
        box = Box.parse(bits, this);
        this.children.push(box);
      }
    };

    return Container;

  })(Box);

  MovieBox = (function(superClass) {
    extend(MovieBox, superClass);

    function MovieBox() {
      return MovieBox.__super__.constructor.apply(this, arguments);
    }

    return MovieBox;

  })(Container);

  SampleTableBox = (function(superClass) {
    extend(SampleTableBox, superClass);

    function SampleTableBox() {
      return SampleTableBox.__super__.constructor.apply(this, arguments);
    }

    return SampleTableBox;

  })(Container);

  DataInformationBox = (function(superClass) {
    extend(DataInformationBox, superClass);

    function DataInformationBox() {
      return DataInformationBox.__super__.constructor.apply(this, arguments);
    }

    return DataInformationBox;

  })(Container);

  UserDataBox = (function(superClass) {
    extend(UserDataBox, superClass);

    function UserDataBox() {
      return UserDataBox.__super__.constructor.apply(this, arguments);
    }

    return UserDataBox;

  })(Container);

  MediaInformationBox = (function(superClass) {
    extend(MediaInformationBox, superClass);

    function MediaInformationBox() {
      return MediaInformationBox.__super__.constructor.apply(this, arguments);
    }

    return MediaInformationBox;

  })(Container);

  MediaBox = (function(superClass) {
    extend(MediaBox, superClass);

    function MediaBox() {
      return MediaBox.__super__.constructor.apply(this, arguments);
    }

    return MediaBox;

  })(Container);

  EditBox = (function(superClass) {
    extend(EditBox, superClass);

    function EditBox() {
      return EditBox.__super__.constructor.apply(this, arguments);
    }

    return EditBox;

  })(Container);

  TrackBox = (function(superClass) {
    extend(TrackBox, superClass);

    function TrackBox() {
      return TrackBox.__super__.constructor.apply(this, arguments);
    }

    return TrackBox;

  })(Container);

  FileTypeBox = (function(superClass) {
    extend(FileTypeBox, superClass);

    function FileTypeBox() {
      return FileTypeBox.__super__.constructor.apply(this, arguments);
    }

    FileTypeBox.prototype.read = function(buf) {
      var bits, brand, brandStr;
      bits = new Bits(buf);
      this.majorBrand = bits.read_uint32();
      this.majorBrandStr = Bits.uintToString(this.majorBrand, 4);
      this.minorVersion = bits.read_uint32();
      this.compatibleBrands = [];
      while (bits.has_more_data()) {
        brand = bits.read_bytes(4);
        brandStr = brand.toString('utf8');
        this.compatibleBrands.push({
          brand: brand,
          brandStr: brandStr
        });
      }
    };

    FileTypeBox.prototype.getDetails = function(detailLevel) {
      return "brand=" + this.majorBrandStr + " version=" + this.minorVersion;
    };

    FileTypeBox.prototype.getTree = function() {
      var obj;
      obj = FileTypeBox.__super__.getTree.apply(this, arguments);
      obj.brand = this.majorBrandStr;
      obj.version = this.minorVersion;
      return obj;
    };

    return FileTypeBox;

  })(Box);

  MovieHeaderBox = (function(superClass) {
    extend(MovieHeaderBox, superClass);

    function MovieHeaderBox() {
      return MovieHeaderBox.__super__.constructor.apply(this, arguments);
    }

    MovieHeaderBox.prototype.read = function(buf) {
      var bits, reserved, reservedInt1, reservedInt2;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      if (this.version === 1) {
        this.creationTime = bits.read_bits(64);
        this.creationDate = Box.mp4TimeToDate(this.creationTime);
        this.modificationTime = bits.read_bits(64);
        this.modificationDate = Box.mp4TimeToDate(this.modificationTime);
        this.timescale = bits.read_uint32();
        this.duration = bits.read_bits(64);
        this.durationSeconds = this.duration / this.timescale;
      } else {
        this.creationTime = bits.read_bits(32);
        this.creationDate = Box.mp4TimeToDate(this.creationTime);
        this.modificationTime = bits.read_bits(32);
        this.modificationDate = Box.mp4TimeToDate(this.modificationTime);
        this.timescale = bits.read_uint32();
        this.duration = bits.read_bits(32);
        this.durationSeconds = this.duration / this.timescale;
      }
      this.rate = bits.read_int(32);
      if (this.rate !== 0x00010000) {
        logger.warn("[mp4] warning: Irregular rate found in mvhd box: " + this.rate);
      }
      this.volume = bits.read_int(16);
      if (this.volume !== 0x0100) {
        logger.warn("[mp4] warning: Irregular volume found in mvhd box: " + this.volume);
      }
      reserved = bits.read_bits(16);
      if (reserved !== 0) {
        throw new Error("reserved bits are not all zero: " + reserved);
      }
      reservedInt1 = bits.read_int(32);
      if (reservedInt1 !== 0) {
        throw new Error("reserved int(32) (1) is not zero: " + reservedInt1);
      }
      reservedInt2 = bits.read_int(32);
      if (reservedInt2 !== 0) {
        throw new Error("reserved int(32) (2) is not zero: " + reservedInt2);
      }
      bits.skip_bytes(4 * 9);
      bits.skip_bytes(4 * 6);
      this.nextTrackID = bits.read_uint32();
      if (bits.has_more_data()) {
        throw new Error("mvhd box has more data");
      }
    };

    MovieHeaderBox.prototype.getDetails = function(detailLevel) {
      return "created=" + (formatDate(this.creationDate)) + " modified=" + (formatDate(this.modificationDate)) + " timescale=" + this.timescale + " durationSeconds=" + this.durationSeconds;
    };

    MovieHeaderBox.prototype.getTree = function() {
      var obj;
      obj = MovieHeaderBox.__super__.getTree.apply(this, arguments);
      obj.creationDate = this.creationDate;
      obj.modificationDate = this.modificationDate;
      obj.timescale = this.timescale;
      obj.duration = this.duration;
      obj.durationSeconds = this.durationSeconds;
      return obj;
    };

    return MovieHeaderBox;

  })(Box);

  ObjectDescriptorBox = (function(superClass) {
    extend(ObjectDescriptorBox, superClass);

    function ObjectDescriptorBox() {
      return ObjectDescriptorBox.__super__.constructor.apply(this, arguments);
    }

    ObjectDescriptorBox.prototype.read = function(buf) {
      var bits;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
    };

    return ObjectDescriptorBox;

  })(Box);

  TrackHeaderBox = (function(superClass) {
    extend(TrackHeaderBox, superClass);

    function TrackHeaderBox() {
      return TrackHeaderBox.__super__.constructor.apply(this, arguments);
    }

    TrackHeaderBox.prototype.read = function(buf) {
      var bits, reserved;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      if (this.version === 1) {
        this.creationTime = bits.read_bits(64);
        this.creationDate = Box.mp4TimeToDate(this.creationTime);
        this.modificationTime = bits.read_bits(64);
        this.modificationDate = Box.mp4TimeToDate(this.modificationTime);
        this.trackID = bits.read_uint32();
        reserved = bits.read_uint32();
        if (reserved !== 0) {
          throw new Error("tkhd: reserved bits are not zero: " + reserved);
        }
        this.duration = bits.read_bits(64);
      } else {
        this.creationTime = bits.read_bits(32);
        this.creationDate = Box.mp4TimeToDate(this.creationTime);
        this.modificationTime = bits.read_bits(32);
        this.modificationDate = Box.mp4TimeToDate(this.modificationTime);
        this.trackID = bits.read_uint32();
        reserved = bits.read_uint32();
        if (reserved !== 0) {
          throw new Error("tkhd: reserved bits are not zero: " + reserved);
        }
        this.duration = bits.read_bits(32);
      }
      reserved = bits.read_bits(64);
      if (reserved !== 0) {
        throw new Error("tkhd: reserved bits are not zero: " + reserved);
      }
      this.layer = bits.read_int(16);
      if (this.layer !== 0) {
        logger.warn("[mp4] warning: layer is not 0 in tkhd box: " + this.layer);
      }
      this.alternateGroup = bits.read_int(16);
      this.volume = bits.read_int(16);
      if (this.volume === 0x0100) {
        this.isAudioTrack = true;
      } else {
        this.isAudioTrack = false;
      }
      reserved = bits.read_bits(16);
      if (reserved !== 0) {
        throw new Error("tkhd: reserved bits are not zero: " + reserved);
      }
      bits.skip_bytes(4 * 9);
      this.width = bits.read_uint32() / 65536;
      this.height = bits.read_uint32() / 65536;
      if (bits.has_more_data()) {
        throw new Error("tkhd box has more data");
      }
    };

    TrackHeaderBox.prototype.getDetails = function(detailLevel) {
      var str;
      str = "created=" + (formatDate(this.creationDate)) + " modified=" + (formatDate(this.modificationDate));
      if (this.isAudioTrack) {
        str += " audio";
      } else {
        str += " video; width=" + this.width + " height=" + this.height;
      }
      return str;
    };

    TrackHeaderBox.prototype.getTree = function() {
      var obj;
      obj = TrackHeaderBox.__super__.getTree.apply(this, arguments);
      obj.creationDate = this.creationDate;
      obj.modificationDate = this.modificationDate;
      obj.isAudioTrack = this.isAudioTrack;
      obj.width = this.width;
      obj.height = this.height;
      return obj;
    };

    return TrackHeaderBox;

  })(Box);

  EditListBox = (function(superClass) {
    extend(EditListBox, superClass);

    function EditListBox() {
      return EditListBox.__super__.constructor.apply(this, arguments);
    }

    EditListBox.prototype.read = function(buf) {
      var bits, entryCount, i, k, mediaRateFraction, mediaRateInteger, mediaTime, mvhdBox, ref, segmentDuration;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      mvhdBox = this.findParent('moov').find('mvhd');
      entryCount = bits.read_uint32();
      this.entries = [];
      for (i = k = 1, ref = entryCount; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        if (this.version === 1) {
          segmentDuration = bits.read_bits(64);
          mediaTime = bits.read_int(64);
        } else {
          segmentDuration = bits.read_bits(32);
          mediaTime = bits.read_int(32);
        }
        mediaRateInteger = bits.read_int(16);
        mediaRateFraction = bits.read_int(16);
        if (mediaRateFraction !== 0) {
          logger.warn("[mp4] warning: media_rate_fraction is not 0 in elst box: " + mediaRateFraction);
        }
        this.entries.push({
          segmentDuration: segmentDuration,
          segmentDurationSeconds: segmentDuration / mvhdBox.timescale,
          mediaTime: mediaTime,
          mediaRate: mediaRateInteger + mediaRateFraction / 65536
        });
      }
      if (bits.has_more_data()) {
        throw new Error("elst box has more data");
      }
    };

    EditListBox.prototype.getEmptyDuration = function() {
      var entry, k, len1, mdhdBox, mvhdBox, ref, time;
      time = 0;
      ref = this.entries;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        if (entry.mediaTime === -1) {
          mvhdBox = this.findParent('moov').child('mvhd');
          mdhdBox = this.findParent('trak').child('mdia').child('mdhd');
          if (mdhdBox == null) {
            throw new Error("cannot access mdhd box (not parsed yet?)");
          }
          time += entry.segmentDuration * mdhdBox.timescale / mvhdBox.timescale;
        } else {
          return time + entry.mediaTime;
        }
      }
    };

    EditListBox.prototype.getDetails = function(detailLevel) {
      return this.entries.map(function(entry, index) {
        return "[" + index + "]:segmentDuration=" + entry.segmentDuration + ",segmentDurationSeconds=" + entry.segmentDurationSeconds + ",mediaTime=" + entry.mediaTime + ",mediaRate=" + entry.mediaRate;
      }).join(',');
    };

    EditListBox.prototype.getTree = function() {
      var obj;
      obj = EditListBox.__super__.getTree.apply(this, arguments);
      obj.entries = this.entries;
      return obj;
    };

    return EditListBox;

  })(Box);

  MediaHeaderBox = (function(superClass) {
    extend(MediaHeaderBox, superClass);

    function MediaHeaderBox() {
      return MediaHeaderBox.__super__.constructor.apply(this, arguments);
    }

    MediaHeaderBox.prototype.read = function(buf) {
      var bits, pad, pre_defined;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      if (this.version === 1) {
        this.creationTime = bits.read_bits(64);
        this.creationDate = Box.mp4TimeToDate(this.creationTime);
        this.modificationTime = bits.read_bits(64);
        this.modificationDate = Box.mp4TimeToDate(this.modificationTime);
        this.timescale = bits.read_uint32();
        this.duration = bits.read_bits(64);
      } else {
        this.creationTime = bits.read_bits(32);
        this.creationDate = Box.mp4TimeToDate(this.creationTime);
        this.modificationTime = bits.read_bits(32);
        this.modificationDate = Box.mp4TimeToDate(this.modificationTime);
        this.timescale = bits.read_uint32();
        this.duration = bits.read_uint32();
      }
      this.durationSeconds = this.duration / this.timescale;
      pad = bits.read_bit();
      if (pad !== 0) {
        throw new Error("mdhd: pad is not 0: " + pad);
      }
      this.language = Box.readLanguageCode(bits);
      pre_defined = bits.read_bits(16);
      if (pre_defined !== 0) {
        throw new Error("mdhd: pre_defined is not 0: " + pre_defined);
      }
    };

    MediaHeaderBox.prototype.getDetails = function(detailLevel) {
      return "created=" + (formatDate(this.creationDate)) + " modified=" + (formatDate(this.modificationDate)) + " timescale=" + this.timescale + " durationSeconds=" + this.durationSeconds + " lang=" + this.language;
    };

    MediaHeaderBox.prototype.getTree = function() {
      var obj;
      obj = MediaHeaderBox.__super__.getTree.apply(this, arguments);
      obj.creationDate = this.creationDate;
      obj.modificationDate = this.modificationDate;
      obj.timescale = this.timescale;
      obj.duration = this.duration;
      obj.durationSeconds = this.durationSeconds;
      obj.language = this.language;
      return obj;
    };

    return MediaHeaderBox;

  })(Box);

  HandlerBox = (function(superClass) {
    extend(HandlerBox, superClass);

    function HandlerBox() {
      return HandlerBox.__super__.constructor.apply(this, arguments);
    }

    HandlerBox.prototype.read = function(buf) {
      var bits, pre_defined;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      pre_defined = bits.read_bits(32);
      if (pre_defined !== 0) {
        throw new Error("hdlr: pre_defined is not 0 (got " + pre_defined + ")");
      }
      this.handlerType = bits.read_bytes(4).toString('utf8');
      bits.skip_bytes(4 * 3);
      this.name = bits.get_string();
    };

    HandlerBox.prototype.getDetails = function(detailLevel) {
      return "handlerType=" + this.handlerType + " name=" + this.name;
    };

    HandlerBox.prototype.getTree = function() {
      var obj;
      obj = HandlerBox.__super__.getTree.apply(this, arguments);
      obj.handlerType = this.handlerType;
      obj.name = this.name;
      return obj;
    };

    return HandlerBox;

  })(Box);

  VideoMediaHeaderBox = (function(superClass) {
    extend(VideoMediaHeaderBox, superClass);

    function VideoMediaHeaderBox() {
      return VideoMediaHeaderBox.__super__.constructor.apply(this, arguments);
    }

    VideoMediaHeaderBox.prototype.read = function(buf) {
      var bits;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.graphicsmode = bits.read_bits(16);
      if (this.graphicsmode !== 0) {
        logger.warn("[mp4] warning: vmhd: non-standard graphicsmode: " + this.graphicsmode);
      }
      this.opcolor = {};
      this.opcolor.red = bits.read_bits(16);
      this.opcolor.green = bits.read_bits(16);
      return this.opcolor.blue = bits.read_bits(16);
    };

    return VideoMediaHeaderBox;

  })(Box);

  DataReferenceBox = (function(superClass) {
    extend(DataReferenceBox, superClass);

    function DataReferenceBox() {
      return DataReferenceBox.__super__.constructor.apply(this, arguments);
    }

    DataReferenceBox.prototype.read = function(buf) {
      var bits, entry_count, i, k, ref;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      entry_count = bits.read_uint32();
      this.children = [];
      for (i = k = 1, ref = entry_count; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        this.children.push(Box.parse(bits, this));
      }
    };

    return DataReferenceBox;

  })(Box);

  DataEntryUrlBox = (function(superClass) {
    extend(DataEntryUrlBox, superClass);

    function DataEntryUrlBox() {
      return DataEntryUrlBox.__super__.constructor.apply(this, arguments);
    }

    DataEntryUrlBox.prototype.read = function(buf) {
      var bits;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      if (bits.has_more_data()) {
        this.location = bits.get_string();
      } else {
        this.location = null;
      }
    };

    DataEntryUrlBox.prototype.getDetails = function(detailLevel) {
      if (this.location != null) {
        return "location=" + this.location;
      } else {
        return "empty location value";
      }
    };

    DataEntryUrlBox.prototype.getTree = function() {
      var obj;
      obj = DataEntryUrlBox.__super__.getTree.apply(this, arguments);
      obj.location = this.location;
      return obj;
    };

    return DataEntryUrlBox;

  })(Box);

  DataEntryUrnBox = (function(superClass) {
    extend(DataEntryUrnBox, superClass);

    function DataEntryUrnBox() {
      return DataEntryUrnBox.__super__.constructor.apply(this, arguments);
    }

    DataEntryUrnBox.prototype.read = function(buf) {
      var bits;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      if (bits.has_more_data()) {
        this.name = bits.get_string();
      } else {
        this.name = null;
      }
      if (bits.has_more_data()) {
        this.location = bits.get_string();
      } else {
        this.location = null;
      }
    };

    return DataEntryUrnBox;

  })(Box);

  SampleDescriptionBox = (function(superClass) {
    extend(SampleDescriptionBox, superClass);

    function SampleDescriptionBox() {
      return SampleDescriptionBox.__super__.constructor.apply(this, arguments);
    }

    SampleDescriptionBox.prototype.read = function(buf) {
      var bits, entry_count, handlerRefBox, handlerType, i, k, ref;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      handlerRefBox = this.findParent('mdia').find('hdlr');
      handlerType = handlerRefBox.handlerType;
      entry_count = bits.read_uint32();
      this.children = [];
      for (i = k = 1, ref = entry_count; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        switch (handlerType) {
          case 'soun':
            this.children.push(Box.parse(bits, this, AudioSampleEntry));
            break;
          case 'vide':
            this.children.push(Box.parse(bits, this, VisualSampleEntry));
            break;
          case 'hint':
            this.children.push(Box.parse(bits, this, HintSampleEntry));
            break;
          default:
            logger.warn("[mp4] warning: ignoring a sample entry for unknown handlerType in stsd box: " + handlerType);
        }
      }
    };

    return SampleDescriptionBox;

  })(Box);

  HintSampleEntry = (function(superClass) {
    extend(HintSampleEntry, superClass);

    function HintSampleEntry() {
      return HintSampleEntry.__super__.constructor.apply(this, arguments);
    }

    HintSampleEntry.prototype.read = function(buf) {
      var bits, reserved;
      bits = new Bits(buf);
      reserved = bits.read_bits(8 * 6);
      if (reserved !== 0) {
        throw new Error("VisualSampleEntry: reserved bits are not 0: " + reserved);
      }
      this.dataReferenceIndex = bits.read_bits(16);
    };

    return HintSampleEntry;

  })(Box);

  AudioSampleEntry = (function(superClass) {
    extend(AudioSampleEntry, superClass);

    function AudioSampleEntry() {
      return AudioSampleEntry.__super__.constructor.apply(this, arguments);
    }

    AudioSampleEntry.prototype.read = function(buf) {
      var bits, mdhdBox, pre_defined, reserved;
      bits = new Bits(buf);
      reserved = bits.read_bits(8 * 6);
      if (reserved !== 0) {
        throw new Error("AudioSampleEntry: reserved bits are not 0: " + reserved);
      }
      this.dataReferenceIndex = bits.read_bits(16);
      reserved = bits.read_bytes_sum(4 * 2);
      if (reserved !== 0) {
        throw new Error("AudioSampleEntry: reserved-1 bits are not 0: " + reserved);
      }
      this.channelCount = bits.read_bits(16);
      if (this.channelCount !== 2) {
        throw new Error("AudioSampleEntry: channelCount is not 2: " + this.channelCount);
      }
      this.sampleSize = bits.read_bits(16);
      if (this.sampleSize !== 16) {
        throw new Error("AudioSampleEntry: sampleSize is not 16: " + this.sampleSize);
      }
      pre_defined = bits.read_bits(16);
      if (pre_defined !== 0) {
        throw new Error("AudioSampleEntry: pre_defined is not 0: " + pre_defined);
      }
      reserved = bits.read_bits(16);
      if (reserved !== 0) {
        throw new Error("AudioSampleEntry: reserved-2 bits are not 0: " + reserved);
      }
      mdhdBox = this.findParent('mdia').find('mdhd');
      this.sampleRate = bits.read_uint32();
      if (this.sampleRate !== mdhdBox.timescale * Math.pow(2, 16)) {
        throw new Error("AudioSampleEntry: illegal sampleRate: " + this.sampleRate + " (should be " + (mdhdBox.timescale << 16) + ")");
      }
      this.remaining_buf = bits.remaining_buffer();
    };

    return AudioSampleEntry;

  })(Box);

  VisualSampleEntry = (function(superClass) {
    extend(VisualSampleEntry, superClass);

    function VisualSampleEntry() {
      return VisualSampleEntry.__super__.constructor.apply(this, arguments);
    }

    VisualSampleEntry.prototype.read = function(buf) {
      var bits, compressorNameBytes, paddingLen, pre_defined, reserved;
      bits = new Bits(buf);
      reserved = bits.read_bits(8 * 6);
      if (reserved !== 0) {
        throw new Error("VisualSampleEntry: reserved bits are not 0: " + reserved);
      }
      this.dataReferenceIndex = bits.read_bits(16);
      pre_defined = bits.read_bits(16);
      if (pre_defined !== 0) {
        throw new Error("VisualSampleEntry: pre_defined bits are not 0: " + pre_defined);
      }
      reserved = bits.read_bits(16);
      if (reserved !== 0) {
        throw new Error("VisualSampleEntry: reserved bits are not 0: " + reserved);
      }
      pre_defined = bits.read_bytes_sum(4 * 3);
      if (pre_defined !== 0) {
        throw new Error("VisualSampleEntry: pre_defined is not 0: " + pre_defined);
      }
      this.width = bits.read_bits(16);
      this.height = bits.read_bits(16);
      this.horizontalResolution = bits.read_uint32();
      if (this.horizontalResolution !== 0x00480000) {
        throw new Error("VisualSampleEntry: horizontalResolution is not 0x00480000: " + this.horizontalResolution);
      }
      this.verticalResolution = bits.read_uint32();
      if (this.verticalResolution !== 0x00480000) {
        throw new Error("VisualSampleEntry: verticalResolution is not 0x00480000: " + this.verticalResolution);
      }
      reserved = bits.read_uint32();
      if (reserved !== 0) {
        throw new Error("VisualSampleEntry: reserved bits are not 0: " + reserved);
      }
      this.frameCount = bits.read_bits(16);
      if (this.frameCount !== 1) {
        throw new Error("VisualSampleEntry: frameCount is not 1: " + this.frameCount);
      }
      compressorNameBytes = bits.read_byte();
      if (compressorNameBytes > 0) {
        this.compressorName = bits.read_bytes(compressorNameBytes).toString('utf8');
      } else {
        this.compressorName = null;
      }
      paddingLen = 32 - 1 - compressorNameBytes;
      if (paddingLen > 0) {
        bits.skip_bytes(paddingLen);
      }
      this.depth = bits.read_bits(16);
      if (this.depth !== 0x0018) {
        throw new Error("VisualSampleEntry: depth is not 0x0018: " + this.depth);
      }
      pre_defined = bits.read_int(16);
      if (pre_defined !== -1) {
        throw new Error("VisualSampleEntry: pre_defined is not -1: " + pre_defined);
      }
      this.remaining_buf = bits.remaining_buffer();
    };

    return VisualSampleEntry;

  })(Box);

  TimeToSampleBox = (function(superClass) {
    extend(TimeToSampleBox, superClass);

    function TimeToSampleBox() {
      return TimeToSampleBox.__super__.constructor.apply(this, arguments);
    }

    TimeToSampleBox.prototype.read = function(buf) {
      var bits, i, k, ref, sampleCount, sampleDelta;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.entryCount = bits.read_uint32();
      this.entries = [];
      for (i = k = 0, ref = this.entryCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        sampleCount = bits.read_uint32();
        sampleDelta = bits.read_uint32();
        if (sampleDelta < 0) {
          throw new Error("stts: negative sampleDelta is not allowed: " + sampleDelta);
        }
        this.entries.push({
          sampleCount: sampleCount,
          sampleDelta: sampleDelta
        });
      }
    };

    TimeToSampleBox.prototype.getTotalSamples = function() {
      var entry, k, len1, ref, samples;
      samples = 0;
      ref = this.entries;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        samples += entry.sampleCount;
      }
      return samples;
    };

    TimeToSampleBox.prototype.getTotalLength = function() {
      var entry, k, len1, mdhdBox, ref, time;
      mdhdBox = this.findParent('mdia').find('mdhd');
      time = 0;
      ref = this.entries;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        time += entry.sampleDelta * entry.sampleCount;
      }
      return time / mdhdBox.timescale;
    };

    TimeToSampleBox.prototype.getSampleAfterSeconds = function(sec, isExclusive) {
      var elstBox, entry, entryDuration, k, len1, numSamples, ref, ref1, remainingTime, sampleNumber, timescale, totalSeconds, totalTime;
      if (isExclusive == null) {
        isExclusive = false;
      }
      timescale = this.findParent('mdia').find('mdhd').timescale;
      remainingTime = sec * timescale;
      sampleNumber = 1;
      elstBox = (ref = this.findParent('trak').child('edts')) != null ? ref.child('elst') : void 0;
      if (elstBox != null) {
        totalTime = elstBox.getEmptyDuration();
        remainingTime -= totalTime;
      } else {
        totalTime = 0;
      }
      ref1 = this.entries;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        entry = ref1[k];
        numSamples = Math.ceil(remainingTime / entry.sampleDelta);
        if (numSamples < 0) {
          numSamples = 0;
        }
        if (numSamples <= entry.sampleCount) {
          totalTime += numSamples * entry.sampleDelta;
          totalSeconds = totalTime / timescale;
          if (isExclusive && (totalSeconds <= sec)) {
            numSamples++;
            totalTime += entry.sampleDelta;
            totalSeconds = totalTime / timescale;
          }
          return {
            sampleNumber: sampleNumber + numSamples,
            time: totalTime,
            seconds: totalSeconds
          };
        }
        sampleNumber += entry.sampleCount;
        entryDuration = entry.sampleDelta * entry.sampleCount;
        totalTime += entryDuration;
        remainingTime -= entryDuration;
      }
      return null;
    };

    TimeToSampleBox.prototype.getSampleAtSeconds = function(sec) {
      var elstBox, entry, entryDuration, k, len1, ref, ref1, remainingTime, sampleIndexInChunk, sampleNumber, timescale, totalTime;
      timescale = this.findParent('mdia').find('mdhd').timescale;
      remainingTime = sec * timescale;
      sampleNumber = 1;
      elstBox = (ref = this.findParent('trak').child('edts')) != null ? ref.child('elst') : void 0;
      if (elstBox != null) {
        totalTime = elstBox.getEmptyDuration();
        remainingTime -= totalTime;
      } else {
        totalTime = 0;
      }
      ref1 = this.entries;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        entry = ref1[k];
        sampleIndexInChunk = Math.floor(remainingTime / entry.sampleDelta);
        if (sampleIndexInChunk < 0) {
          sampleIndexInChunk = 0;
        }
        if (sampleIndexInChunk < entry.sampleCount) {
          totalTime += sampleIndexInChunk * entry.sampleDelta;
          return {
            sampleNumber: sampleNumber + sampleIndexInChunk,
            time: totalTime,
            seconds: totalTime / timescale
          };
        }
        sampleNumber += entry.sampleCount;
        entryDuration = entry.sampleDelta * entry.sampleCount;
        totalTime += entryDuration;
        remainingTime -= entryDuration;
      }
      return null;
    };

    TimeToSampleBox.prototype.getDecodingTime = function(sampleNumber) {
      var elstBox, entry, k, len1, mdhdBox, ref, ref1, time, trakBox;
      trakBox = this.findParent('trak');
      elstBox = (ref = trakBox.child('edts')) != null ? ref.child('elst') : void 0;
      mdhdBox = trakBox.child('mdia').child('mdhd');
      sampleNumber--;
      if (elstBox != null) {
        time = elstBox.getEmptyDuration();
      } else {
        time = 0;
      }
      ref1 = this.entries;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        entry = ref1[k];
        if (sampleNumber > entry.sampleCount) {
          time += entry.sampleDelta * entry.sampleCount;
          sampleNumber -= entry.sampleCount;
        } else {
          time += entry.sampleDelta * sampleNumber;
          break;
        }
      }
      return {
        time: time,
        seconds: time / mdhdBox.timescale
      };
    };

    TimeToSampleBox.prototype.getDetails = function(detailLevel) {
      var str;
      str = "entryCount=" + this.entryCount;
      if (detailLevel >= 2) {
        str += ' ' + this.entries.map(function(entry, index) {
          return "[" + index + "]:sampleCount=" + entry.sampleCount + ",sampleDelta=" + entry.sampleDelta;
        }).join(',');
      }
      return str;
    };

    TimeToSampleBox.prototype.getTree = function() {
      var obj;
      obj = TimeToSampleBox.__super__.getTree.apply(this, arguments);
      obj.entries = this.entries;
      return obj;
    };

    return TimeToSampleBox;

  })(Box);

  SyncSampleBox = (function(superClass) {
    extend(SyncSampleBox, superClass);

    function SyncSampleBox() {
      return SyncSampleBox.__super__.constructor.apply(this, arguments);
    }

    SyncSampleBox.prototype.read = function(buf) {
      var bits, i, k, lastSampleNumber, ref, sampleNumber;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.entryCount = bits.read_uint32();
      this.sampleNumbers = [];
      lastSampleNumber = -1;
      for (i = k = 0, ref = this.entryCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        sampleNumber = bits.read_uint32();
        if (sampleNumber < lastSampleNumber) {
          throw new Error("stss: sample number must be in increasing order: " + sampleNumber + " < " + lastSampleNumber);
        }
        lastSampleNumber = sampleNumber;
        this.sampleNumbers.push(sampleNumber);
      }
    };

    SyncSampleBox.prototype.getDetails = function(detailLevel) {
      if (detailLevel >= 2) {
        return "sampleNumbers=" + (this.sampleNumbers.join(','));
      } else {
        return "entryCount=" + this.entryCount;
      }
    };

    SyncSampleBox.prototype.getTree = function() {
      var obj;
      obj = SyncSampleBox.__super__.getTree.apply(this, arguments);
      obj.sampleNumbers = this.sampleNumbers;
      return obj;
    };

    return SyncSampleBox;

  })(Box);

  SampleToChunkBox = (function(superClass) {
    extend(SampleToChunkBox, superClass);

    function SampleToChunkBox() {
      return SampleToChunkBox.__super__.constructor.apply(this, arguments);
    }

    SampleToChunkBox.prototype.read = function(buf) {
      var bits, endIndex, firstChunk, i, k, l, lastEntry, ref, ref1, sampleDescriptionIndex, sampleNumber, samplesPerChunk;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.entryCount = bits.read_uint32();
      this.entries = [];
      sampleNumber = 1;
      for (i = k = 0, ref = this.entryCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        firstChunk = bits.read_uint32();
        samplesPerChunk = bits.read_uint32();
        sampleDescriptionIndex = bits.read_uint32();
        if (i > 0) {
          lastEntry = this.entries[this.entries.length - 1];
          sampleNumber += (firstChunk - lastEntry.firstChunk) * lastEntry.samplesPerChunk;
        }
        this.entries.push({
          firstChunk: firstChunk,
          firstSample: sampleNumber,
          samplesPerChunk: samplesPerChunk,
          sampleDescriptionIndex: sampleDescriptionIndex
        });
      }
      endIndex = this.entries.length - 1;
      for (i = l = 0, ref1 = endIndex; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
        if (i === endIndex) {
          break;
        }
        this.entries[i].numChunks = this.entries[i + 1].firstChunk - this.entries[i].firstChunk;
      }
    };

    SampleToChunkBox.prototype.getNumSamplesExceptLastChunk = function() {
      var entry, k, len1, ref, samples;
      samples = 0;
      ref = this.entries;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        if (entry.numChunks != null) {
          samples += entry.samplesPerChunk * entry.numChunks;
        }
      }
      return samples;
    };

    SampleToChunkBox.prototype.getNumSamplesInChunk = function(chunk) {
      var entry, k, len1, ref, sttsBox;
      ref = this.entries;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        if (entry.numChunks == null) {
          sttsBox = this.findParent('stbl').find('stts');
          return entry.samplesPerChunk;
        }
        if (chunk < entry.firstChunk + entry.numChunks) {
          return entry.samplesPerChunk;
        }
      }
      throw new Error("Chunk not found: " + chunk);
    };

    SampleToChunkBox.prototype.findChunk = function(sampleNumber) {
      var entry, k, len1, ref;
      ref = this.entries;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        if (entry.numChunks == null) {
          return entry.firstChunk + Math.floor((sampleNumber - 1) / entry.samplesPerChunk);
        }
        if (sampleNumber <= entry.samplesPerChunk * entry.numChunks) {
          return entry.firstChunk + Math.floor((sampleNumber - 1) / entry.samplesPerChunk);
        }
        sampleNumber -= entry.samplesPerChunk * entry.numChunks;
      }
      throw new Error("Chunk for sample number " + sampleNumber + " is not found");
    };

    SampleToChunkBox.prototype.getFirstSampleNumberInChunk = function(chunkNumber) {
      var i, k, ref;
      for (i = k = ref = this.entries.length - 1; ref <= 0 ? k <= 0 : k >= 0; i = ref <= 0 ? ++k : --k) {
        if (chunkNumber >= this.entries[i].firstChunk) {
          return this.entries[i].firstSample + (chunkNumber - this.entries[i].firstChunk) * this.entries[i].samplesPerChunk;
        }
      }
      return null;
    };

    SampleToChunkBox.prototype.getDetails = function(detailLevel) {
      if (detailLevel >= 2) {
        return this.entries.map(function(entry) {
          return "firstChunk=" + entry.firstChunk + " samplesPerChunk=" + entry.samplesPerChunk + " sampleDescriptionIndex=" + entry.sampleDescriptionIndex;
        }).join(', ');
      } else {
        return "entryCount=" + this.entryCount;
      }
    };

    SampleToChunkBox.prototype.getTree = function() {
      var obj;
      obj = SampleToChunkBox.__super__.getTree.apply(this, arguments);
      obj.entries = this.entries;
      return obj;
    };

    return SampleToChunkBox;

  })(Box);

  SampleSizeBox = (function(superClass) {
    extend(SampleSizeBox, superClass);

    function SampleSizeBox() {
      return SampleSizeBox.__super__.constructor.apply(this, arguments);
    }

    SampleSizeBox.prototype.read = function(buf) {
      var bits, i, k, ref;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.sampleSize = bits.read_uint32();
      this.sampleCount = bits.read_uint32();
      if (this.sampleSize === 0) {
        this.entrySizes = [];
        for (i = k = 1, ref = this.sampleCount; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.entrySizes.push(bits.read_uint32());
        }
      }
    };

    SampleSizeBox.prototype.getSampleSizes = function(sampleNumber, len) {
      var i, k, l, ref, ref1, sizes;
      if (len == null) {
        len = 1;
      }
      sizes = [];
      if (this.sampleSize !== 0) {
        for (i = k = ref = len; ref <= 0 ? k < 0 : k > 0; i = ref <= 0 ? ++k : --k) {
          sizes.push(this.sampleSize);
        }
      } else {
        for (i = l = ref1 = len; ref1 <= 0 ? l < 0 : l > 0; i = ref1 <= 0 ? ++l : --l) {
          sizes.push(this.entrySizes[sampleNumber - 1]);
          sampleNumber++;
        }
      }
      return sizes;
    };

    SampleSizeBox.prototype.getTotalSampleSize = function(sampleNumber, len) {
      var i, k, ref, totalLength;
      if (len == null) {
        len = 1;
      }
      if (this.sampleSize !== 0) {
        return this.sampleSize * len;
      } else {
        totalLength = 0;
        for (i = k = ref = len; ref <= 0 ? k < 0 : k > 0; i = ref <= 0 ? ++k : --k) {
          if (sampleNumber > this.entrySizes.length) {
            throw new Error("Sample number is out of range: " + sampleNumber + " > " + this.entrySizes.length);
          }
          totalLength += this.entrySizes[sampleNumber - 1];
          sampleNumber++;
        }
        return totalLength;
      }
    };

    SampleSizeBox.prototype.getDetails = function(detailLevel) {
      var str;
      str = "sampleSize=" + this.sampleSize + " sampleCount=" + this.sampleCount;
      if (this.entrySizes != null) {
        if (detailLevel >= 2) {
          str += " entrySizes=" + (this.entrySizes.join(','));
        } else {
          str += " num_entrySizes=" + this.entrySizes.length;
        }
      }
      return str;
    };

    SampleSizeBox.prototype.getTree = function() {
      var obj;
      obj = SampleSizeBox.__super__.getTree.apply(this, arguments);
      obj.sampleSize = this.sampleSize;
      obj.sampleCount = this.sampleCount;
      if (this.entrySizes != null) {
        obj.entrySizes = this.entrySizes;
      }
      return obj;
    };

    return SampleSizeBox;

  })(Box);

  ChunkOffsetBox = (function(superClass) {
    extend(ChunkOffsetBox, superClass);

    function ChunkOffsetBox() {
      return ChunkOffsetBox.__super__.constructor.apply(this, arguments);
    }

    ChunkOffsetBox.prototype.read = function(buf) {
      var bits, i, k, ref;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.entryCount = bits.read_uint32();
      this.chunkOffsets = [];
      for (i = k = 1, ref = this.entryCount; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        this.chunkOffsets.push(bits.read_uint32());
      }
    };

    ChunkOffsetBox.prototype.getChunkOffset = function(chunkNumber) {
      if ((chunkNumber <= 0) || (chunkNumber > this.chunkOffsets.length)) {
        throw new Error("Chunk number out of range: " + chunkNumber + " (len=" + this.chunkOffsets.length + ")");
      }
      return this.chunkOffsets[chunkNumber - 1];
    };

    ChunkOffsetBox.prototype.getDetails = function(detailLevel) {
      if (detailLevel >= 2) {
        return "chunkOffsets=" + (this.chunkOffsets.join(','));
      } else {
        return "entryCount=" + this.entryCount;
      }
    };

    ChunkOffsetBox.prototype.getTree = function() {
      var obj;
      obj = ChunkOffsetBox.__super__.getTree.apply(this, arguments);
      obj.chunkOffsets = this.chunkOffsets;
      return obj;
    };

    return ChunkOffsetBox;

  })(Box);

  SoundMediaHeaderBox = (function(superClass) {
    extend(SoundMediaHeaderBox, superClass);

    function SoundMediaHeaderBox() {
      return SoundMediaHeaderBox.__super__.constructor.apply(this, arguments);
    }

    SoundMediaHeaderBox.prototype.read = function(buf) {
      var bits, reserved;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.balance = bits.read_bits(16);
      if (this.balance !== 0) {
        throw new Error("smhd: balance is not 0: " + this.balance);
      }
      reserved = bits.read_bits(16);
      if (reserved !== 0) {
        throw new Error("smhd: reserved bits are not 0: " + reserved);
      }
    };

    return SoundMediaHeaderBox;

  })(Box);

  MetaBox = (function(superClass) {
    extend(MetaBox, superClass);

    function MetaBox() {
      return MetaBox.__super__.constructor.apply(this, arguments);
    }

    MetaBox.prototype.read = function(buf) {
      var bits, box;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.children = [];
      while (bits.has_more_data()) {
        box = Box.parse(bits, this);
        this.children.push(box);
      }
    };

    return MetaBox;

  })(Box);

  PrimaryItemBox = (function(superClass) {
    extend(PrimaryItemBox, superClass);

    function PrimaryItemBox() {
      return PrimaryItemBox.__super__.constructor.apply(this, arguments);
    }

    PrimaryItemBox.prototype.read = function(buf) {
      var bits;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.itemID = bits.read_bits(16);
    };

    return PrimaryItemBox;

  })(Box);

  ItemLocationBox = (function(superClass) {
    extend(ItemLocationBox, superClass);

    function ItemLocationBox() {
      return ItemLocationBox.__super__.constructor.apply(this, arguments);
    }

    ItemLocationBox.prototype.read = function(buf) {
      var baseOffset, bits, dataReferenceIndex, extentCount, extentLength, extentOffset, extents, i, itemID, j, k, l, ref, ref1;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.offsetSize = bits.read_bits(4);
      this.lengthSize = bits.read_bits(4);
      this.baseOffsetSize = bits.read_bits(4);
      this.reserved = bits.read_bits(4);
      this.itemCount = bits.read_bits(16);
      this.items = [];
      for (i = k = 0, ref = this.itemCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        itemID = bits.read_bits(16);
        dataReferenceIndex = bits.read_bits(16);
        baseOffset = bits.read_bits(this.baseOffsetSize * 8);
        extentCount = bits.read_bits(16);
        extents = [];
        for (j = l = 0, ref1 = extentCount; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
          extentOffset = bits.read_bits(this.offsetSize * 8);
          extentLength = bits.read_bits(this.lengthSize * 8);
          extents.push({
            extentOffset: extentOffset,
            extentLength: extentLength
          });
        }
        this.items.push({
          itemID: itemID,
          dataReferenceIndex: dataReferenceIndex,
          baseOffset: baseOffset,
          extentCount: extentCount,
          extents: extents
        });
      }
    };

    return ItemLocationBox;

  })(Box);

  ItemProtectionBox = (function(superClass) {
    extend(ItemProtectionBox, superClass);

    function ItemProtectionBox() {
      return ItemProtectionBox.__super__.constructor.apply(this, arguments);
    }

    ItemProtectionBox.prototype.read = function(buf) {
      var bits, box, i, k, ref;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.protectionCount = bits.read_bits(16);
      this.children = [];
      for (i = k = 1, ref = this.protectionCount; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        box = Box.parse(bits, this);
        this.children.push(box);
      }
    };

    return ItemProtectionBox;

  })(Box);

  ItemInfoEntry = (function(superClass) {
    extend(ItemInfoEntry, superClass);

    function ItemInfoEntry() {
      return ItemInfoEntry.__super__.constructor.apply(this, arguments);
    }

    ItemInfoEntry.prototype.read = function(buf) {
      var bits;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.itemID = bits.read_bits(16);
      this.itemProtectionIndex = bits.read_bits(16);
      this.itemName = bits.get_string();
      this.contentType = bits.get_string();
      if (bits.has_more_data()) {
        this.contentEncoding = bits.get_string();
      }
    };

    return ItemInfoEntry;

  })(Box);

  ItemInfoBox = (function(superClass) {
    extend(ItemInfoBox, superClass);

    function ItemInfoBox() {
      return ItemInfoBox.__super__.constructor.apply(this, arguments);
    }

    ItemInfoBox.prototype.read = function(buf) {
      var bits, box, i, k, ref;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.entryCount = bits.read_bits(16);
      this.children = [];
      for (i = k = 1, ref = this.entryCount; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        box = Box.parse(bits, this);
        this.children.push(box);
      }
    };

    return ItemInfoBox;

  })(Box);

  MetadataItemListBox = (function(superClass) {
    extend(MetadataItemListBox, superClass);

    function MetadataItemListBox() {
      return MetadataItemListBox.__super__.constructor.apply(this, arguments);
    }

    return MetadataItemListBox;

  })(Container);

  GenericDataBox = (function(superClass) {
    extend(GenericDataBox, superClass);

    function GenericDataBox() {
      return GenericDataBox.__super__.constructor.apply(this, arguments);
    }

    GenericDataBox.prototype.read = function(buf) {
      var bits, nullPos, zeroBytes;
      bits = new Bits(buf);
      this.length = bits.read_uint32();
      this.name = bits.read_bytes(4).toString('utf8');
      this.entryCount = bits.read_uint32();
      zeroBytes = bits.read_bytes_sum(4);
      if (zeroBytes !== 0) {
        logger.warn("[mp4] warning: zeroBytes are not all zeros (got " + zeroBytes + ")");
      }
      this.value = bits.read_bytes(this.length - 16);
      nullPos = Bits.searchByteInBuffer(this.value, 0x00);
      if (nullPos === 0) {
        this.valueStr = null;
      } else if (nullPos !== -1) {
        this.valueStr = this.value.slice(0, nullPos).toString('utf8');
      } else {
        this.valueStr = this.value.toString('utf8');
      }
    };

    GenericDataBox.prototype.getDetails = function(detailLevel) {
      return this.name + "=" + this.valueStr;
    };

    GenericDataBox.prototype.getTree = function() {
      var obj;
      obj = GenericDataBox.__super__.getTree.apply(this, arguments);
      obj.data = this.valueStr;
      return obj;
    };

    return GenericDataBox;

  })(Box);

  GoogleGSSTBox = (function(superClass) {
    extend(GoogleGSSTBox, superClass);

    function GoogleGSSTBox() {
      return GoogleGSSTBox.__super__.constructor.apply(this, arguments);
    }

    return GoogleGSSTBox;

  })(GenericDataBox);

  GoogleGSTDBox = (function(superClass) {
    extend(GoogleGSTDBox, superClass);

    function GoogleGSTDBox() {
      return GoogleGSTDBox.__super__.constructor.apply(this, arguments);
    }

    return GoogleGSTDBox;

  })(GenericDataBox);

  GoogleGSSDBox = (function(superClass) {
    extend(GoogleGSSDBox, superClass);

    function GoogleGSSDBox() {
      return GoogleGSSDBox.__super__.constructor.apply(this, arguments);
    }

    return GoogleGSSDBox;

  })(GenericDataBox);

  GoogleGSPUBox = (function(superClass) {
    extend(GoogleGSPUBox, superClass);

    function GoogleGSPUBox() {
      return GoogleGSPUBox.__super__.constructor.apply(this, arguments);
    }

    return GoogleGSPUBox;

  })(GenericDataBox);

  GoogleGSPMBox = (function(superClass) {
    extend(GoogleGSPMBox, superClass);

    function GoogleGSPMBox() {
      return GoogleGSPMBox.__super__.constructor.apply(this, arguments);
    }

    return GoogleGSPMBox;

  })(GenericDataBox);

  GoogleGSHHBox = (function(superClass) {
    extend(GoogleGSHHBox, superClass);

    function GoogleGSHHBox() {
      return GoogleGSHHBox.__super__.constructor.apply(this, arguments);
    }

    return GoogleGSHHBox;

  })(GenericDataBox);

  MediaDataBox = (function(superClass) {
    extend(MediaDataBox, superClass);

    function MediaDataBox() {
      return MediaDataBox.__super__.constructor.apply(this, arguments);
    }

    MediaDataBox.prototype.read = function(buf) {};

    return MediaDataBox;

  })(Box);

  AVCSampleEntry = (function(superClass) {
    extend(AVCSampleEntry, superClass);

    function AVCSampleEntry() {
      return AVCSampleEntry.__super__.constructor.apply(this, arguments);
    }

    AVCSampleEntry.prototype.read = function(buf) {
      var bits;
      AVCSampleEntry.__super__.read.call(this, buf);
      bits = new Bits(this.remaining_buf);
      this.children = [];
      this.children.push(Box.parse(bits, this, AVCConfigurationBox));
      if (bits.has_more_data()) {
        this.children.push(Box.parse(bits, this, MPEG4BitRateBox));
      }
      if (bits.has_more_data()) {
        this.children.push(Box.parse(bits, this, MPEG4ExtensionDescriptorsBox));
      }
    };

    return AVCSampleEntry;

  })(VisualSampleEntry);

  MPEG4BitRateBox = (function(superClass) {
    extend(MPEG4BitRateBox, superClass);

    function MPEG4BitRateBox() {
      return MPEG4BitRateBox.__super__.constructor.apply(this, arguments);
    }

    MPEG4BitRateBox.prototype.read = function(buf) {
      var bits;
      bits = new Bits(buf);
      this.bufferSizeDB = bits.read_uint32();
      this.maxBitrate = bits.read_uint32();
      return this.avgBitrate = bits.read_uint32();
    };

    MPEG4BitRateBox.prototype.getDetails = function(detailLevel) {
      return "bufferSizeDB=" + this.bufferSizeDB + " maxBitrate=" + this.maxBitrate + " avgBitrate=" + this.avgBitrate;
    };

    MPEG4BitRateBox.prototype.getTree = function() {
      var obj;
      obj = MPEG4BitRateBox.__super__.getTree.apply(this, arguments);
      obj.bufferSizeDB = this.bufferSizeDB;
      obj.maxBitrate = this.maxBitrate;
      obj.avgBitrate = this.avgBitrate;
      return obj;
    };

    return MPEG4BitRateBox;

  })(Box);

  MPEG4ExtensionDescriptorsBox = (function() {
    function MPEG4ExtensionDescriptorsBox() {}

    MPEG4ExtensionDescriptorsBox.prototype.read = function(buf) {};

    return MPEG4ExtensionDescriptorsBox;

  })();

  AVCConfigurationBox = (function(superClass) {
    extend(AVCConfigurationBox, superClass);

    function AVCConfigurationBox() {
      return AVCConfigurationBox.__super__.constructor.apply(this, arguments);
    }

    AVCConfigurationBox.prototype.read = function(buf) {
      var bits, i, k, l, pictureParameterSetLength, ref, ref1, reserved, sequenceParameterSetLength;
      bits = new Bits(buf);
      this.configurationVersion = bits.read_byte();
      if (this.configurationVersion !== 1) {
        logger.warn("warning: mp4: avcC: unknown configurationVersion: " + this.configurationVersion);
      }
      this.AVCProfileIndication = bits.read_byte();
      this.profileCompatibility = bits.read_byte();
      this.AVCLevelIndication = bits.read_byte();
      reserved = bits.read_bits(6);
      this.lengthSizeMinusOne = bits.read_bits(2);
      reserved = bits.read_bits(3);
      this.numOfSequenceParameterSets = bits.read_bits(5);
      this.sequenceParameterSets = [];
      for (i = k = 0, ref = this.numOfSequenceParameterSets; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        sequenceParameterSetLength = bits.read_bits(16);
        this.sequenceParameterSets.push(bits.read_bytes(sequenceParameterSetLength));
      }
      this.numOfPictureParameterSets = bits.read_byte();
      this.pictureParameterSets = [];
      for (i = l = 0, ref1 = this.numOfPictureParameterSets; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
        pictureParameterSetLength = bits.read_bits(16);
        this.pictureParameterSets.push(bits.read_bytes(pictureParameterSetLength));
      }
    };

    AVCConfigurationBox.prototype.getDetails = function(detailLevel) {
      return 'sps=' + this.sequenceParameterSets.map(function(sps) {
        return "0x" + (sps.toString('hex'));
      }).join(',') + ' pps=' + this.pictureParameterSets.map(function(pps) {
        return "0x" + (pps.toString('hex'));
      }).join(',');
    };

    AVCConfigurationBox.prototype.getTree = function() {
      var obj;
      obj = AVCConfigurationBox.__super__.getTree.apply(this, arguments);
      obj.sps = this.sequenceParameterSets.map(function(sps) {
        return slice.call(sps);
      });
      obj.pps = this.pictureParameterSets.map(function(pps) {
        return slice.call(pps);
      });
      return obj;
    };

    return AVCConfigurationBox;

  })(Box);

  ESDBox = (function(superClass) {
    extend(ESDBox, superClass);

    function ESDBox() {
      return ESDBox.__super__.constructor.apply(this, arguments);
    }

    ESDBox.prototype.readDecoderConfigDescriptor = function(bits) {
      var info, reserved;
      info = {};
      info.tag = bits.read_byte();
      if (info.tag !== 0x04) {
        throw new Error("ESDBox: DecoderConfigDescrTag is not 4 (got " + info.tag + ")");
      }
      info.length = this.readDescriptorLength(bits);
      info.objectProfileIndication = bits.read_byte();
      info.streamType = bits.read_bits(6);
      info.upStream = bits.read_bit();
      reserved = bits.read_bit();
      if (reserved !== 1) {
        throw new Error("ESDBox: DecoderConfigDescriptor: reserved bit is not 1 (got " + reserved + ")");
      }
      info.bufferSizeDB = bits.read_bits(24);
      info.maxBitrate = bits.read_uint32();
      info.avgBitrate = bits.read_uint32();
      info.decoderSpecificInfo = this.readDecoderSpecificInfo(bits);
      return info;
    };

    ESDBox.prototype.readDecoderSpecificInfo = function(bits) {
      var info;
      info = {};
      info.tag = bits.read_byte();
      if (info.tag !== 0x05) {
        throw new Error("ESDBox: DecSpecificInfoTag is not 5 (got " + info.tag + ")");
      }
      info.length = this.readDescriptorLength(bits);
      info.specificInfo = bits.read_bytes(info.length);
      return info;
    };

    ESDBox.prototype.readSLConfigDescriptor = function(bits) {
      var info, reserved;
      info = {};
      info.tag = bits.read_byte();
      if (info.tag !== 0x06) {
        throw new Error("ESDBox: SLConfigDescrTag is not 6 (got " + info.tag + ")");
      }
      info.length = this.readDescriptorLength(bits);
      info.predefined = bits.read_byte();
      if (info.predefined === 0) {
        info.useAccessUnitStartFlag = bits.read_bit();
        info.useAccessUnitEndFlag = bits.read_bit();
        info.useRandomAccessPointFlag = bits.read_bit();
        info.hasRandomAccessUnitsOnlyFlag = bits.read_bit();
        info.usePaddingFlag = bits.read_bit();
        info.useTimeStampsFlag = bits.read_bit();
        info.useIdleFlag = bits.read_bit();
        info.durationFlag = bits.read_bit();
        info.timeStampResolution = bits.read_uint32();
        info.ocrResolution = bits.read_uint32();
        info.timeStampLength = bits.read_byte();
        if (info.timeStampLength > 64) {
          throw new Error("ESDBox: SLConfigDescriptor: timeStampLength must be <= 64 (got " + info.timeStampLength + ")");
        }
        info.ocrLength = bits.read_byte();
        if (info.ocrLength > 64) {
          throw new Error("ESDBox: SLConfigDescriptor: ocrLength must be <= 64 (got " + info.ocrLength + ")");
        }
        info.auLength = bits.read_byte();
        if (info.auLength > 32) {
          throw new Error("ESDBox: SLConfigDescriptor: auLength must be <= 64 (got " + info.auLength + ")");
        }
        info.instantBitrateLength = bits.read_byte();
        info.degradationPriorityLength = bits.read_bits(4);
        info.auSeqNumLength = bits.read_bits(5);
        if (info.auSeqNumLength > 16) {
          throw new Error("ESDBox: SLConfigDescriptor: auSeqNumLength must be <= 16 (got " + info.auSeqNumLength + ")");
        }
        info.packetSeqNumLength = bits.read_bits(5);
        if (info.packetSeqNumLength > 16) {
          throw new Error("ESDBox: SLConfigDescriptor: packetSeqNumLength must be <= 16 (got " + info.packetSeqNumLength + ")");
        }
        reserved = bits.read_bits(2);
        if (reserved !== 0x3) {
          throw new Error("ESDBox: SLConfigDescriptor: reserved bits value is not " + 0x3 + " (got " + reserved + ")");
        }
        if (info.durationFlag === 1) {
          info.timeScale = bits.read_uint32();
          info.accessUnitDuration = bits.read_bits(16);
          info.compositionUnitDuration = bits.read_bits(16);
        }
        if (info.useTimeStampsFlag === 0) {
          info.startDecodingTimeStamp = bits.read_bits(info.timeStampLength);
          info.startCompositionTimeStamp = bits.read_bits(info.timeStamplength);
        }
      }
      return info;
    };

    ESDBox.prototype.readDescriptorLength = function(bits) {
      var len;
      len = bits.read_byte();
      if (len >= 0x80) {
        len = ((len & 0x7f) << 21) | ((bits.read_byte() & 0x7f) << 14) | ((bits.read_byte() & 0x7f) << 7) | bits.read_byte();
      }
      return len;
    };

    ESDBox.prototype.read = function(buf) {
      var bits;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.tag = bits.read_byte();
      if (this.tag !== 0x03) {
        throw new Error("ESDBox: tag is not " + 0x03 + " (got " + this.tag + ")");
      }
      this.length = this.readDescriptorLength(bits);
      this.ES_ID = bits.read_bits(16);
      this.streamDependenceFlag = bits.read_bit();
      this.urlFlag = bits.read_bit();
      this.ocrStreamFlag = bits.read_bit();
      this.streamPriority = bits.read_bits(5);
      if (this.streamDependenceFlag === 1) {
        this.depenedsOnES_ID = bits.read_bits(16);
      }
      if (this.urlFlag === 1) {
        this.urlLength = bits.read_byte();
        this.urlString = bits.read_bytes(this.urlLength);
      }
      if (this.ocrStreamFlag === 1) {
        this.ocrES_ID = bits.read_bits(16);
      }
      this.decoderConfigDescriptor = this.readDecoderConfigDescriptor(bits);
      this.slConfigDescriptor = this.readSLConfigDescriptor(bits);
    };

    ESDBox.prototype.getDetails = function(detailLevel) {
      return "audioSpecificConfig=0x" + (this.decoderConfigDescriptor.decoderSpecificInfo.specificInfo.toString('hex')) + " maxBitrate=" + this.decoderConfigDescriptor.maxBitrate + " avgBitrate=" + this.decoderConfigDescriptor.avgBitrate;
    };

    ESDBox.prototype.getTree = function() {
      var obj;
      obj = ESDBox.__super__.getTree.apply(this, arguments);
      obj.audioSpecificConfig = slice.call(this.decoderConfigDescriptor.decoderSpecificInfo.specificInfo);
      obj.maxBitrate = this.decoderConfigDescriptor.maxBitrate;
      obj.avgBitrate = this.decoderConfigDescriptor.avgBitrate;
      return obj;
    };

    return ESDBox;

  })(Box);

  MP4AudioSampleEntry = (function(superClass) {
    extend(MP4AudioSampleEntry, superClass);

    function MP4AudioSampleEntry() {
      return MP4AudioSampleEntry.__super__.constructor.apply(this, arguments);
    }

    MP4AudioSampleEntry.prototype.read = function(buf) {
      var bits;
      MP4AudioSampleEntry.__super__.read.call(this, buf);
      bits = new Bits(this.remaining_buf);
      this.children = [Box.parse(bits, this, ESDBox)];
    };

    return MP4AudioSampleEntry;

  })(AudioSampleEntry);

  FreeSpaceBox = (function(superClass) {
    extend(FreeSpaceBox, superClass);

    function FreeSpaceBox() {
      return FreeSpaceBox.__super__.constructor.apply(this, arguments);
    }

    return FreeSpaceBox;

  })(Box);

  CompositionOffsetBox = (function(superClass) {
    extend(CompositionOffsetBox, superClass);

    function CompositionOffsetBox() {
      return CompositionOffsetBox.__super__.constructor.apply(this, arguments);
    }

    CompositionOffsetBox.prototype.read = function(buf) {
      var bits, i, k, ref, sampleCount, sampleOffset;
      bits = new Bits(buf);
      this.readFullBoxHeader(bits);
      this.entryCount = bits.read_uint32();
      this.entries = [];
      for (i = k = 0, ref = this.entryCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        sampleCount = bits.read_uint32();
        sampleOffset = bits.read_uint32();
        this.entries.push({
          sampleCount: sampleCount,
          sampleOffset: sampleOffset
        });
      }
    };

    CompositionOffsetBox.prototype.getCompositionTimeOffset = function(sampleNumber) {
      var entry, k, len1, ref;
      ref = this.entries;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        if (sampleNumber <= entry.sampleCount) {
          return entry.sampleOffset;
        }
        sampleNumber -= entry.sampleCount;
      }
      throw new Error("mp4: ctts: composition time for sample number " + sampleNumber + " not found");
    };

    return CompositionOffsetBox;

  })(Box);

  CTOOBox = (function(superClass) {
    extend(CTOOBox, superClass);

    function CTOOBox() {
      return CTOOBox.__super__.constructor.apply(this, arguments);
    }

    return CTOOBox;

  })(GenericDataBox);

  api = {
    MP4File: MP4File
  };

  module.exports = api;

}).call(this);
