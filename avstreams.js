// Generated by CoffeeScript 1.12.4
(function() {
  var AVStream, AVStreamGenerator, Bits, EventEmitterModule, MP4Stream, aac, api, createStreamId, crypto, eventListeners, fs, h264, logger, mp4, path, recordedAppToDir, streamGenerators, streams,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  crypto = require('crypto');

  fs = require('fs');

  path = require('path');

  h264 = require('./h264');

  aac = require('./aac');

  mp4 = require('./mp4');

  Bits = require('./bits');

  EventEmitterModule = require('./event_emitter');

  logger = require('./logger');

  createStreamId = function() {
    var buf, e, shasum;
    try {
      buf = crypto.randomBytes(256);
    } catch (error) {
      e = error;
      logger.error("crypto.randomBytes() failed: " + e);
      buf = crypto.pseudoRandomBytes(256);
    }
    shasum = crypto.createHash('sha512');
    shasum.update(buf);
    return shasum.digest('hex').slice(0, 8);
  };

  AVStreamGenerator = (function() {
    function AVStreamGenerator(methods) {
      if ((methods != null ? methods.generate : void 0) != null) {
        this.generate = methods.generate;
      }
      if ((methods != null ? methods.teardown : void 0) != null) {
        this.teardown = methods.teardown;
      }
      if ((methods != null ? methods.pause : void 0) != null) {
        this.pause = methods.pause;
      }
      if ((methods != null ? methods.resume : void 0) != null) {
        this.resume = methods.resume;
      }
      if ((methods != null ? methods.seek : void 0) != null) {
        this.seek = methods.seek;
      }
      if ((methods != null ? methods.sendVideoPacketsSinceLastKeyFrame : void 0) != null) {
        this.sendVideoPacketsSinceLastKeyFrame = methods.sendVideoPacketsSinceLastKeyFrame;
      }
      if ((methods != null ? methods.getCurrentPlayTime : void 0) != null) {
        this.getCurrentPlayTime = methods.getCurrentPlayTime;
      }
      if ((methods != null ? methods.isPaused : void 0) != null) {
        this.isPaused = methods.isPaused;
      }
      if (methods != null) {
        if (typeof methods.init === "function") {
          methods.init();
        }
      }
    }

    AVStreamGenerator.prototype.generate = function() {};

    AVStreamGenerator.prototype.teardown = function() {};

    return AVStreamGenerator;

  })();

  AVStream = (function() {
    function AVStream(id) {
      this.id = id;
      this.initAVParams();
    }

    AVStream.prototype.initAVParams = function() {
      this.audioClockRate = null;
      this.audioSampleRate = null;
      this.audioChannels = null;
      this.audioPeriodSize = 1024;
      this.audioObjectType = null;
      this.videoWidth = null;
      this.videoHeight = null;
      this.videoProfileLevelId = null;
      this.videoFrameRate = 30.0;
      this.videoAVCLevel = null;
      this.videoAVCProfile = null;
      this.isVideoStarted = false;
      this.isAudioStarted = false;
      this.timeAtVideoStart = null;
      this.timeAtAudioStart = null;
      this.spsString = '';
      this.ppsString = '';
      this.spsNALUnit = null;
      this.ppsNALUnit = null;
      this.spropParameterSets = '';
      return this.type = null;
    };

    AVStream.prototype.destroy = function() {
      logger.debug("[stream:" + this.id + "] destroy");
      this.spsNALUnit = null;
      this.ppsNALUnit = null;
      return this.emit('destroy');
    };

    AVStream.prototype.isRecorded = function() {
      return this.type === api.STREAM_TYPE_RECORDED;
    };

    AVStream.prototype.reset = function() {
      logger.debug("[stream:" + this.id + "] reset");
      this.initAVParams();
      return this.emit('reset');
    };

    AVStream.prototype.updateSpropParam = function(buf) {
      var nalUnitType;
      nalUnitType = buf[0] & 0x1f;
      if (nalUnitType === 7) {
        this.spsString = buf.toString('base64');
        this.videoProfileLevelId = buf.slice(1, 4).toString('hex').toUpperCase();
      } else if (nalUnitType === 8) {
        this.ppsString = buf.toString('base64');
      }
      return this.spropParameterSets = this.spsString + ',' + this.ppsString;
    };

    AVStream.prototype.resetFrameRate = function() {
      this.frameRateCalcBasePTS = null;
      this.frameRateCalcNumFrames = null;
      return this.videoFrameRate = 30.0;
    };

    AVStream.prototype.calcFrameRate = function(pts) {
      var diffMs, frameRate;
      if (this.frameRateCalcBasePTS != null) {
        diffMs = (pts - this.frameRateCalcBasePTS) / 90;
        if (pts !== this.lastPTS) {
          this.frameRateCalcNumFrames++;
          this.lastPTS = pts;
        }
        if ((this.frameRateCalcNumFrames >= 150) || (diffMs >= 5000)) {
          frameRate = this.frameRateCalcNumFrames * 1000 / diffMs;
          if (frameRate !== this.videoFrameRate) {
            logger.debug("[stream:" + this.id + "] frame rate: " + this.videoFrameRate);
            this.videoFrameRate = frameRate;
            this.emit('update_frame_rate', frameRate);
          }
          this.frameRateCalcBasePTS = pts;
          this.frameRateCalcNumFrames = 0;
          return this.lastPTS = null;
        }
      } else {
        this.frameRateCalcBasePTS = pts;
        this.frameRateCalcNumFrames = 0;
        return this.lastPTS = null;
      }
    };

    AVStream.prototype.updateConfig = function(obj) {
      var isConfigUpdated, name, value;
      isConfigUpdated = false;
      for (name in obj) {
        value = obj[name];
        if (this[name] !== value) {
          this[name] = value;
          if (value instanceof Buffer) {
            logger.debug("[stream:" + this.id + "] update " + name + ": Buffer=<0x" + (value.toString('hex')) + ">");
          } else if (typeof value === 'object') {
            logger.debug("[stream:" + this.id + "] update " + name + ":");
            logger.debug(value);
          } else {
            logger.debug("[stream:" + this.id + "] update " + name + ": " + value);
          }
          if (name === 'audioASCInfo') {
            if ((value != null ? value.sbrPresentFlag : void 0) === 1) {
              if ((value != null ? value.psPresentFlag : void 0) === 1) {
                logger.debug("[stream:" + this.id + "] audio: HE-AAC v2");
              } else {
                logger.debug("[stream:" + this.id + "] audio: HE-AAC v1");
              }
            }
          }
          isConfigUpdated = true;
        }
      }
      if (isConfigUpdated) {
        return this.emit('updateConfig');
      }
    };

    AVStream.prototype.updateSPS = function(nalUnit) {
      var e, frameSize, isConfigUpdated, sps;
      if ((this.spsNALUnit == null) || (nalUnit.compare(this.spsNALUnit) !== 0)) {
        this.spsNALUnit = nalUnit;
        this.updateSpropParam(nalUnit);
        try {
          sps = h264.readSPS(nalUnit);
        } catch (error) {
          e = error;
          logger.error("[stream:" + this.id + "] video data error: failed to read SPS");
          logger.error(e.stack);
          return;
        }
        frameSize = h264.getFrameSize(sps);
        isConfigUpdated = false;
        if (this.videoWidth !== frameSize.width) {
          this.videoWidth = frameSize.width;
          logger.debug("[stream:" + this.id + "] video width: " + this.videoWidth);
          isConfigUpdated = true;
        }
        if (this.videoHeight !== frameSize.height) {
          this.videoHeight = frameSize.height;
          logger.debug("[stream:" + this.id + "] video height: " + this.videoHeight);
          isConfigUpdated = true;
        }
        if (this.videoAVCLevel !== sps.level_idc) {
          this.videoAVCLevel = sps.level_idc;
          logger.debug("[stream:" + this.id + "] video avclevel: " + this.videoAVCLevel);
          isConfigUpdated = true;
        }
        if (this.videoAVCProfile !== sps.profile_idc) {
          this.videoAVCProfile = sps.profile_idc;
          logger.debug("[stream:" + this.id + "] video avcprofile: " + this.videoAVCProfile);
          isConfigUpdated = true;
        }
        if (isConfigUpdated) {
          logger.debug("[stream:" + this.id + "] updated SPS: 0x" + (nalUnit.toString('hex')));
          return this.emit('updateConfig');
        }
      }
    };

    AVStream.prototype.updatePPS = function(nalUnit) {
      if ((this.ppsNALUnit == null) || (nalUnit.compare(this.ppsNALUnit) !== 0)) {
        logger.debug("[stream:" + this.id + "] updated PPS: 0x" + (nalUnit.toString('hex')));
        this.ppsNALUnit = nalUnit;
        this.updateSpropParam(nalUnit);
        return this.emit('updateConfig');
      }
    };

    AVStream.prototype.toString = function() {
      var str;
      str = this.id + ": ";
      if (this.videoWidth != null) {
        str += "video: " + this.videoWidth + "x" + this.videoHeight + " profile=" + this.videoAVCProfile + " level=" + this.videoAVCLevel;
      } else {
        str += "video: (waiting for data)";
      }
      if (this.audioSampleRate != null) {
        str += "; audio: samplerate=" + this.audioSampleRate + " channels=" + this.audioChannels + " objecttype=" + this.audioObjectType;
      } else {
        str += "; audio: (waiting for data)";
      }
      return str;
    };

    return AVStream;

  })();

  EventEmitterModule.mixin(AVStream);

  MP4Stream = (function(superClass) {
    extend(MP4Stream, superClass);

    function MP4Stream() {
      return MP4Stream.__super__.constructor.apply(this, arguments);
    }

    MP4Stream.create = function(filename) {
      var ascBuf, ascInfo, bits, err, mp4File, mp4Stream, streamId;
      try {
        mp4File = new mp4.MP4File(filename);
      } catch (error) {
        err = error;
        logger.error("error opening MP4 file " + filename + ": " + err);
        return null;
      }
      streamId = api.createNewStreamId();
      mp4Stream = new MP4Stream(streamId);
      logger.debug("created stream " + streamId + " from file " + filename);
      api.emit('new', mp4Stream);
      api.add(mp4Stream);
      mp4Stream.type = api.STREAM_TYPE_RECORDED;
      mp4File.on('audio_data', function(data, pts) {
        return mp4Stream.emit('audio_data', data, pts);
      });
      mp4File.on('video_data', function(nalUnits, pts, dts) {
        return mp4Stream.emit('video_data', nalUnits, pts, dts);
      });
      mp4File.on('eof', function() {
        return mp4Stream.emit('end');
      });
      mp4File.parse();
      if (mp4File.hasVideo()) {
        mp4Stream.updateSPS(mp4File.getSPS());
        mp4Stream.updatePPS(mp4File.getPPS());
      }
      if (mp4File.hasAudio()) {
        ascBuf = mp4File.getAudioSpecificConfig();
        bits = new Bits(ascBuf);
        ascInfo = aac.readAudioSpecificConfig(bits);
        mp4Stream.updateConfig({
          audioSpecificConfig: ascBuf,
          audioASCInfo: ascInfo,
          audioSampleRate: ascInfo.samplingFrequency,
          audioClockRate: 90000,
          audioChannels: ascInfo.channelConfiguration,
          audioObjectType: ascInfo.audioObjectType
        });
      }
      mp4Stream.durationSeconds = mp4File.getDurationSeconds();
      mp4Stream.lastTagTimestamp = mp4File.getLastTimestamp();
      mp4Stream.mp4File = mp4File;
      mp4File.fillBuffer(function() {
        if (mp4File.hasAudio()) {
          mp4Stream.emit('audio_start');
          mp4Stream.isAudioStarted = true;
        }
        if (mp4File.hasVideo()) {
          mp4Stream.emit('video_start');
          return mp4Stream.isVideoStarted = true;
        }
      });
      return mp4Stream;
    };

    MP4Stream.prototype.play = function() {
      return this.mp4File.play();
    };

    MP4Stream.prototype.pause = function() {
      return this.mp4File.pause();
    };

    MP4Stream.prototype.resume = function() {
      return this.mp4File.resume();
    };

    MP4Stream.prototype.seek = function(seekSeconds, callback) {
      var actualStartTime;
      actualStartTime = this.mp4File.seek(seekSeconds);
      return callback(null, actualStartTime);
    };

    MP4Stream.prototype.sendVideoPacketsSinceLastKeyFrame = function(endSeconds, callback) {
      return this.mp4File.sendVideoPacketsSinceLastKeyFrame(endSeconds, callback);
    };

    MP4Stream.prototype.teardown = function() {
      logger.debug("[mp4stream:" + this.id + "] teardown");
      this.mp4File.close();
      return this.destroy();
    };

    MP4Stream.prototype.getCurrentPlayTime = function() {
      return this.mp4File.currentPlayTime;
    };

    MP4Stream.prototype.isPaused = function() {
      return this.mp4File.isPaused();
    };

    return MP4Stream;

  })(AVStream);

  eventListeners = {};

  streams = {};

  streamGenerators = {};

  recordedAppToDir = {};

  api = {
    STREAM_TYPE_LIVE: 'live',
    STREAM_TYPE_RECORDED: 'recorded',
    AVStream: AVStream,
    MP4Stream: MP4Stream,
    AVStreamGenerator: AVStreamGenerator,
    emit: function() {
      var data, j, len, listener, name, ref;
      name = arguments[0], data = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (eventListeners[name] != null) {
        ref = eventListeners[name];
        for (j = 0, len = ref.length; j < len; j++) {
          listener = ref[j];
          listener.apply(null, data);
        }
      }
    },
    on: function(name, listener) {
      if (eventListeners[name] != null) {
        return eventListeners[name].push(listener);
      } else {
        return eventListeners[name] = [listener];
      }
    },
    removeListener: function(name, listener) {
      var _listener, i, j, len, ref, ref1;
      if (eventListeners[name] != null) {
        ref = eventListeners[name];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          _listener = ref[i];
          if (_listener === listener) {
            [].splice.apply(eventListeners, [i, i - i + 1].concat(ref1 = [])), ref1;
          }
        }
      }
    },
    getAll: function() {
      return streams;
    },
    exists: function(streamId) {
      return streams[streamId] != null;
    },
    get: function(streamId) {
      var app, dir, e, filename, filetype, match, pathSep, stream;
      if (streams[streamId] != null) {
        return streams[streamId];
      } else if (streamGenerators[streamId] != null) {
        stream = streamGenerators[streamId].generate();
        if (stream != null) {
          stream.teardown = streamGenerators[streamId].teardown;
          stream.pause = streamGenerators[streamId].pause;
          stream.resume = function() {
            stream.resetFrameRate();
            return streamGenerators[streamId].resume.apply(this, arguments);
          };
          stream.seek = function() {
            stream.resetFrameRate();
            return streamGenerators[streamId].seek.apply(this, arguments);
          };
          stream.getCurrentPlayTime = streamGenerators[streamId].getCurrentPlayTime;
          stream.sendVideoPacketsSinceLastKeyFrame = streamGenerators[streamId].sendVideoPacketsSinceLastKeyFrame;
          stream.isPaused = streamGenerators[streamId].isPaused;
          logger.debug("created stream " + stream.id);
        }
        return stream;
      } else {
        for (app in recordedAppToDir) {
          dir = recordedAppToDir[app];
          if (streamId.slice(0, +app.length + 1 || 9e9) === app + '/') {
            filename = streamId.slice(app.length + 1);
            if ((match = /^(\w*?):(.*)$/.exec(filename)) != null) {
              filetype = match[1];
              filename = match[2];
            } else {
              filetype = 'mp4';
            }
            filename = path.normalize(filename);
            pathSep = path.sep;
            if (pathSep === '\\') {
              pathSep = '\\' + pathSep;
            }
            if ((filename === '.') || new RegExp("(^|" + pathSep + ")..(" + pathSep + "|$)").test(filename)) {
              logger.warn("rejected request to stream: " + streamId);
              break;
            }
            try {
              fs.accessSync(dir + "/" + filename, fs.R_OK);
            } catch (error) {
              e = error;
              try {
                fs.accessSync(dir + "/" + filename + "." + filetype, fs.R_OK);
                filename = filename + "." + filetype;
              } catch (error) {
                e = error;
                logger.error("error: failed to read " + dir + "/" + filename + " or " + dir + "/" + filename + "." + filetype + ": " + e);
                return null;
              }
            }
            stream = MP4Stream.create(dir + "/" + filename);
            logger.info("created stream " + stream.id + " from " + dir + "/" + filename);
            return stream;
          }
        }
        return null;
      }
    },
    attachRecordedDirToApp: function(dir, appName) {
      if (recordedAppToDir[appName] != null) {
        logger.warn("warning: avstreams.attachRecordedDirToApp: overwriting existing app: " + appName);
      }
      return recordedAppToDir[appName] = dir;
    },
    addGenerator: function(streamId, generator) {
      if (streamGenerators[streamId] != null) {
        logger.warn("warning: avstreams.addGenerator(): overwriting generator: " + streamId);
      }
      return streamGenerators[streamId] = generator;
    },
    removeGenerator: function(streamId) {
      if (streamGenerators[streamId] != null) {
        streamGenerators[streamId].teardown();
      }
      return delete streamGenerators[streamId];
    },
    createNewStreamId: function() {
      var id, retryCount;
      retryCount = 0;
      while (true) {
        id = createStreamId();
        if (!api.exists(id)) {
          return id;
        }
        retryCount++;
        if (retryCount >= 100) {
          throw new Error("avstreams.createNewStreamId: Failed to create new stream id");
        }
      }
    },
    create: function(streamId) {
      var stream;
      if (streamId == null) {
        streamId = api.createNewStreamId();
      }
      stream = new AVStream(streamId);
      logger.debug("created stream " + streamId);
      api.emit('new', stream);
      api.add(stream);
      return stream;
    },
    getOrCreate: function(streamId) {
      var stream;
      stream = streams[streamId];
      if (stream == null) {
        stream = api.create(streamId);
      }
      return stream;
    },
    add: function(stream) {
      if (streams[stream.id] != null) {
        logger.warn("warning: overwriting stream: " + stream.id);
      }
      streams[stream.id] = stream;
      api.emit('add_stream', stream);
      stream._onAnyListener = (function(stream) {
        return function() {
          var data, eventName;
          eventName = arguments[0], data = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          api.emit.apply(api, [eventName, stream].concat(slice.call(data)));
          if (eventName === 'destroy') {
            return api.remove(stream.id);
          }
        };
      })(stream);
      return stream.onAny(stream._onAnyListener);
    },
    remove: function(streamId) {
      var stream;
      if (typeof streamId === 'object') {
        stream = streamId;
        streamId = stream != null ? stream.id : void 0;
      } else {
        stream = streams[streamId];
      }
      if (stream != null) {
        stream.offAny(stream._onAnyListener);
        api.emit('remove_stream', stream);
      }
      return delete streams[streamId];
    },
    clear: function() {
      streams = {};
      return api.emit('clear_streams');
    },
    dump: function() {
      var results, stream, streamId;
      logger.raw("[streams: " + (Object.keys(streams).length) + "]");
      results = [];
      for (streamId in streams) {
        stream = streams[streamId];
        results.push(logger.raw(" " + stream.toString()));
      }
      return results;
    }
  };

  module.exports = api;

}).call(this);
