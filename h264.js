// Generated by CoffeeScript 1.12.4
(function() {
  var ASPECT_RATIO_IDC_EXTENDED_SAR, Bits, RANGE_TAB_LPS, SLICE_TYPES, SUB_WIDTHS, api, dtsPackets, eventListeners, fs, lastDTS, lastPTS, logger, pps, sps, videoBuf,
    slice = [].slice;

  fs = require('fs');

  Bits = require('./bits');

  logger = require('./logger');

  videoBuf = null;

  pps = {};

  sps = {};

  ASPECT_RATIO_IDC_EXTENDED_SAR = 255;

  SUB_WIDTHS = {
    '1,0': [2, 2],
    '2,0': [2, 1],
    '3,0': [1, 1]
  };

  RANGE_TAB_LPS = [[128, 176, 208, 240], [128, 167, 197, 227], [128, 158, 187, 216], [123, 150, 178, 205], [116, 142, 169, 195], [111, 135, 160, 185], [105, 128, 152, 175], [100, 122, 144, 166], [95, 116, 137, 158], [90, 110, 130, 150], [85, 104, 123, 142], [81, 99, 117, 135], [77, 94, 111, 128], [73, 89, 105, 122], [69, 85, 100, 116], [66, 80, 95, 110], [62, 76, 90, 104], [59, 72, 86, 99], [56, 69, 81, 94], [53, 65, 77, 89], [51, 62, 73, 85], [48, 59, 69, 80], [46, 56, 66, 76], [43, 53, 63, 72], [41, 50, 59, 69], [39, 48, 56, 65], [37, 45, 54, 62], [35, 43, 51, 59], [33, 41, 48, 56], [32, 39, 46, 53], [30, 37, 43, 50], [29, 35, 41, 48], [27, 33, 39, 45], [26, 31, 37, 43], [24, 30, 35, 41], [23, 28, 33, 39], [22, 27, 32, 37], [21, 26, 30, 35], [20, 24, 29, 33], [19, 23, 27, 31], [18, 22, 26, 30], [17, 21, 25, 28], [16, 20, 23, 27], [15, 19, 22, 25], [14, 18, 21, 24], [14, 17, 20, 23], [13, 16, 19, 22], [12, 15, 18, 21], [12, 14, 17, 20], [11, 14, 16, 19], [11, 13, 15, 18], [10, 12, 15, 17], [10, 12, 14, 16], [9, 11, 13, 15], [9, 11, 12, 14], [8, 10, 12, 14], [8, 9, 11, 13], [7, 9, 11, 12], [7, 9, 10, 12], [7, 8, 10, 11], [6, 8, 9, 11], [6, 7, 9, 10], [6, 7, 8, 9], [2, 2, 2, 2]];

  SLICE_TYPES = {
    0: 'P',
    1: 'B',
    2: 'I',
    3: 'SP',
    4: 'SI',
    5: 'P',
    6: 'B',
    7: 'I',
    8: 'SP',
    9: 'SI'
  };

  eventListeners = {};

  lastPTS = null;

  lastDTS = null;

  dtsPackets = [];

  api = {
    NAL_UNIT_TYPE_NON_IDR_PICTURE: 1,
    NAL_UNIT_TYPE_IDR_PICTURE: 5,
    NAL_UNIT_TYPE_SEI: 6,
    NAL_UNIT_TYPE_SPS: 7,
    NAL_UNIT_TYPE_PPS: 8,
    NAL_UNIT_TYPE_ACCESS_UNIT_DELIMITER: 9,
    open: function(file) {
      return videoBuf = fs.readFileSync(file);
    },
    close: function() {
      return videoBuf = null;
    },
    emit: function() {
      var data, k, len, listener, name, ref;
      name = arguments[0], data = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (eventListeners[name] != null) {
        ref = eventListeners[name];
        for (k = 0, len = ref.length; k < len; k++) {
          listener = ref[k];
          listener.apply(null, data);
        }
      }
    },
    on: function(name, listener) {
      if (eventListeners[name] != null) {
        return eventListeners[name].push(listener);
      } else {
        return eventListeners[name] = [listener];
      }
    },
    end: function() {
      return this.emit('end');
    },
    splitIntoNALUnits: function(buffer) {
      var nalUnit, nalUnits, startCodePos;
      nalUnits = [];
      while (true) {
        startCodePos = Bits.searchBytesInArray(buffer, [0x00, 0x00, 0x01], 0);
        if (startCodePos !== -1) {
          nalUnit = buffer.slice(0, startCodePos);
          buffer = buffer.slice(startCodePos + 3);
        } else {
          nalUnit = buffer;
        }
        while (nalUnit[nalUnit.length - 1] === 0x00) {
          nalUnit = nalUnit.slice(0, nalUnit.length - 1);
        }
        if (nalUnit.length > 0) {
          nalUnits.push(nalUnit);
        }
        if (startCodePos === -1) {
          break;
        }
      }
      return nalUnits;
    },
    feedPESPacket: function(pesPacket) {
      var dts, nalUnit, nalUnitType, nalUnits, pts, results, startCodePos;
      if (videoBuf != null) {
        videoBuf = Buffer.concat([videoBuf, pesPacket.pes.data]);
      } else {
        videoBuf = pesPacket.pes.data;
      }
      pts = pesPacket.pes.PTS;
      dts = pesPacket.pes.DTS;
      nalUnits = [];
      results = [];
      while (true) {
        startCodePos = Bits.searchBytesInArray(videoBuf, [0x00, 0x00, 0x01], 0);
        if (startCodePos === -1) {
          break;
        }
        nalUnit = videoBuf.slice(0, startCodePos);
        videoBuf = videoBuf.slice(startCodePos + 3);
        while (nalUnit[nalUnit.length - 1] === 0x00) {
          nalUnit = nalUnit.slice(0, nalUnit.length - 1);
        }
        if (nalUnit.length > 0) {
          nalUnitType = nalUnit[0] & 0x1f;
          if (nalUnitType === api.NAL_UNIT_TYPE_SPS) {
            api.readSPS(nalUnit);
          } else if (nalUnitType === api.NAL_UNIT_TYPE_PPS) {
            api.readPPS(nalUnit);
          } else if (nalUnitType === api.NAL_UNIT_TYPE_SEI) {
            api.readSEI(nalUnit);
          }
          nalUnits.push(nalUnit);
          if ((dtsPackets.length > 0) && (pts !== lastPTS)) {
            dtsPackets.push(nalUnit);
            this.emit('dts_nal_units', lastPTS, lastDTS, dtsPackets);
            dtsPackets = [];
          } else {
            dtsPackets.push(nalUnit);
          }
          lastPTS = pts;
          results.push(lastDTS = dts);
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    feed: function(data) {
      var nalUnit, nalUnitType, nalUnits, startCodePos;
      if (videoBuf != null) {
        videoBuf = Buffer.concat([videoBuf, data]);
      } else {
        videoBuf = data;
      }
      nalUnits = [];
      while (true) {
        startCodePos = Bits.searchBytesInArray(videoBuf, [0x00, 0x00, 0x01], 0);
        if (startCodePos === -1) {
          break;
        }
        nalUnit = videoBuf.slice(0, startCodePos);
        videoBuf = videoBuf.slice(startCodePos + 3);
        while (nalUnit[nalUnit.length - 1] === 0x00) {
          nalUnit = nalUnit.slice(0, nalUnit.length - 1);
        }
        if (nalUnit.length > 0) {
          nalUnitType = nalUnit[0] & 0x1f;
          if (nalUnitType === api.NAL_UNIT_TYPE_SPS) {
            api.readSPS(nalUnit);
          } else if (nalUnitType === api.NAL_UNIT_TYPE_PPS) {
            api.readPPS(nalUnit);
          } else if (nalUnitType === api.NAL_UNIT_TYPE_SEI) {
            api.readSEI(nalUnit);
          }
          nalUnits.push(nalUnit);
          this.emit('nal_unit', nalUnit);
        }
      }
      if (nalUnits.length > 0) {
        return this.emit('nal_units', nalUnits);
      }
    },
    hasMoreData: function() {
      return (videoBuf != null) && (videoBuf.length > 0);
    },
    getNALUnitType: function(nalUnit) {
      return nalUnit[0] & 0x1f;
    },
    getSliceTypeString: function(sliceType) {
      return SLICE_TYPES[sliceType];
    },
    isPictureNALUnitType: function(nalUnitType) {
      return nalUnitType === api.NAL_UNIT_TYPE_NON_IDR_PICTURE || nalUnitType === api.NAL_UNIT_TYPE_IDR_PICTURE;
    },
    getSPS: function() {
      return sps;
    },
    getPPS: function() {
      return pps;
    },
    readScalingList: function(bits, scalingList, sizeOfScalingList, useDefaultScalingMatrixFlag) {
      var delta_scale, j, k, lastScale, nextScale, ref;
      lastScale = 8;
      nextScale = 8;
      for (j = k = 0, ref = sizeOfScalingList; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
        if (nextScale !== 0) {
          delta_scale = bits.read_se();
          nextScale = (lastScale + delta_scale + 256) % 256;
          useDefaultScalingMatrixFlag = (j === 0) && (nextScale === 0);
        }
        scalingList[j] = nextScale === 0 ? lastScale : nextScale;
        lastScale = scalingList[j];
      }
    },
    read_user_data_unregistered: function(bits, payloadSize) {
      var i, k, ref, results, user_data_payload_byte, uuid_iso_iec_11578;
      uuid_iso_iec_11578 = bits.read_bits(128);
      results = [];
      for (i = k = 16, ref = payloadSize; 16 <= ref ? k < ref : k > ref; i = 16 <= ref ? ++k : --k) {
        results.push(user_data_payload_byte = bits.read_byte());
      }
      return results;
    },
    read_reserved_sei_message: function(bits, payloadSize) {
      var i, k, ref, reserved_sei_message_payload_byte, results;
      results = [];
      for (i = k = 0, ref = payloadSize; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        results.push(reserved_sei_message_payload_byte = bits.read_byte());
      }
      return results;
    },
    read_sei_payload: function(bits, payloadType, payloadSize) {
      bits.read_bytes(payloadSize);
      return bits.read_until_byte_aligned();
    },
    read_sei_message: function(bits) {
      var byte, last_payload_size_byte, last_payload_type_byte, payloadSize, payloadType;
      payloadType = 0;
      while ((byte = bits.read_byte()) === 0xff) {
        payloadType += 255;
      }
      last_payload_type_byte = byte;
      payloadType += last_payload_type_byte;
      payloadSize = 0;
      while ((byte = bits.read_byte()) === 0xff) {
        payloadSize += 255;
      }
      last_payload_size_byte = byte;
      payloadSize += last_payload_size_byte;
      return api.read_sei_payload(bits, payloadType, payloadSize);
    },
    readSEI: function(nalUnit) {
      var bits;
      nalUnit = api.removeEmulationPreventionByte(nalUnit);
      bits = new Bits(nalUnit);
      api.read_nal_header(bits);
      while (true) {
        api.read_sei_message(bits);
        if (!api.more_rbsp_data(bits)) {
          break;
        }
      }
    },
    readPPS: function(nalUnit) {
      var bits, bottom_right, chroma_qp_index_offset, constrained_intra_pred_flag, i, iGroup, k, l, m, n, numBits, pic_init_qs_minus26, pic_parameter_set_id, pic_scaling_list_present_flag, pic_scaling_matrix_present_flag, pic_size_in_map_units_minus1, ref, ref1, ref2, ref3, run_length_minus1, scalingList4x4, scalingList8x8, second_chroma_qp_index_offset, seq_parameter_set_id, slice_group_change_direction_flag, slice_group_id, slice_group_map_type, top_left, transform_8x8_mode_flag, useDefaultScalingMatrix4x4Flag, useDefaultScalingMatrix8x8Flag;
      nalUnit = api.removeEmulationPreventionByte(nalUnit);
      bits = new Bits(nalUnit);
      api.read_nal_header(bits);
      pic_parameter_set_id = bits.read_ue();
      seq_parameter_set_id = bits.read_ue();
      pps.entropy_coding_mode_flag = bits.read_bit();
      pps.bottom_field_pic_order_in_frame_present_flag = bits.read_bit();
      pps.num_slice_groups_minus1 = bits.read_ue();
      if (pps.num_slice_groups_minus1 > 0) {
        slice_group_map_type = bits.read_ue();
        if (slice_group_map_type === 0) {
          for (iGroup = k = 0, ref = pps.num_slice_groups_minus1; 0 <= ref ? k <= ref : k >= ref; iGroup = 0 <= ref ? ++k : --k) {
            run_length_minus1 = bits.read_ue();
          }
        } else if (slice_group_map_type === 2) {
          for (iGroup = l = 0, ref1 = pps.num_slice_groups_minus1; 0 <= ref1 ? l < ref1 : l > ref1; iGroup = 0 <= ref1 ? ++l : --l) {
            top_left = bits.read_ue();
            bottom_right = bits.read_ue();
          }
        } else if (slice_group_map_type === 3 || slice_group_map_type === 4 || slice_group_map_type === 5) {
          slice_group_change_direction_flag = bits.read_bit();
          pps.slice_group_change_rate_minus1 = bits.read_ue();
        } else if (slice_group_map_type === 6) {
          pic_size_in_map_units_minus1 = bits.read_ue();
          for (i = m = 0, ref2 = pic_size_in_map_units_minus1; 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {
            numBits = Math.ceil(Math.log(pps.num_slice_groups_minus1 + 1) / Math.LN2);
            slice_group_id = bits.read_bits(numBits);
          }
        }
      }
      pps.num_ref_idx_l0_default_active_minus1 = bits.read_ue();
      pps.num_ref_idx_l1_default_active_minus1 = bits.read_ue();
      pps.weighted_pred_flag = bits.read_bit();
      pps.weighted_bipred_idc = bits.read_bits(2);
      pps.pic_init_qp_minus26 = bits.read_se();
      pic_init_qs_minus26 = bits.read_se();
      chroma_qp_index_offset = bits.read_se();
      pps.deblocking_filter_control_present_flag = bits.read_bit();
      constrained_intra_pred_flag = bits.read_bit();
      pps.redundant_pic_cnt_present_flag = bits.read_bit();
      if (api.more_rbsp_data(bits)) {
        transform_8x8_mode_flag = bits.read_bit();
        pic_scaling_matrix_present_flag = bits.read_bit();
        if (pic_scaling_matrix_present_flag === 1) {
          for (i = n = 0, ref3 = 6 + (sps.chroma_format_idc !== 3 ? 2 : 6) * transform_8x8_mode_flag; 0 <= ref3 ? n < ref3 : n > ref3; i = 0 <= ref3 ? ++n : --n) {
            pic_scaling_list_present_flag = bits.read_bit();
            if (pic_scaling_list_present_flag) {
              if (i < 6) {
                scalingList4x4 = [];
                useDefaultScalingMatrix4x4Flag = [];
                api.readScalingList(bits, scalingList4x4, 16, useDefaultScalingMatrix4x4Flag);
              } else {
                scalingList8x8 = [];
                useDefaultScalingMatrix8x8Flag = [];
                api.readScalingList(bits, scalingList8x8, 64, useDefaultScalingMatrix8x8Flag);
              }
            }
          }
        }
        second_chroma_qp_index_offset = bits.read_se();
      }
    },
    getFrameSize: function(sps) {
      var cropUnitX, cropUnitY, height, width;
      if (sps.chromaArrayType === 0) {
        cropUnitX = 1;
        cropUnitY = 2 - sps.frame_mbs_only_flag;
      } else {
        cropUnitX = sps.subWidthC;
        cropUnitY = sps.subHeightC * (2 - sps.frame_mbs_only_flag);
      }
      width = sps.picWidthInSamples - (cropUnitX * sps.frame_crop_right_offset + 1) - cropUnitX * sps.frame_crop_left_offset + 1;
      height = (16 * sps.frameHeightInMbs) - (cropUnitY * sps.frame_crop_bottom_offset + 1) - cropUnitY * sps.frame_crop_top_offset + 1;
      return {
        width: width,
        height: height
      };
    },
    getSubWidths: function(sps) {
      return SUB_WIDTHS[sps.chroma_format_idc + ',' + sps.separate_colour_plane_flag];
    },
    readSPS: function(nalUnit) {
      var bit_depth_chroma_minus8, bit_depth_luma_minus8, bits, delta_pic_order_always_zero_flag, direct_8x8_inference_flag, frame_cropping_flag, gaps_in_frame_num_value_allowed_flag, i, k, l, num_ref_frames_in_pic_order_cnt_cycle, offset_for_non_ref_pic, offset_for_ref_frame, offset_for_top_to_bottom_field, qpprime_y_zero_transform_bypass_flag, rbsp_stop_one_bit, ref, ref1, ref2, reserved_zero_2bits, scalingList4x4, scalingList8x8, seq_parameter_set_id, seq_scaling_list_present_flag, seq_scaling_matrix_present_flag, subWidths, useDefaultScalingMatrix4x4Flag, useDefaultScalingMatrix8x8Flag, vui_parameters_present_flag, zero_bits_sum;
      sps = {};
      nalUnit = api.removeEmulationPreventionByte(nalUnit);
      bits = new Bits(nalUnit);
      api.read_nal_header(bits);
      sps.profile_idc = bits.read_byte();
      sps.constraint_set0_flag = bits.read_bit();
      sps.constraint_set1_flag = bits.read_bit();
      sps.constraint_set2_flag = bits.read_bit();
      sps.constraint_set3_flag = bits.read_bit();
      sps.constraint_set4_flag = bits.read_bit();
      sps.constraint_set5_flag = bits.read_bit();
      reserved_zero_2bits = bits.read_bits(2);
      if (reserved_zero_2bits !== 0) {
        throw new Error("video error: reserved_zero_2bits must be 00: " + reserved_zero_2bits);
      }
      sps.level_idc = bits.read_byte();
      seq_parameter_set_id = bits.read_ue();
      if ((ref = sps.profile_idc) === 100 || ref === 110 || ref === 122 || ref === 244 || ref === 44 || ref === 83 || ref === 86 || ref === 118 || ref === 128) {
        sps.chroma_format_idc = bits.read_ue();
        sps.chromaArrayType = sps.chroma_format_idc;
        if (sps.chroma_format_idc === 3) {
          sps.separate_colour_plane_flag = bits.read_bit();
          if (sps.separate_colour_plane_flag === 1) {
            sps.chromaArrayType = 0;
          }
        } else {
          sps.separate_colour_plane_flag = 0;
        }
        bit_depth_luma_minus8 = bits.read_ue();
        bit_depth_chroma_minus8 = bits.read_ue();
        qpprime_y_zero_transform_bypass_flag = bits.read_bit();
        seq_scaling_matrix_present_flag = bits.read_bit();
        if (seq_scaling_matrix_present_flag) {
          for (i = k = 0, ref1 = (sps.chroma_format_idc !== 3 ? 8 : 12); 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
            seq_scaling_list_present_flag = bits.read_bit();
            if (seq_scaling_list_present_flag) {
              if (i < 6) {
                scalingList4x4 = [];
                useDefaultScalingMatrix4x4Flag = [];
                api.readScalingList(bits, scalingList4x4, 16, useDefaultScalingMatrix4x4Flag);
              } else {
                scalingList8x8 = [];
                useDefaultScalingMatrix8x8Flag = [];
                api.readScalingList(bits, scalingList8x8, 64, useDefaultScalingMatrix8x8Flag);
              }
            }
          }
        }
      } else {
        sps.chromaArrayType = sps.chroma_format_idc = 1;
        sps.separate_colour_plane_flag = 0;
      }
      subWidths = api.getSubWidths(sps);
      if (subWidths != null) {
        sps.subWidthC = subWidths[0];
        sps.subHeightC = subWidths[1];
      }
      sps.log2_max_frame_num_minus4 = bits.read_ue();
      sps.pic_order_cnt_type = bits.read_ue();
      if (sps.pic_order_cnt_type === 0) {
        sps.log2_max_pic_order_cnt_lsb_minus4 = bits.read_ue();
      } else if (sps.pic_order_cnt_type === 1) {
        delta_pic_order_always_zero_flag = bits.read_bit();
        offset_for_non_ref_pic = bits.read_se();
        offset_for_top_to_bottom_field = bits.read_se();
        num_ref_frames_in_pic_order_cnt_cycle = bits.read_ue();
        for (i = l = 0, ref2 = num_ref_frames_in_pic_order_cnt_cycle; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
          offset_for_ref_frame = bits.read_se();
        }
      }
      sps.max_num_ref_frames = bits.read_ue();
      gaps_in_frame_num_value_allowed_flag = bits.read_bit();
      sps.pic_width_in_mbs_minus1 = bits.read_ue();
      sps.pic_height_in_map_units_minus1 = bits.read_ue();
      sps.picWidthInMbs = sps.pic_width_in_mbs_minus1 + 1;
      sps.picWidthInSamples = sps.picWidthInMbs * 16;
      sps.picHeightInMapUnits = sps.pic_height_in_map_units_minus1 + 1;
      sps.picSizeInMapUnits = sps.picWidthInMbs * sps.picHeightInMapUnits;
      sps.frame_mbs_only_flag = bits.read_bit();
      sps.frameHeightInMbs = (2 - sps.frame_mbs_only_flag) * sps.picHeightInMapUnits;
      if (!sps.frame_mbs_only_flag) {
        sps.mb_adaptive_frame_field_flag = bits.read_bit();
      }
      direct_8x8_inference_flag = bits.read_bit();
      frame_cropping_flag = bits.read_bit();
      if (frame_cropping_flag) {
        sps.frame_crop_left_offset = bits.read_ue();
        sps.frame_crop_right_offset = bits.read_ue();
        sps.frame_crop_top_offset = bits.read_ue();
        sps.frame_crop_bottom_offset = bits.read_ue();
      } else {
        sps.frame_crop_left_offset = 0;
        sps.frame_crop_right_offset = 0;
        sps.frame_crop_top_offset = 0;
        sps.frame_crop_bottom_offset = 0;
      }
      vui_parameters_present_flag = bits.read_bit();
      if (vui_parameters_present_flag) {
        api.read_vui_parameters(bits);
      }
      rbsp_stop_one_bit = bits.read_bit();
      if (rbsp_stop_one_bit !== 1) {
        logger.warn("warn: malformed SPS data: rbsp_stop_one_bit must be 1");
      }
      zero_bits_sum = bits.read_until_byte_aligned();
      if (zero_bits_sum !== 0) {
        logger.warn("warn: malformed SPS data: rbsp_alignment_zero_bit must be all zeroes");
      }
      if (bits.get_remaining_bits() !== 0) {
        logger.warn("warn: malformed SPS length");
      }
      return sps;
    },
    read_slice_data: function(bits, opts) {
      var currMbAddr, moreDataFlag, prevMbSkipped, sliceTypeString;
      if (pps.entropy_coding_mode_flag) {
        bits.read_until_byte_aligned();
      }
      currMbAddr = opts.sliceHeader.first_mb_in_slice * (1 + opts.sliceHeader.mbaffFrameFlag);
      moreDataFlag = 1;
      prevMbSkipped = 0;
      return sliceTypeString = api.getSliceTypeString(opts.sliceHeader.slice_type);
    },
    read_ref_pic_list_mvc_modification: function(opts) {
      throw new Error("Not implemented");
    },
    read_ref_pic_list_modification: function(bits, opts) {
      var abs_diff_pic_num_minus1, l0, long_term_pic_num, modification_of_pic_nums_idc, ref, ref_pic_list_modification_flag_l0, ref_pic_list_modification_flag_l1, sliceHeader;
      sliceHeader = opts.sliceHeader;
      if ((ref = sliceHeader.slice_type % 5) !== 2 && ref !== 4) {
        ref_pic_list_modification_flag_l0 = bits.read_bit();
        if (ref_pic_list_modification_flag_l0) {
          if (sliceHeader.num_ref_idx_active_override_flag) {
            l0 = sliceHeader.num_ref_idx_l0_active_minus1 + 1;
          } else {
            l0 = pps.num_ref_idx_l0_default_active_minus1 + 1;
          }
          while (true) {
            modification_of_pic_nums_idc = bits.read_ue();
            if (modification_of_pic_nums_idc === 0 || modification_of_pic_nums_idc === 1) {
              abs_diff_pic_num_minus1 = bits.read_ue();
            } else if (modification_of_pic_nums_idc === 2) {
              long_term_pic_num = bits.read_ue();
            }
            if (modification_of_pic_nums_idc === 3) {
              break;
            }
          }
        }
      }
      if (sliceHeader.slice_type % 5 === 1) {
        ref_pic_list_modification_flag_l1 = bits.read_bit();
        if (ref_pic_list_modification_flag_l1) {
          while (true) {
            modification_of_pic_nums_idc = bits.read_ue();
            if (modification_of_pic_nums_idc === 0 || modification_of_pic_nums_idc === 1) {
              abs_diff_pic_num_minus1 = bits.read_ue();
            } else if (modification_of_pic_nums_idc === 2) {
              long_term_pic_num = bits.read_ue();
            }
            if (modification_of_pic_nums_idc === 3) {
              break;
            }
          }
        }
      }
    },
    read_pred_weight_table: function(bits, opts) {
      var chroma_log2_weight_denom, chroma_offset_10, chroma_offset_11, chroma_weight_10, chroma_weight_10_flag, chroma_weight_11, chroma_weight_11_flag, i, j, k, l, luma_log2_weight_denom, luma_offset_10, luma_offset_11, luma_weight_10, luma_weight_10_flag, luma_weight_11, luma_weight_11_flag, m, ref, ref1, results, sliceHeader;
      sliceHeader = opts.sliceHeader;
      luma_log2_weight_denom = bits.read_ue();
      if (sps.chromaArrayType == null) {
        throw new Error("ChromaArrayType isn't set");
      }
      if (sps.chromaArrayType !== 0) {
        chroma_log2_weight_denom = bits.read_ue();
      }
      luma_weight_10 = [];
      luma_offset_10 = [];
      chroma_weight_10 = [];
      chroma_offset_10 = [];
      for (i = k = 0, ref = sliceHeader.num_ref_idx_l0_active_minus1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        luma_weight_10_flag = bits.read_bit();
        if (luma_weight_10_flag) {
          luma_weight_10[i] = bits.read_se();
          luma_offset_10[i] = bits.read_se();
        }
        if (sps.chromaArrayType !== 0) {
          chroma_weight_10_flag = bits.read_bit();
          if (chroma_weight_10_flag) {
            chroma_weight_10[i] = [];
            chroma_offset_10[i] = [];
            for (j = l = 0; l < 2; j = ++l) {
              chroma_weight_10[i][j] = bits.read_se();
              chroma_offset_10[i][j] = bits.read_se();
            }
          }
        }
      }
      if (sliceHeader.slice_type % 5 === 1) {
        luma_weight_11 = [];
        luma_offset_11 = [];
        chroma_weight_11 = [];
        chroma_offset_11 = [];
        results = [];
        for (i = m = 0, ref1 = sliceHeader.num_ref_idx_l1_active_minus1; 0 <= ref1 ? m <= ref1 : m >= ref1; i = 0 <= ref1 ? ++m : --m) {
          luma_weight_11_flag = bits.read_bit();
          if (luma_weight_11_flag) {
            luma_weight_11[i] = bits.read_se();
            luma_offset_11[i] = bits.read_se();
          }
          if (sps.chromaArrayType !== 0) {
            chroma_weight_11_flag = bits.read_bit();
            if (chroma_weight_11_flag) {
              chroma_weight_11[i] = [];
              chroma_offset_11[i] = [];
              results.push((function() {
                var n, results1;
                results1 = [];
                for (j = n = 0; n < 2; j = ++n) {
                  chroma_weight_11[i][j] = bits.read_se();
                  results1.push(chroma_offset_11[i][j] = bits.read_se());
                }
                return results1;
              })());
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    },
    read_dec_ref_pic_marking: function(bits, opts) {
      var adaptive_ref_pic_marking_mode_flag, difference_of_pic_nums_minus1, long_term_frame_idx, long_term_pic_num, long_term_reference_flag, max_long_term_frame_idx_plus1, memory_management_control_operation, no_output_of_prior_pics_flag, results, sliceHeader;
      sliceHeader = opts.sliceHeader;
      if (sliceHeader.idrPicFlag) {
        no_output_of_prior_pics_flag = bits.read_bit();
        return long_term_reference_flag = bits.read_bit();
      } else {
        adaptive_ref_pic_marking_mode_flag = bits.read_bit();
        if (adaptive_ref_pic_marking_mode_flag) {
          results = [];
          while (true) {
            memory_management_control_operation = bits.read_ue();
            if (memory_management_control_operation === 1 || memory_management_control_operation === 3) {
              difference_of_pic_nums_minus1 = bits.read_ue();
            }
            if (memory_management_control_operation === 2) {
              long_term_pic_num = bits.read_ue();
            }
            if (memory_management_control_operation === 3 || memory_management_control_operation === 6) {
              long_term_frame_idx = bits.read_ue();
            }
            if (memory_management_control_operation === 4) {
              max_long_term_frame_idx_plus1 = bits.read_ue();
            }
            if (memory_management_control_operation === 0) {
              break;
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      }
    },
    read_slice_header: function(bits, opts) {
      var cabac_init_idc, colour_plane_id, direct_spatial_mv_pred_flag, disable_deblocking_filter_idc, numBits, redundant_pic_cnt, sliceHeader, sliceTypeString, slice_alpha_c0_offset_div2, slice_beta_offset_div2, slice_qs_delta;
      sliceHeader = opts.sliceHeader = {};
      if (opts.nalHeader.nal_unit_type === api.NAL_UNIT_TYPE_IDR_PICTURE) {
        sliceHeader.idrPicFlag = 1;
      } else {
        sliceHeader.idrPicFlag = 0;
      }
      sliceHeader.first_mb_in_slice = bits.read_ue();
      sliceHeader.slice_type = bits.read_ue();
      sliceHeader.pic_parameter_set_id = bits.read_ue();
      if (sps.separate_colour_plane_flag === 1) {
        colour_plane_id = bits.read_bits(2);
      }
      sliceHeader.frame_num = bits.read_bits(sps.log2_max_frame_num_minus4 + 4);
      if (!sps.frame_mbs_only_flag) {
        sliceHeader.field_pic_flag = bits.read_bit();
        if (sliceHeader.field_pic_flag) {
          sliceHeader.bottom_field_flag = bits.read_bit();
        }
      }
      if (sps.mb_adaptive_frame_field_flag && !sliceHeader.field_pic_flag) {
        sliceHeader.mbaffFrameFlag = 1;
      } else {
        sliceHeader.mbaffFrameFlag = 0;
      }
      if (sliceHeader.idrPicFlag) {
        sliceHeader.idr_pic_id = bits.read_ue();
      }
      if (sps.pic_order_cnt_type === 0) {
        sliceHeader.pic_order_cnt_lsb = bits.read_bits(sps.log2_max_pic_order_cnt_lsb_minus4 + 4);
        if (pps.bottom_field_pic_order_in_frame_present_flag && !sliceHeader.field_pic_flag) {
          sliceHeader.delta_pic_order_cnt_bottom = bits.read_se();
        }
      }
      if ((sps.pic_order_cnt_type === 1) && (!delta_pic_order_always_zero_flag)) {
        sliceHeader.delta_pic_order_cnt_0 = bits.read_se();
        if (pps.bottom_field_pic_order_in_frame_present_flag && !sliceHeader.field_pic_flag) {
          sliceHeader.delta_pic_order_cnt_1 = bits.read_se();
        }
      }
      if (pps.redundant_pic_cnt_present_flag) {
        redundant_pic_cnt = bits.read_ue();
      }
      sliceTypeString = api.getSliceTypeString(sliceHeader.slice_type);
      if (sliceTypeString === 'B') {
        direct_spatial_mv_pred_flag = bits.read_bit();
      }
      if (sliceTypeString === 'P' || sliceTypeString === 'SP' || sliceTypeString === 'B') {
        sliceHeader.num_ref_idx_active_override_flag = bits.read_bit();
        if (sliceHeader.num_ref_idx_active_override_flag) {
          sliceHeader.num_ref_idx_l0_active_minus1 = bits.read_ue();
          if (sliceTypeString === 'B') {
            sliceHeader.num_ref_idx_l1_active_minus1 = bits.read_ue();
          }
        }
      }
      if (opts.nalHeader.nal_unit_type === 20) {
        api.read_ref_pic_list_mvc_modification(opts);
      } else {
        api.read_ref_pic_list_modification(bits, opts);
      }
      if ((pps.weighted_pred_flag && (sliceTypeString === 'P' || sliceTypeString === 'SP')) || (pps.weighted_bipred_idc === 1 && sliceTypeString === 'B')) {
        api.read_pred_weight_table(bits, opts);
      }
      if (opts.nalHeader.nal_ref_idc !== 0) {
        api.read_dec_ref_pic_marking(bits, opts);
      }
      if (pps.entropy_coding_mode_flag && (sliceTypeString !== 'I' && sliceTypeString !== 'SI')) {
        cabac_init_idc = bits.read_ue();
      }
      sliceHeader.slice_qp_delta = bits.read_se();
      if (sliceTypeString === 'SP' || sliceTypeString === 'SI') {
        if (sliceTypeString === 'SP') {
          sliceHeader.sp_for_switch_flag = bits.read_bit();
        }
        slice_qs_delta = bits.read_se();
      }
      if (pps.deblocking_filter_control_present_flag) {
        disable_deblocking_filter_idc = bits.read_ue();
        if (disable_deblocking_filter_idc !== 1) {
          slice_alpha_c0_offset_div2 = bits.read_se();
          slice_beta_offset_div2 = bits.read_se();
        }
      }
      if ((pps.num_slice_groups_minus1 > 0) && ((3 <= slice_group_map_type && slice_group_map_type <= 5))) {
        numBits = Math.ceil(Math.log(sps.picSizeInMapUnits + pps.slice_group_change_rate_minus1 + 1) / Math.LN2);
        return sliceHeader.slice_group_change_cycle = bits.read_bits(numBits);
      }
    },
    _isSamePicture: function(nalData1, nalData2) {
      var elem, k, len, ref;
      ref = ['pic_parameter_set_id', 'frame_num', 'field_pic_flag', 'bottom_field_flag', 'idr_pic_id', 'pic_order_cnt_lsb', 'delta_pic_order_cnt_bottom', 'delta_pic_order_cnt_0', 'delta_pic_order_cnt_1', 'sp_for_switch_flag', 'slice_group_change_cycle'];
      for (k = 0, len = ref.length; k < len; k++) {
        elem = ref[k];
        if (nalData1.sliceHeader[elem] !== nalData2.sliceHeader[elem]) {
          return false;
        }
      }
      return true;
    },
    isSamePicture: function(nalUnit1, nalUnit2) {
      var nalData1, nalData2;
      nalData1 = api.parseNALUnit(nalUnit1);
      nalData2 = api.parseNALUnit(nalUnit2);
      return api._isSamePicture(nalData1, nalData2);
    },
    parseNALUnit: function(nalUnit) {
      var bits, data, ref;
      data = {};
      nalUnit = api.removeEmulationPreventionByte(nalUnit);
      bits = new Bits(nalUnit);
      data.nalHeader = api.read_nal_header(bits);
      if ((ref = data.nalHeader.nal_unit_type) === api.NAL_UNIT_TYPE_NON_IDR_PICTURE || ref === api.NAL_UNIT_TYPE_IDR_PICTURE) {
        api.read_slice_header(bits, data);
      }
      return data;
    },
    removeEmulationPreventionByte: function(nalUnit) {
      var currentSrcPos, emulPos, i, k, len, newBuf, pos, removeBytePositions, searchPos;
      searchPos = 0;
      removeBytePositions = [];
      while (true) {
        emulPos = Bits.searchBytesInArray(nalUnit, [0x00, 0x00, 0x03], searchPos);
        if (emulPos === -1) {
          break;
        }
        removeBytePositions.push(emulPos + 2);
        searchPos = emulPos + 3;
      }
      if (removeBytePositions.length > 0) {
        newBuf = new Buffer(nalUnit.length - removeBytePositions.length);
        currentSrcPos = 0;
        for (i = k = 0, len = removeBytePositions.length; k < len; i = ++k) {
          pos = removeBytePositions[i];
          nalUnit.copy(newBuf, currentSrcPos - i, currentSrcPos, pos);
          currentSrcPos = pos + 1;
        }
        if (currentSrcPos < nalUnit.length) {
          nalUnit.copy(newBuf, currentSrcPos - removeBytePositions.length, currentSrcPos, nalUnit.length);
        }
        nalUnit = newBuf;
      }
      return nalUnit;
    },
    getNextNALUnit: function() {
      var nalUnit, nalUnitType, startCodePos;
      if (!api.hasMoreData()) {
        return null;
      }
      startCodePos = Bits.searchBytesInArray(videoBuf, [0x00, 0x00, 0x01], 0);
      if (startCodePos === -1) {
        nalUnit = videoBuf;
        videoBuf = [];
        return nalUnit;
      }
      nalUnit = videoBuf.slice(0, startCodePos);
      videoBuf = videoBuf.slice(startCodePos + 3);
      while (nalUnit[nalUnit.length - 1] === 0x00) {
        nalUnit = nalUnit.slice(0, nalUnit.length - 1);
      }
      if (nalUnit.length > 0) {
        nalUnitType = nalUnit[0] & 0x1f;
        if (nalUnitType === api.NAL_UNIT_TYPE_SPS) {
          api.readSPS(nalUnit);
        } else if (nalUnitType === api.NAL_UNIT_TYPE_PPS) {
          api.readPPS(nalUnit);
        } else if (nalUnitType === api.NAL_UNIT_TYPE_SEI) {
          api.readSEI(nalUnit);
        }
        return nalUnit;
      } else {
        return api.getNextNALUnit();
      }
    },
    clip3: function(x, y, z) {
      if (z < x) {
        return x;
      }
      if (z > y) {
        return y;
      }
      return z;
    },
    decodeBypass: function(bits, vars) {
      vars.codIOffset <<= 1;
      vars.codIOffset |= bits.read_bit();
      if (vars.codIOffset >= vars.codIRange) {
        vars.binVal = 1;
        return vars.codIOffset -= vars.codIRange;
      } else {
        return vars.binVal = 0;
      }
    },
    deriveCtxIdx: function(input) {
      var binIdx, ctxIdxInc, ctxIdxOffset, maxBinIdxCtx;
      binIdx = input.binIdx;
      maxBinIdxCtx = input.maxBinIdxCtx;
      ctxIdxOffset = input.ctxIdxOffset;
      ctxIdxInc = null;
      return {
        ctxIdx: 0
      };
    },
    renormD: function(bits, vars) {
      var results;
      results = [];
      while (vars.codIRange < 256) {
        vars.codIRange <<= 1;
        vars.codIOffset <<= 1;
        results.push(vars.codIOffset |= bits.read_bit());
      }
      return results;
    },
    decodeTerminate: function(bits, vars) {
      vars.codIRange -= 2;
      if (vars.codIOffset >= vars.codIRange) {
        return vars.binVal = 1;
      } else {
        vars.binVal = 0;
        return api.renormD(bits);
      }
    },
    decodeDecision: function(vars) {
      var codIRangeLPS, qCodIRangeIdx;
      qCodIRangeIdx = (vars.codIRange >> 6) & 3;
      codIRangeLPS = rangeTabLPS[vars.pStateIdx][qCodIRangeIdx];
      vars.codIRange -= codIRangeLPS;
      if (vars.codIOffset >= vars.codIRange) {
        vars.binVal = 1 - vars.valMPS;
        vars.codIOffset -= vars.codIRange;
        vars.codIRange = codIRangeLPS;
      } else {
        vars.binVal = vars.valMPS;
      }
      if (vars.binVal === vars.valMPS) {
        vars.pStateIdx = transIdxMPS(vars.pStateIdx);
      } else {
        if (vars.pStateIdx === 0) {
          vars.valMPS = 1 - vars.valMPS;
        }
        vars.pStateIdx = transIdxLPS(vars.pStateIdx);
      }
      return api.renormD(vars);
    },
    read_ae: function(bits, opts) {
      throw new Error("Not implemented");
    },
    read_nal_unit_header_svc_extension: function() {
      throw new Error("Not implemented");
    },
    read_nal_unit_header_mvc_extension: function() {
      throw new Error("Not implemented");
    },
    read_nal_header: function(bits) {
      var forbidden_zero_bit, nalHeader, ref, svc_extension_flag;
      nalHeader = {};
      forbidden_zero_bit = bits.read_bit();
      nalHeader.nal_ref_idc = bits.read_bits(2);
      nalHeader.nal_unit_type = bits.read_bits(5);
      if ((ref = nalHeader.nal_unit_type) === 14 || ref === 20) {
        svc_extension_flag = bits.read_bit();
        if (svc_extension_flag) {
          api.read_nal_unit_header_svc_extension();
        } else {
          api.read_nal_unit_header_mvc_extension();
        }
      }
      return nalHeader;
    },
    read_hrd_parameters: function(bits) {
      var bit_rate_scale, bit_rate_value_minus1, cbr_flag, cpb_cnt_minus1, cpb_removal_delay_length_minus1, cpb_size_scale, cpb_size_value_minus1, dpb_output_delay_length_minus1, initial_cpb_removal_delay_length_minus1, k, ref, schedSelIdx, time_offset_length;
      cpb_cnt_minus1 = bits.read_ue();
      bit_rate_scale = bits.read_bits(4);
      cpb_size_scale = bits.read_bits(4);
      bit_rate_value_minus1 = [];
      cpb_size_value_minus1 = [];
      cbr_flag = [];
      for (schedSelIdx = k = 0, ref = cpb_cnt_minus1; 0 <= ref ? k <= ref : k >= ref; schedSelIdx = 0 <= ref ? ++k : --k) {
        bit_rate_value_minus1[schedSelIdx] = bits.read_ue();
        cpb_size_value_minus1[schedSelIdx] = bits.read_ue();
        cbr_flag[schedSelIdx] = bits.read_bit();
      }
      initial_cpb_removal_delay_length_minus1 = bits.read_bits(5);
      cpb_removal_delay_length_minus1 = bits.read_bits(5);
      dpb_output_delay_length_minus1 = bits.read_bits(5);
      return time_offset_length = bits.read_bits(5);
    },
    read_vui_parameters: function(bits) {
      var vui;
      vui = {};
      vui.aspect_ratio_info_present_flag = bits.read_bit();
      if (vui.aspect_ratio_info_present_flag) {
        vui.aspect_ratio_idc = bits.read_bits(8);
        if (vui.aspect_ratio_idc === ASPECT_RATIO_IDC_EXTENDED_SAR) {
          vui.sar_width = bits.read_bits(16);
          vui.sar_height = bits.read_bits(16);
        }
      }
      vui.overscan_info_present_flag = bits.read_bit();
      if (vui.overscan_info_present_flag) {
        vui.overscan_appropriate_flag = bits.read_bit();
      }
      vui.video_signal_type_present_flag = bits.read_bit();
      if (vui.video_signal_type_present_flag) {
        vui.video_format = bits.read_bits(3);
        vui.video_full_range_flag = bits.read_bit();
        vui.colour_description_present_flag = bits.read_bit();
        if (vui.colour_description_present_flag) {
          vui.colour_primaries = bits.read_bits(8);
          vui.transfer_characteristics = bits.read_bits(8);
          vui.matrix_coefficients = bits.read_bits(8);
        }
      }
      vui.chroma_loc_info_present_flag = bits.read_bit();
      if (vui.chroma_loc_info_present_flag === 1) {
        vui.chroma_sample_loc_type_top_field = bits.read_ue();
        vui.chroma_sample_loc_type_bottom_field = bits.read_ue();
      }
      vui.timing_info_present_flag = bits.read_bit();
      if (vui.timing_info_present_flag) {
        vui.num_units_in_tick = bits.read_bits(32);
        vui.time_scale = bits.read_bits(32);
        vui.fixed_frame_rate_flag = bits.read_bit();
      }
      vui.nal_hrd_parameters_present_flag = bits.read_bit();
      if (vui.nal_hrd_parameters_present_flag) {
        api.read_hrd_parameters(bits);
      }
      vui.vcl_hrd_parameters_present_flag = bits.read_bit();
      if (vui.vcl_hrd_parameters_present_flag) {
        api.read_hrd_parameters(bits);
      }
      if (vui.nal_hrd_parameters_present_flag || vui.vcl_hrd_parameters_present_flag) {
        vui.low_delay_hrd_flag = bits.read_bit();
      }
      vui.pic_struct_present_flag = bits.read_bit();
      vui.bitstream_restriction_flag = bits.read_bit();
      if (vui.bitstream_restriction_flag) {
        vui.motion_vectors_over_pic_boundaries_flag = bits.read_bit();
        vui.max_bytes_per_pic_denom = bits.read_ue();
        vui.max_bits_per_mb_denom = bits.read_ue();
        vui.log2_max_mv_length_horizontal = bits.read_ue();
        vui.log2_max_mv_length_vertical = bits.read_ue();
        vui.max_num_reorder_frames = bits.read_ue();
        return vui.max_dec_frame_buffering = bits.read_ue();
      }
    },
    search_rbsp_stop_one_bit: function(bits) {
      return bits.lastIndexOfBit(1);
    },
    more_rbsp_data: function(bits) {
      var currPos, remaining_bits, stop_bit_pos;
      remaining_bits = bits.get_remaining_bits();
      if (remaining_bits === 0) {
        return false;
      }
      stop_bit_pos = api.search_rbsp_stop_one_bit(bits);
      if (stop_bit_pos == null) {
        throw new Error("stop_one_bit is not found");
      }
      currPos = bits.current_position();
      if ((stop_bit_pos.byte > currPos.byte) || (stop_bit_pos.bit > currPos.bit)) {
        return true;
      } else {
        return false;
      }
    },
    concatWithStartCodePrefix: function(bufs) {
      var buf, k, len, nalUnitsWithStartCodePrefix, startCodePrefix, totalLen;
      nalUnitsWithStartCodePrefix = [];
      startCodePrefix = new Buffer([0x00, 0x00, 0x00, 0x01]);
      totalLen = 0;
      for (k = 0, len = bufs.length; k < len; k++) {
        buf = bufs[k];
        nalUnitsWithStartCodePrefix.push(startCodePrefix);
        nalUnitsWithStartCodePrefix.push(buf);
        totalLen += 4 + buf.length;
      }
      return Buffer.concat(nalUnitsWithStartCodePrefix, totalLen);
    },
    readAVCDecoderConfigurationRecord: function(bits) {
      var i, info, k, l, ppsLen, ref, ref1, spsLen;
      info = {};
      info.configurationVersion = bits.read_byte();
      if (info.configurationVersion !== 1) {
        throw new Error("configurationVersion is not 1: " + info.configurationVersion);
      }
      info.avcProfileIndication = bits.read_byte();
      info.profile_compatibility = bits.read_byte();
      info.avcLevelIndication = bits.read_byte();
      bits.skip_bits(6);
      info.lengthSizeMinusOne = bits.read_bits(2);
      info.nalUnitLengthSize = info.lengthSizeMinusOne + 1;
      bits.skip_bits(3);
      info.numOfSPS = bits.read_bits(5);
      info.sps = [];
      for (i = k = 0, ref = info.numOfSPS; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        spsLen = bits.read_bits(16);
        info.sps.push(bits.read_bytes(spsLen));
      }
      info.numOfPPS = bits.read_byte();
      info.pps = [];
      for (i = l = 0, ref1 = info.numOfPPS; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
        ppsLen = bits.read_bits(16);
        info.pps.push(bits.read_bytes(ppsLen));
      }
      return info;
    },
    parseSpropParameterSets: function(str) {
      var base64String, k, len, nalUnits, ref;
      nalUnits = [];
      ref = str.split(',');
      for (k = 0, len = ref.length; k < len; k++) {
        base64String = ref[k];
        nalUnits.push(new Buffer(base64String, 'base64'));
      }
      return nalUnits;
    }
  };

  module.exports = api;

}).call(this);
